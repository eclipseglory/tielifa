(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebGL2D"] = factory();
	else
		root["tielifa"] = root["tielifa"] || {}, root["tielifa"]["WebGL2D"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./github/src/geometry/EarClipping.js":
/*!********************************************!*\
  !*** ./github/src/geometry/EarClipping.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Node = __webpack_require__(/*! ./Node.js */ \"./github/src/geometry/Node.js\");\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EarClipping = function () {\n    function EarClipping() {\n        _classCallCheck(this, EarClipping);\n    }\n\n    _createClass(EarClipping, null, [{\n        key: 'earcut',\n        value: function earcut(data, holeIndices, dim) {\n\n            dim = dim || 2;\n\n            var hasHoles = holeIndices && holeIndices.length,\n                outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n                outerNode = this.linkedList(data, 0, outerLen, dim, true),\n                triangles = [];\n\n            if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n            var minX = void 0,\n                minY = void 0,\n                maxX = void 0,\n                maxY = void 0,\n                x = void 0,\n                y = void 0,\n                invSize = void 0;\n\n            if (hasHoles) outerNode = this.eliminateHoles(data, holeIndices, outerNode, dim);\n\n            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n            if (data.length > 80 * dim) {\n                minX = maxX = data[0];\n                minY = maxY = data[1];\n\n                for (var i = dim; i < outerLen; i += dim) {\n                    x = data[i];\n                    y = data[i + 1];\n                    if (x < minX) minX = x;\n                    if (y < minY) minY = y;\n                    if (x > maxX) maxX = x;\n                    if (y > maxY) maxY = y;\n                }\n\n                // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n                invSize = Math.max(maxX - minX, maxY - minY);\n                invSize = invSize !== 0 ? 1 / invSize : 0;\n            }\n\n            this.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n            return triangles;\n        }\n\n        // create a circular doubly linked list from polygon points in the specified winding order\n\n    }, {\n        key: 'linkedList',\n        value: function linkedList(data, start, end, dim, clockwise) {\n            var i, last;\n\n            if (clockwise === EarClipping.signedArea(data, start, end, dim) > 0) {\n                for (i = start; i < end; i += dim) {\n                    last = this.insertNode(i, data[i], data[i + 1], last);\n                }\n            } else {\n                for (i = end - dim; i >= start; i -= dim) {\n                    last = this.insertNode(i, data[i], data[i + 1], last);\n                }\n            }\n\n            if (last && EarClipping.equals(last, last.next)) {\n                this.removeNode(last);\n                last = last.next;\n            }\n\n            return last;\n        }\n\n        // eliminate colinear or duplicate points\n\n    }, {\n        key: 'filterPoints',\n        value: function filterPoints(start, end) {\n            if (!start) return start;\n            if (!end) end = start;\n\n            var p = start,\n                again;\n            do {\n                again = false;\n\n                if (!p.steiner && (EarClipping.equals(p, p.next) || EarClipping.area(p.prev, p, p.next) === 0)) {\n                    this.removeNode(p);\n                    p = end = p.prev;\n                    if (p === p.next) break;\n                    again = true;\n                } else {\n                    p = p.next;\n                }\n            } while (again || p !== end);\n\n            return end;\n        }\n\n        // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n    }, {\n        key: 'earcutLinked',\n        value: function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n            if (!ear) return;\n\n            // interlink polygon nodes in z-order\n            if (!pass && invSize) this.indexCurve(ear, minX, minY, invSize);\n\n            var stop = ear,\n                prev,\n                next;\n\n            // iterate through ears, slicing them one by one\n            while (ear.prev !== ear.next) {\n                prev = ear.prev;\n                next = ear.next;\n\n                if (invSize ? this.isEarHashed(ear, minX, minY, invSize) : this.isEar(ear)) {\n                    // cut off the triangle\n                    triangles.push(prev.i / dim);\n                    triangles.push(ear.i / dim);\n                    triangles.push(next.i / dim);\n\n                    this.removeNode(ear);\n\n                    // skipping the next vertex leads to less sliver triangles\n                    ear = next.next;\n                    stop = next.next;\n\n                    continue;\n                }\n\n                ear = next;\n\n                // if we looped through the whole remaining polygon and can't find any more ears\n                if (ear === stop) {\n                    // try filtering points and slicing again\n                    if (!pass) {\n                        this.earcutLinked(this.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                        // if this didn't work, try curing all small self-intersections locally\n                    } else if (pass === 1) {\n                        ear = this.cureLocalIntersections(ear, triangles, dim);\n                        this.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                        // as a last resort, try splitting the remaining polygon into two\n                    } else if (pass === 2) {\n                        this.splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // check whether a polygon node forms a valid ear with adjacent nodes\n\n    }, {\n        key: 'isEar',\n        value: function isEar(ear) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // now make sure we don't have other points inside the potential ear\n            var p = ear.next.next;\n\n            while (p !== ear.prev) {\n                if (this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.next;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'isEarHashed',\n        value: function isEarHashed(ear, minX, minY, invSize) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // triangle bbox; min & max are calculated like this for speed\n            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n                minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n                maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n                maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n\n            // z-order range for the current triangle bbox;\n            var minZ = this.zOrder(minTX, minTY, minX, minY, invSize),\n                maxZ = this.zOrder(maxTX, maxTY, minX, minY, invSize);\n\n            var p = ear.prevZ,\n                n = ear.nextZ;\n\n            // look for points inside the triangle in both directions\n            while (p && p.z >= minZ && n && n.z <= maxZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            // look for remaining points in decreasing z-order\n            while (p && p.z >= minZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n            }\n\n            // look for remaining points in increasing z-order\n            while (n && n.z <= maxZ) {\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            return true;\n        }\n\n        // go through all polygon nodes and cure small local self-intersections\n\n    }, {\n        key: 'cureLocalIntersections',\n        value: function cureLocalIntersections(start, triangles, dim) {\n            var p = start;\n            do {\n                var a = p.prev,\n                    b = p.next.next;\n\n                if (!EarClipping.equals(a, b) && this.intersects(a, p, p.next, b) && this.locallyInside(a, b) && this.locallyInside(b, a)) {\n\n                    triangles.push(a.i / dim);\n                    triangles.push(p.i / dim);\n                    triangles.push(b.i / dim);\n\n                    // remove two nodes involved\n                    this.removeNode(p);\n                    this.removeNode(p.next);\n\n                    p = start = b;\n                }\n                p = p.next;\n            } while (p !== start);\n\n            return p;\n        }\n\n        // try splitting polygon into two and triangulate them independently\n\n    }, {\n        key: 'splitEarcut',\n        value: function splitEarcut(start, triangles, dim, minX, minY, invSize) {\n            // look for a valid diagonal that divides the polygon into two\n            var a = start;\n            do {\n                var b = a.next.next;\n                while (b !== a.prev) {\n                    if (a.i !== b.i && this.isValidDiagonal(a, b)) {\n                        // split the polygon in two by the diagonal\n                        var c = this.splitPolygon(a, b);\n\n                        // filter colinear points around the cuts\n                        a = this.filterPoints(a, a.next);\n                        c = this.filterPoints(c, c.next);\n\n                        // run earcut on each half\n                        this.earcutLinked(a, triangles, dim, minX, minY, invSize);\n                        this.earcutLinked(c, triangles, dim, minX, minY, invSize);\n                        return;\n                    }\n                    b = b.next;\n                }\n                a = a.next;\n            } while (a !== start);\n        }\n\n        // link every hole into the outer loop, producing a single-ring polygon without holes\n\n    }, {\n        key: 'eliminateHoles',\n        value: function eliminateHoles(data, holeIndices, outerNode, dim) {\n            var queue = [],\n                i,\n                len,\n                start,\n                end,\n                list;\n\n            for (i = 0, len = holeIndices.length; i < len; i++) {\n                start = holeIndices[i] * dim;\n                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                list = this.linkedList(data, start, end, dim, false);\n                if (list === list.next) list.steiner = true;\n                queue.push(this.getLeftmost(list));\n            }\n\n            queue.sort(this.compareX);\n\n            // process holes from left to right\n            for (i = 0; i < queue.length; i++) {\n                this.eliminateHole(queue[i], outerNode);\n                outerNode = this.filterPoints(outerNode, outerNode.next);\n            }\n\n            return outerNode;\n        }\n    }, {\n        key: 'compareX',\n        value: function compareX(a, b) {\n            return a.x - b.x;\n        }\n\n        // find a bridge between vertices that connects hole with an outer ring and and link it\n\n    }, {\n        key: 'eliminateHole',\n        value: function eliminateHole(hole, outerNode) {\n            outerNode = this.findHoleBridge(hole, outerNode);\n            if (outerNode) {\n                var b = this.splitPolygon(outerNode, hole);\n                this.filterPoints(b, b.next);\n            }\n        }\n\n        // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n    }, {\n        key: 'findHoleBridge',\n        value: function findHoleBridge(hole, outerNode) {\n            var p = outerNode,\n                hx = hole.x,\n                hy = hole.y,\n                qx = -Infinity,\n                m;\n\n            // find a segment intersected by a ray from the hole's leftmost point to the left;\n            // segment's endpoint with lesser x will be potential connection point\n            do {\n                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                    if (x <= hx && x > qx) {\n                        qx = x;\n                        if (x === hx) {\n                            if (hy === p.y) return p;\n                            if (hy === p.next.y) return p.next;\n                        }\n                        m = p.x < p.next.x ? p : p.next;\n                    }\n                }\n                p = p.next;\n            } while (p !== outerNode);\n\n            if (!m) return null;\n\n            if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n            // look for points inside the triangle of hole point, segment intersection and endpoint;\n            // if there are no points found, we have a valid connection;\n            // otherwise choose the point of the minimum angle with the ray as connection point\n\n            var stop = m,\n                mx = m.x,\n                my = m.y,\n                tanMin = Infinity,\n                tan;\n\n            p = m.next;\n\n            while (p !== stop) {\n                if (hx >= p.x && p.x >= mx && hx !== p.x && this.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n                    tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                    if ((tan < tanMin || tan === tanMin && p.x > m.x) && this.locallyInside(p, hole)) {\n                        m = p;\n                        tanMin = tan;\n                    }\n                }\n\n                p = p.next;\n            }\n\n            return m;\n        }\n\n        // interlink polygon nodes in z-order\n\n    }, {\n        key: 'indexCurve',\n        value: function indexCurve(start, minX, minY, invSize) {\n            var p = start;\n            do {\n                if (p.z === null) p.z = this.zOrder(p.x, p.y, minX, minY, invSize);\n                p.prevZ = p.prev;\n                p.nextZ = p.next;\n                p = p.next;\n            } while (p !== start);\n\n            p.prevZ.nextZ = null;\n            p.prevZ = null;\n\n            this.sortLinked(p);\n        }\n\n        // Simon Tatham's linked list merge sort algorithm\n        // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n    }, {\n        key: 'sortLinked',\n        value: function sortLinked(list) {\n            var i,\n                p,\n                q,\n                e,\n                tail,\n                numMerges,\n                pSize,\n                qSize,\n                inSize = 1;\n\n            do {\n                p = list;\n                list = null;\n                tail = null;\n                numMerges = 0;\n\n                while (p) {\n                    numMerges++;\n                    q = p;\n                    pSize = 0;\n                    for (i = 0; i < inSize; i++) {\n                        pSize++;\n                        q = q.nextZ;\n                        if (!q) break;\n                    }\n                    qSize = inSize;\n\n                    while (pSize > 0 || qSize > 0 && q) {\n\n                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                            e = p;\n                            p = p.nextZ;\n                            pSize--;\n                        } else {\n                            e = q;\n                            q = q.nextZ;\n                            qSize--;\n                        }\n\n                        if (tail) tail.nextZ = e;else list = e;\n\n                        e.prevZ = tail;\n                        tail = e;\n                    }\n\n                    p = q;\n                }\n\n                tail.nextZ = null;\n                inSize *= 2;\n            } while (numMerges > 1);\n\n            return list;\n        }\n\n        // z-order of a point given coords and inverse of the longer side of data bbox\n\n    }, {\n        key: 'zOrder',\n        value: function zOrder(x, y, minX, minY, invSize) {\n            // coords are transformed into non-negative 15-bit integer range\n            x = 32767 * (x - minX) * invSize;\n            y = 32767 * (y - minY) * invSize;\n\n            x = (x | x << 8) & 0x00FF00FF;\n            x = (x | x << 4) & 0x0F0F0F0F;\n            x = (x | x << 2) & 0x33333333;\n            x = (x | x << 1) & 0x55555555;\n\n            y = (y | y << 8) & 0x00FF00FF;\n            y = (y | y << 4) & 0x0F0F0F0F;\n            y = (y | y << 2) & 0x33333333;\n            y = (y | y << 1) & 0x55555555;\n\n            return x | y << 1;\n        }\n\n        // find the leftmost node of a polygon ring\n\n    }, {\n        key: 'getLeftmost',\n        value: function getLeftmost(start) {\n            var p = start,\n                leftmost = start;\n            do {\n                if (p.x < leftmost.x) leftmost = p;\n                p = p.next;\n            } while (p !== start);\n\n            return leftmost;\n        }\n\n        // check if a point lies within a convex triangle\n\n    }, {\n        key: 'pointInTriangle',\n        value: function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n        }\n\n        // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n    }, {\n        key: 'isValidDiagonal',\n        value: function isValidDiagonal(a, b) {\n            return a.next.i !== b.i && a.prev.i !== b.i && !this.intersectsPolygon(a, b) && this.locallyInside(a, b) && this.locallyInside(b, a) && this.middleInside(a, b);\n        }\n\n        // signed area of a triangle\n\n    }, {\n        key: 'area',\n        value: function area(p, q, r) {\n            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        }\n\n        // check if two points are equal\n\n    }, {\n        key: 'equals',\n        value: function equals(p1, p2) {\n            return p1.x === p2.x && p1.y === p2.y;\n        }\n\n        // check if two segments intersect\n\n    }, {\n        key: 'intersects',\n        value: function intersects(p1, q1, p2, q2) {\n            if (EarClipping.equals(p1, q1) && EarClipping.equals(p2, q2) || EarClipping.equals(p1, q2) && EarClipping.equals(p2, q1)) return true;\n            return EarClipping.area(p1, q1, p2) > 0 !== EarClipping.area(p1, q1, q2) > 0 && EarClipping.area(p2, q2, p1) > 0 !== EarClipping.area(p2, q2, q1) > 0;\n        }\n\n        // check if a polygon diagonal intersects any polygon segments\n\n    }, {\n        key: 'intersectsPolygon',\n        value: function intersectsPolygon(a, b) {\n            var p = a;\n            do {\n                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && this.intersects(p, p.next, a, b)) return true;\n                p = p.next;\n            } while (p !== a);\n\n            return false;\n        }\n\n        // check if a polygon diagonal is locally inside the polygon\n\n    }, {\n        key: 'locallyInside',\n        value: function locallyInside(a, b) {\n            return area(a.prev, a, a.next) < 0 ? EarClipping.area(a, b, a.next) >= 0 && EarClipping.area(a, a.prev, b) >= 0 : EarClipping.area(a, b, a.prev) < 0 || EarClipping.area(a, a.next, b) < 0;\n        }\n\n        // check if the middle point of a polygon diagonal is inside the polygon\n\n    }, {\n        key: 'middleInside',\n        value: function middleInside(a, b) {\n            var p = a,\n                inside = false,\n                px = (a.x + b.x) / 2,\n                py = (a.y + b.y) / 2;\n            do {\n                if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n                p = p.next;\n            } while (p !== a);\n\n            return inside;\n        }\n\n        // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n        // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n    }, {\n        key: 'splitPolygon',\n        value: function splitPolygon(a, b) {\n            var a2 = new _Node2.default(a.i, a.x, a.y),\n                b2 = new _Node2.default(b.i, b.x, b.y),\n                an = a.next,\n                bp = b.prev;\n\n            a.next = b;\n            b.prev = a;\n\n            a2.next = an;\n            an.prev = a2;\n\n            b2.next = a2;\n            a2.prev = b2;\n\n            bp.next = b2;\n            b2.prev = bp;\n\n            return b2;\n        }\n\n        // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n    }, {\n        key: 'insertNode',\n        value: function insertNode(i, x, y, last) {\n            var p = new _Node2.default(i, x, y);\n\n            if (!last) {\n                p.prev = p;\n                p.next = p;\n            } else {\n                p.next = last.next;\n                p.prev = last;\n                last.next.prev = p;\n                last.next = p;\n            }\n            return p;\n        }\n    }, {\n        key: 'removeNode',\n        value: function removeNode(p) {\n            p.next.prev = p.prev;\n            p.prev.next = p.next;\n\n            if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n            if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n        }\n    }, {\n        key: 'signedArea',\n        value: function signedArea(data, start, end, dim) {\n            var sum = 0;\n            for (var i = start, j = end - dim; i < end; i += dim) {\n                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n                j = i;\n            }\n            return sum;\n        }\n\n        // return a percentage difference between the polygon area and its triangulation area;\n        // used to verify correctness of triangulation\n\n    }, {\n        key: 'deviation',\n        value: function deviation(data, holeIndices, dim, triangles) {\n            var hasHoles = holeIndices && holeIndices.length;\n            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n            var polygonArea = Math.abs(this.signedArea(data, 0, outerLen, dim));\n            if (hasHoles) {\n                for (var i = 0, len = holeIndices.length; i < len; i++) {\n                    var start = holeIndices[i] * dim;\n                    var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                    polygonArea -= Math.abs(this.signedArea(data, start, end, dim));\n                }\n            }\n\n            var trianglesArea = 0;\n            for (i = 0; i < triangles.length; i += 3) {\n                var a = triangles[i] * dim;\n                var b = triangles[i + 1] * dim;\n                var c = triangles[i + 2] * dim;\n                trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n            }\n\n            return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n        }\n    }, {\n        key: 'flatten',\n\n\n        // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form EarClipping accepts\n        value: function flatten(data) {\n            var dim = data[0][0].length,\n                result = { vertices: [], holes: [], dimensions: dim },\n                holeIndex = 0;\n\n            for (var i = 0; i < data.length; i++) {\n                for (var j = 0; j < data[i].length; j++) {\n                    for (var d = 0; d < dim; d++) {\n                        result.vertices.push(data[i][j][d]);\n                    }\n                }\n                if (i > 0) {\n                    holeIndex += data[i - 1].length;\n                    result.holes.push(holeIndex);\n                }\n            }\n            return result;\n        }\n    }]);\n\n    return EarClipping;\n}();\n\nexports.default = EarClipping;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/geometry/EarClipping.js?");

/***/ }),

/***/ "./github/src/geometry/Node.js":
/*!*************************************!*\
  !*** ./github/src/geometry/Node.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function Node(i, x, y) {\n        _classCallCheck(this, Node);\n\n        // vertex index in coordinates array\n        this.i = i;\n\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n\n        // previous and next vertex nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n\n        // z-order curve value\n        this.z = null;\n\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n\n        // indicates whether this is a steiner point\n        this.steiner = false;\n};\n\nexports.default = Node;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/geometry/Node.js?");

/***/ }),

/***/ "./github/src/math/Mat4.js":
/*!*********************************!*\
  !*** ./github/src/math/Mat4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp_mat4 = undefined;\n\nvar Mat4 = function () {\n    function Mat4() {\n        _classCallCheck(this, Mat4);\n    }\n\n    _createClass(Mat4, null, [{\n        key: \"perspective2\",\n        value: function perspective2(left, top, right, bottom, near, far) {\n            return [2 * near / (right - left), 0, 0, 0, 0, 2 * near / (top - bottom), 0, 0, (right + left) / (right - left), (bottom + top) / (top - bottom), (-near - far) / (far - near), -1, 0, 0, -near * far * 2 / (far - near), 0];\n        }\n    }, {\n        key: \"perspective3\",\n        value: function perspective3(fieldOfViewInRadians, width, height, near, far) {\n            var m = this.perspective(fieldOfViewInRadians, width / height, near, far);\n            var m1 = Mat4.TEMP_MAT4[0];\n            Mat4.translationMatrix(m1, -width / 2, -height / 2, 0);\n            Mat4.multiply(m, m, m1);\n            return m;\n        }\n    }, {\n        key: \"perspective\",\n        value: function perspective(fieldOfViewInRadians, aspect, near, far) {\n            var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\n            if (_Tools2.default.equals(f, 1)) f = 1;\n            var rangeInv = 1.0 / (near - far);\n            var m = this.identity();\n            m[0] = f / aspect;\n            m[5] = -f;\n            m[10] = (near + far) * rangeInv;\n            m[11] = -1;\n            m[14] = near * far * rangeInv * 2;\n\n            // return [\n            //     f / aspect, 0, 0, 0,\n            //     0, f, 0, 0,\n            //     0, 0, (near + far) * rangeInv, -1,\n            //     0, 0, near * far * rangeInv * 2, 0\n            // ];\n            return m;\n        }\n    }, {\n        key: \"orthoProjection\",\n        value: function orthoProjection(left, top, right, bottom, near, far) {\n            return new Float32Array([2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, 2 / (near - far), 0, (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1]);\n        }\n    }, {\n        key: \"copy\",\n        value: function copy(from, to) {\n            to[0] = from[0];\n            to[1] = from[1];\n            to[2] = from[2];\n            to[3] = from[3];\n            to[4] = from[4];\n            to[5] = from[5];\n            to[6] = from[6];\n            to[7] = from[7];\n            to[8] = from[8];\n            to[9] = from[9];\n            to[10] = from[10];\n            to[11] = from[11];\n            to[12] = from[12];\n            to[13] = from[13];\n            to[14] = from[14];\n            to[15] = from[15];\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(a, b) {\n            var a0 = a[0],\n                a1 = a[1],\n                a2 = a[2],\n                a3 = a[3];\n            var a4 = a[4],\n                a5 = a[5],\n                a6 = a[6],\n                a7 = a[7];\n            var a8 = a[8],\n                a9 = a[9],\n                a10 = a[10],\n                a11 = a[11];\n            var a12 = a[12],\n                a13 = a[13],\n                a14 = a[14],\n                a15 = a[15];\n\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            var b4 = b[4],\n                b5 = b[5],\n                b6 = b[6],\n                b7 = b[7];\n            var b8 = b[8],\n                b9 = b[9],\n                b10 = b[10],\n                b11 = b[11];\n            var b12 = b[12],\n                b13 = b[13],\n                b14 = b[14],\n                b15 = b[15];\n\n            return Math.abs(a0 - b0) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _Tools2.default.EPSILON.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n        }\n    }, {\n        key: \"exactEquals\",\n        value: function exactEquals(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n        }\n    }, {\n        key: \"projection\",\n        value: function projection(width, height, depth) {\n            var m = this.identity();\n            m[0] = 2 / width;\n            m[5] = -2 / height;\n            m[10] = 2 / depth;\n            m[12] = -1;\n            m[13] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identity\",\n        value: function identity() {\n            var m = new Float32Array(16);\n            m[0] = 1;\n            m[5] = 1;\n            m[10] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identityMatrix\",\n        value: function identityMatrix(matrix) {\n            var m = matrix;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translationMatrix\",\n        value: function translationMatrix(out, tx, ty, tz) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translation\",\n        value: function translation(tx, ty, tz) {\n            var m = this.identity();\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            return m;\n        }\n    }, {\n        key: \"rotationZMatrix\",\n        value: function rotationZMatrix(out, radian) {\n            var m = out;\n            m[2] = 0;\n            m[3] = 0;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n        }\n    }, {\n        key: \"rotationZ\",\n        value: function rotationZ(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationXMatrix\",\n        value: function rotationXMatrix(out, radian) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationX\",\n        value: function rotationX(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationYMatrix\",\n        value: function rotationYMatrix(out, radian) {\n            var m = out;\n            m[1] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[9] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationY\",\n        value: function rotationY(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"scalingMatrix\",\n        value: function scalingMatrix(out, sx, sy, sz) {\n            var m = out;\n            m[0] = sx;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = sy;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = sz;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"scaling\",\n        value: function scaling(sx, sy, sz) {\n            var m = this.identity();\n            m[0] = sx;\n            m[5] = sy;\n            m[10] = sz;\n            return m;\n        }\n    }, {\n        key: \"multiplyWithVertex\",\n        value: function multiplyWithVertex(matrix, vertex) {\n            var a00 = matrix[0];\n            var a01 = matrix[1];\n            var a02 = matrix[2];\n            var a03 = matrix[3];\n            var a10 = matrix[4];\n            var a11 = matrix[5];\n            var a12 = matrix[6];\n            var a13 = matrix[7];\n            var a20 = matrix[8];\n            var a21 = matrix[9];\n            var a22 = matrix[10];\n            var a23 = matrix[11];\n            var a30 = matrix[12];\n            var a31 = matrix[13];\n            var a32 = matrix[14];\n            var a33 = matrix[15];\n\n            var b00 = vertex[0];\n            var b01 = vertex[1];\n            var b02 = vertex[2];\n            var b03 = vertex[3];\n            if (b02 == undefined) b02 = 0;\n            if (b03 == undefined) b03 = 1;\n\n            return [b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33];\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(out, a, b) {\n            var a00 = a[0],\n                a01 = a[1],\n                a02 = a[2],\n                a03 = a[3];\n            var a10 = a[4],\n                a11 = a[5],\n                a12 = a[6],\n                a13 = a[7];\n            var a20 = a[8],\n                a21 = a[9],\n                a22 = a[10],\n                a23 = a[11];\n            var a30 = a[12],\n                a31 = a[13],\n                a32 = a[14],\n                a33 = a[15];\n\n            // Cache only the current line of the second matrix\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[4];\n            b1 = b[5];\n            b2 = b[6];\n            b3 = b[7];\n            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[8];\n            b1 = b[9];\n            b2 = b[10];\n            b3 = b[11];\n            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[12];\n            b1 = b[13];\n            b2 = b[14];\n            b3 = b[15];\n            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            return out;\n        }\n    }, {\n        key: \"TEMP_MAT4\",\n        get: function get() {\n            if (temp_mat4 == undefined) {\n                temp_mat4 = [Mat4.identity(), Mat4.identity(), Mat4.identity(), Mat4.identity()];\n            }\n            return temp_mat4;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return _Tools2.default.EPSILON;\n        }\n    }]);\n\n    return Mat4;\n}();\n\nexports.default = Mat4;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/math/Mat4.js?");

/***/ }),

/***/ "./github/src/utils/Color.js":
/*!***********************************!*\
  !*** ./github/src/utils/Color.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\n__webpack_require__(/*! ./w3color.js */ \"./github/src/utils/w3color.js\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _instance = void 0;\n\nvar Color = function () {\n    function Color() {\n        _classCallCheck(this, Color);\n\n        if (_instance) {\n            return _instance;\n        }\n        _instance = this;\n        this.colorMap = {};\n    }\n\n    _createClass(Color, [{\n        key: 'convertStringToColor',\n        value: function convertStringToColor(string) {\n            string = string.toLowerCase();\n            var that = this;\n            // if (Color.isHEXString(string)) {\n            //     return getColorViaHex(string);\n            // }\n            if (Color.isRGBAString(string)) {\n                return this.rgba2vec(string);\n            }\n            // if (Color.isRGBString(string)) {\n            //     return this.rgb2vec(string);\n            // }\n            if (Color.isHSLAString(string)) {\n                return this.hsla2vet3(string);\n            }\n            // if (Color.isHSLString(string)) {\n            //     return this.hsl2vet3(string);\n            // }\n\n            function getColorViaHex(string) {\n                var vec3 = that.colorMap[string];\n                if (vec3 != undefined) return vec3;\n                vec3 = that.convertHEXToVet3(string);\n                that.colorMap[string] = vec3;\n                return vec3;\n            }\n\n            return this.getVec(string, string, 1);\n            // return this.convertKeywordToVet3(string);\n        }\n    }, {\n        key: 'hsla2vet3',\n        value: function hsla2vet3(hsl) {\n            var temp = hsl;\n            var vec3 = this.colorMap[temp];\n            if (vec3 != undefined) return vec3;\n            hsl = hsl.match(new RegExp(\",\", \"g\"));\n            hsl = hsl || [];\n            var a = 1.0;\n            if (hsl.length == 3) {\n                hsl = temp;\n                var i = hsl.lastIndexOf(',');\n                var i1 = hsl.lastIndexOf(')');\n                var as = hsl.substring(i + 1, i1);\n                a = parseFloat(as);\n                hsl = hsl.substring(0, i);\n                hsl += ')';\n            } else {\n                hsl = temp;\n            }\n            hsl = hsl.replace('a', '');\n            var v = w3color(hsl);\n            if (v.valid) {\n                vec3 = [v.r, v.g, v.b, a];\n                this.colorMap[temp] = vec3;\n                return vec3;\n            } else {\n                return [0, 0, 0, 1];\n            }\n        }\n    }, {\n        key: 'rgba2vec',\n        value: function rgba2vec(rgb) {\n            var temp = rgb;\n            var vec3 = this.colorMap[temp];\n            if (vec3 != undefined) return vec3;\n            rgb = rgb.match(new RegExp(\",\", \"g\"));\n            rgb = rgb || [];\n            var a = 1.0;\n            if (rgb.length == 3) {\n                rgb = temp;\n                var i = rgb.lastIndexOf(',');\n                var i1 = rgb.lastIndexOf(')');\n                var as = rgb.substring(i + 1, i1);\n                a = parseFloat(as);\n                rgb = rgb.substring(0, i);\n                rgb += ')';\n            } else {\n                rgb = temp;\n            }\n            rgb = rgb.replace('a', '');\n            return this.getVec(rgb, temp, a);\n        }\n    }, {\n        key: 'getVec',\n        value: function getVec(string, key, alpha) {\n            var v = w3color(string);\n            if (v.valid) {\n                v = v.toRgb();\n                var vec3 = [v.r, v.g, v.b, alpha];\n                if (this.colorMap[key] == undefined) this.colorMap[key] = vec3;\n                return vec3;\n            } else {\n                return [0, 0, 0, 1];\n            }\n        }\n    }], [{\n        key: 'getInstance',\n        value: function getInstance() {\n            if (!_instance) {\n                _instance = new Color();\n            }\n            return _instance;\n        }\n    }, {\n        key: 'isRGBAString',\n        value: function isRGBAString(string) {\n            if (string) {\n                if (string.indexOf('rgba') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'isHSLAString',\n        value: function isHSLAString(string) {\n            if (string) {\n                if (string.indexOf('hsla') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }]);\n\n    return Color;\n}();\n\nexports.default = Color;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/utils/Color.js?");

/***/ }),

/***/ "./github/src/utils/Tools.js":
/*!***********************************!*\
  !*** ./github/src/utils/Tools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EPSILON = 0.00001;\nvar PI2 = Math.PI * 2;\n\nvar Tools = function () {\n    function Tools() {\n        _classCallCheck(this, Tools);\n\n        this.instance = null;\n    }\n\n    _createClass(Tools, null, [{\n        key: \"equals\",\n        value: function equals(a, b) {\n            // return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n            return Math.abs(a - b) <= EPSILON;\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance(point1, point2) {\n            var dx = point1.x - point2.x;\n            var dy = point1.y - point2.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // static collisionResponse(v1, m1, v2, m2, n, e) {\n        //     if (e == undefined) e = 1; // 恢复系数默认为1\n        //     let m1d = undefined;\n        //     let m2d = undefined;\n        //     if (m1 == Infinity) {\n        //         m2d = 1;\n        //         m1d = 0;\n        //     }\n        //     if (m2 == Infinity) {\n        //         m2d = 0;\n        //         m1d = 1;\n        //     }\n        //     if (m1d == undefined && m2d == undefined) {\n        //         m1d = 1 / m1;\n        //         m2d = 1 / m2;\n        //     }\n        //     let up = 0 - (1 + e);\n        //     let v12 = Vector2.TEMP_VECTORS[0];\n        //     v12.x = v1.x - v2.x;\n        //     v12.y = v1.y - v2.y;\n        //     up = up * Vector2.dot(v12, n);\n        //     let tempVector = v12;// {x: n.x, y: n.y};\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, (m1d + m2d));\n        //     let down = Vector2.dot(n, tempVector);\n        //     let j = up / down;\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m1d);\n        //     let newV1 = {x: 0, y: 0};\n        //     Vector2.add(newV1, v1, tempVector);\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m2d);\n        //     let newV2 = {x: 0, y: 0};\n        //     Vector2.sub(newV2, v2, tempVector);\n        //\n        //     return {newV1: newV1, newV2: newV2};\n        // }\n        //\n        //\n        // getProjectionPointOnLine(point, linePoint1, linePoint2) {\n        //     let p = point; // 线外一点p\n        //     let a = linePoint1; // 线上端点a\n        //     let b = linePoint2; // 线上端点b\n        //     let ap = new Vector2(p.x - a.x, p.y - a.y);\n        //     let ab = new Vector2(b.x - a.x, b.y - a.y);\n        //     let abN = Vector2.normalize(ab, ab);//计算出ab的单位向量\n        //     let compAP = Vector2.dot(ap, abN);//ap在ab上分量\n        //     abN.multiply(compAP); //ap在ab上的投影,返回值就是abN\n        //     let p0 = {x: 0, y: 0};\n        //     Vector2.plus(p0, a, abN);\n        //     return p0;\n        // }\n\n    }, {\n        key: \"clamp\",\n        value: function clamp(value, min, max) {\n            if (value > max) {\n                return max;\n            }\n            if (value < min) {\n                return min;\n            }\n            return value;\n        }\n    }, {\n        key: \"getInsance\",\n        value: function getInsance() {\n            if (this.instance == null) {\n                this.instance = new Tools();\n            }\n            return this.instance;\n        }\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(bounds1, bounds2) {\n            var a = bounds1;\n            var b = bounds2;\n            return a.left <= b.right && a.right >= b.left && a.bottom >= b.top && a.top <= b.bottom;\n        }\n    }, {\n        key: \"isHit\",\n        value: function isHit(rect1, rect2) {\n            var result = false;\n            var x = rect1.left;\n            var y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left + rect1.width;\n            y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n\n            x = rect1.left + rect1.width;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            if (!result) {\n                x = rect2.left;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left + rect2.width;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n\n                x = rect2.left + rect2.width;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n            }\n            return result;\n        }\n    }, {\n        key: \"isInTheRect\",\n        value: function isInTheRect(x, y, rect) {\n            var fx = rect.left;\n            var fy = rect.top;\n            var currentWidth = rect.width;\n            var currentHeight = rect.height;\n            if (x > fx && x < fx + currentWidth && y > fy && y < fy + currentHeight) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: \"PI2\",\n        get: function get() {\n            return PI2;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return EPSILON;\n        }\n    }]);\n\n    return Tools;\n}();\n\nexports.default = Tools;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/utils/Tools.js?");

/***/ }),

/***/ "./github/src/utils/w3color.js":
/*!*************************************!*\
  !*** ./github/src/utils/w3color.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* w3color.js ver.1.18 by w3schools.com (Do not remove this line)*/\n(function () {\n    function w3color(color, elmnt) {\n        if (!(this instanceof w3color)) {\n            return new w3color(color, elmnt);\n        }\n        if ((typeof color === \"undefined\" ? \"undefined\" : _typeof(color)) == \"object\") {\n            return color;\n        }\n        this.attachValues(toColorObject(color));\n        if (elmnt) {\n            elmnt.style.backgroundColor = this.toRgbString();\n        }\n    }\n\n    w3color.prototype = {\n        toRgbString: function toRgbString() {\n            return \"rgb(\" + this.red + \", \" + this.green + \", \" + this.blue + \")\";\n        },\n        toRgbaString: function toRgbaString() {\n            return \"rgba(\" + this.red + \", \" + this.green + \", \" + this.blue + \", \" + this.opacity + \")\";\n        },\n        toHwbString: function toHwbString() {\n            return \"hwb(\" + this.hue + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%)\";\n        },\n        toHwbStringDecimal: function toHwbStringDecimal() {\n            return \"hwb(\" + this.hue + \", \" + this.whiteness + \", \" + this.blackness + \")\";\n        },\n        toHwbaString: function toHwbaString() {\n            return \"hwba(\" + this.hue + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%, \" + this.opacity + \")\";\n        },\n        toHslString: function toHslString() {\n            return \"hsl(\" + this.hue + \", \" + Math.round(this.sat * 100) + \"%, \" + Math.round(this.lightness * 100) + \"%)\";\n        },\n        toHslStringDecimal: function toHslStringDecimal() {\n            return \"hsl(\" + this.hue + \", \" + this.sat + \", \" + this.lightness + \")\";\n        },\n        toHslaString: function toHslaString() {\n            return \"hsla(\" + this.hue + \", \" + Math.round(this.sat * 100) + \"%, \" + Math.round(this.lightness * 100) + \"%, \" + this.opacity + \")\";\n        },\n        toCmykString: function toCmykString() {\n            return \"cmyk(\" + Math.round(this.cyan * 100) + \"%, \" + Math.round(this.magenta * 100) + \"%, \" + Math.round(this.yellow * 100) + \"%, \" + Math.round(this.black * 100) + \"%)\";\n        },\n        toCmykStringDecimal: function toCmykStringDecimal() {\n            return \"cmyk(\" + this.cyan + \", \" + this.magenta + \", \" + this.yellow + \", \" + this.black + \")\";\n        },\n        toNcolString: function toNcolString() {\n            return this.ncol + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%\";\n        },\n        toNcolStringDecimal: function toNcolStringDecimal() {\n            return this.ncol + \", \" + this.whiteness + \", \" + this.blackness;\n        },\n        toNcolaString: function toNcolaString() {\n            return this.ncol + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%, \" + this.opacity;\n        },\n        toName: function toName() {\n            var r,\n                g,\n                b,\n                colorhexs = getColorArr('hexs');\n            for (i = 0; i < colorhexs.length; i++) {\n                r = parseInt(colorhexs[i].substr(0, 2), 16);\n                g = parseInt(colorhexs[i].substr(2, 2), 16);\n                b = parseInt(colorhexs[i].substr(4, 2), 16);\n                if (this.red == r && this.green == g && this.blue == b) {\n                    return getColorArr('names')[i];\n                }\n            }\n            return \"\";\n        },\n        toHexString: function toHexString() {\n            var r = toHex(this.red);\n            var g = toHex(this.green);\n            var b = toHex(this.blue);\n            return \"#\" + r + g + b;\n        },\n        toRgb: function toRgb() {\n            return { r: this.red, g: this.green, b: this.blue, a: this.opacity };\n        },\n        toHsl: function toHsl() {\n            return { h: this.hue, s: this.sat, l: this.lightness, a: this.opacity };\n        },\n        toHwb: function toHwb() {\n            return { h: this.hue, w: this.whiteness, b: this.blackness, a: this.opacity };\n        },\n        toCmyk: function toCmyk() {\n            return { c: this.cyan, m: this.magenta, y: this.yellow, k: this.black, a: this.opacity };\n        },\n        toNcol: function toNcol() {\n            return { ncol: this.ncol, w: this.whiteness, b: this.blackness, a: this.opacity };\n        },\n        isDark: function isDark(n) {\n            var m = n || 128;\n            return (this.red * 299 + this.green * 587 + this.blue * 114) / 1000 < m;\n        },\n        saturate: function saturate(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.sat += x;\n            if (this.sat > 1) {\n                this.sat = 1;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        },\n        desaturate: function desaturate(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.sat -= x;\n            if (this.sat < 0) {\n                this.sat = 0;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        },\n        lighter: function lighter(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.lightness += x;\n            if (this.lightness > 1) {\n                this.lightness = 1;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        },\n        darker: function darker(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.lightness -= x;\n            if (this.lightness < 0) {\n                this.lightness = 0;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        },\n        attachValues: function attachValues(color) {\n            this.red = color.red;\n            this.green = color.green;\n            this.blue = color.blue;\n            this.hue = color.hue;\n            this.sat = color.sat;\n            this.lightness = color.lightness;\n            this.whiteness = color.whiteness;\n            this.blackness = color.blackness;\n            this.cyan = color.cyan;\n            this.magenta = color.magenta;\n            this.yellow = color.yellow;\n            this.black = color.black;\n            this.ncol = color.ncol;\n            this.opacity = color.opacity;\n            this.valid = color.valid;\n        }\n    };\n\n    function toColorObject(c) {\n        var x,\n            y,\n            typ,\n            arr = [],\n            arrlength,\n            i,\n            opacity,\n            match,\n            a,\n            hue,\n            sat,\n            rgb,\n            colornames = [],\n            colorhexs = [];\n        c = w3trim(c.toLowerCase());\n        x = c.substr(0, 1).toUpperCase();\n        y = c.substr(1);\n        a = 1;\n        if ((x == \"R\" || x == \"Y\" || x == \"G\" || x == \"C\" || x == \"B\" || x == \"M\" || x == \"W\") && !isNaN(y)) {\n            if (c.length == 6 && c.indexOf(\",\") == -1) {} else {\n                c = \"ncol(\" + c + \")\";\n            }\n        }\n        if (c.length != 3 && c.length != 6 && !isNaN(c)) {\n            c = \"ncol(\" + c + \")\";\n        }\n        if (c.indexOf(\",\") > 0 && c.indexOf(\"(\") == -1) {\n            c = \"ncol(\" + c + \")\";\n        }\n        if (c.substr(0, 3) == \"rgb\" || c.substr(0, 3) == \"hsl\" || c.substr(0, 3) == \"hwb\" || c.substr(0, 4) == \"ncol\" || c.substr(0, 4) == \"cmyk\") {\n            if (c.substr(0, 4) == \"ncol\") {\n                if (c.split(\",\").length == 4 && c.indexOf(\"ncola\") == -1) {\n                    c = c.replace(\"ncol\", \"ncola\");\n                }\n                typ = \"ncol\";\n                c = c.substr(4);\n            } else if (c.substr(0, 4) == \"cmyk\") {\n                typ = \"cmyk\";\n                c = c.substr(4);\n            } else {\n                typ = c.substr(0, 3);\n                c = c.substr(3);\n            }\n            arrlength = 3;\n            opacity = false;\n            if (c.substr(0, 1).toLowerCase() == \"a\") {\n                arrlength = 4;\n                opacity = true;\n                c = c.substr(1);\n            } else if (typ == \"cmyk\") {\n                arrlength = 4;\n                if (c.split(\",\").length == 5) {\n                    arrlength = 5;\n                    opacity = true;\n                }\n            }\n            c = c.replace(\"(\", \"\");\n            c = c.replace(\")\", \"\");\n            arr = c.split(\",\");\n            if (typ == \"rgb\") {\n                if (arr.length != arrlength) {\n                    return emptyObject();\n                }\n                for (i = 0; i < arrlength; i++) {\n                    if (arr[i] == \"\" || arr[i] == \" \") {\n                        arr[i] = \"0\";\n                    }\n                    if (arr[i].indexOf(\"%\") > -1) {\n                        arr[i] = arr[i].replace(\"%\", \"\");\n                        arr[i] = Number(arr[i] / 100);\n                        if (i < 3) {\n                            arr[i] = Math.round(arr[i] * 255);\n                        }\n                    }\n                    if (isNaN(arr[i])) {\n                        return emptyObject();\n                    }\n                    if (parseInt(arr[i]) > 255) {\n                        arr[i] = 255;\n                    }\n                    if (i < 3) {\n                        arr[i] = parseInt(arr[i]);\n                    }\n                    if (i == 3 && Number(arr[i]) > 1) {\n                        arr[i] = 1;\n                    }\n                }\n                rgb = { r: arr[0], g: arr[1], b: arr[2] };\n                if (opacity == true) {\n                    a = Number(arr[3]);\n                }\n            }\n            if (typ == \"hsl\" || typ == \"hwb\" || typ == \"ncol\") {\n                while (arr.length < arrlength) {\n                    arr.push(\"0\");\n                }\n                if (typ == \"hsl\" || typ == \"hwb\") {\n                    if (parseInt(arr[0]) >= 360) {\n                        arr[0] = 0;\n                    }\n                }\n                for (i = 1; i < arrlength; i++) {\n                    if (arr[i].indexOf(\"%\") > -1) {\n                        arr[i] = arr[i].replace(\"%\", \"\");\n                        arr[i] = Number(arr[i]);\n                        if (isNaN(arr[i])) {\n                            return emptyObject();\n                        }\n                        arr[i] = arr[i] / 100;\n                    } else {\n                        arr[i] = Number(arr[i]);\n                    }\n                    if (Number(arr[i]) > 1) {\n                        arr[i] = 1;\n                    }\n                    if (Number(arr[i]) < 0) {\n                        arr[i] = 0;\n                    }\n                }\n                if (typ == \"hsl\") {\n                    rgb = hslToRgb(arr[0], arr[1], arr[2]);\n                    hue = Number(arr[0]);\n                    sat = Number(arr[1]);\n                }\n                if (typ == \"hwb\") {\n                    rgb = hwbToRgb(arr[0], arr[1], arr[2]);\n                }\n                if (typ == \"ncol\") {\n                    rgb = ncolToRgb(arr[0], arr[1], arr[2]);\n                }\n                if (opacity == true) {\n                    a = Number(arr[3]);\n                }\n            }\n            if (typ == \"cmyk\") {\n                while (arr.length < arrlength) {\n                    arr.push(\"0\");\n                }\n                for (i = 0; i < arrlength; i++) {\n                    if (arr[i].indexOf(\"%\") > -1) {\n                        arr[i] = arr[i].replace(\"%\", \"\");\n                        arr[i] = Number(arr[i]);\n                        if (isNaN(arr[i])) {\n                            return emptyObject();\n                        }\n                        arr[i] = arr[i] / 100;\n                    } else {\n                        arr[i] = Number(arr[i]);\n                    }\n                    if (Number(arr[i]) > 1) {\n                        arr[i] = 1;\n                    }\n                    if (Number(arr[i]) < 0) {\n                        arr[i] = 0;\n                    }\n                }\n                rgb = cmykToRgb(arr[0], arr[1], arr[2], arr[3]);\n                if (opacity == true) {\n                    a = Number(arr[4]);\n                }\n            }\n        } else if (c.substr(0, 3) == \"ncs\") {\n            rgb = ncsToRgb(c);\n        } else {\n            match = false;\n            colornames = getColorArr('names');\n            for (i = 0; i < colornames.length; i++) {\n                if (c.toLowerCase() == colornames[i].toLowerCase()) {\n                    colorhexs = getColorArr('hexs');\n                    match = true;\n                    rgb = {\n                        r: parseInt(colorhexs[i].substr(0, 2), 16),\n                        g: parseInt(colorhexs[i].substr(2, 2), 16),\n                        b: parseInt(colorhexs[i].substr(4, 2), 16)\n                    };\n                    break;\n                }\n            }\n            if (match == false) {\n                c = c.replace(\"#\", \"\");\n                if (c.length == 3) {\n                    c = c.substr(0, 1) + c.substr(0, 1) + c.substr(1, 1) + c.substr(1, 1) + c.substr(2, 1) + c.substr(2, 1);\n                }\n                for (i = 0; i < c.length; i++) {\n                    if (!isHex(c.substr(i, 1))) {\n                        return emptyObject();\n                    }\n                }\n                arr[0] = parseInt(c.substr(0, 2), 16);\n                arr[1] = parseInt(c.substr(2, 2), 16);\n                arr[2] = parseInt(c.substr(4, 2), 16);\n                for (i = 0; i < 3; i++) {\n                    if (isNaN(arr[i])) {\n                        return emptyObject();\n                    }\n                }\n                rgb = {\n                    r: arr[0],\n                    g: arr[1],\n                    b: arr[2]\n                };\n            }\n        }\n        return colorObject(rgb, a, hue, sat);\n    }\n\n    function colorObject(rgb, a, h, s) {\n        var hsl, hwb, cmyk, ncol, color, hue, sat;\n        if (!rgb) {\n            return emptyObject();\n        }\n        if (!a) {\n            a = 1;\n        }\n        hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n        hwb = rgbToHwb(rgb.r, rgb.g, rgb.b);\n        cmyk = rgbToCmyk(rgb.r, rgb.g, rgb.b);\n        hue = h || hsl.h;\n        sat = s || hsl.s;\n        ncol = hueToNcol(hue);\n        color = {\n            red: rgb.r,\n            green: rgb.g,\n            blue: rgb.b,\n            hue: hue,\n            sat: sat,\n            lightness: hsl.l,\n            whiteness: hwb.w,\n            blackness: hwb.b,\n            cyan: cmyk.c,\n            magenta: cmyk.m,\n            yellow: cmyk.y,\n            black: cmyk.k,\n            ncol: ncol,\n            opacity: a,\n            valid: true\n        };\n        color = roundDecimals(color);\n        return color;\n    }\n\n    function emptyObject() {\n        return {\n            red: 0,\n            green: 0,\n            blue: 0,\n            hue: 0,\n            sat: 0,\n            lightness: 0,\n            whiteness: 0,\n            blackness: 0,\n            cyan: 0,\n            magenta: 0,\n            yellow: 0,\n            black: 0,\n            ncol: \"R\",\n            opacity: 1,\n            valid: false\n        };\n    }\n\n    function getColorArr(x) {\n        if (x == \"names\") {\n            return ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];\n        }\n        if (x == \"hexs\") {\n            return ['f0f8ff', 'faebd7', '00ffff', '7fffd4', 'f0ffff', 'f5f5dc', 'ffe4c4', '000000', 'ffebcd', '0000ff', '8a2be2', 'a52a2a', 'deb887', '5f9ea0', '7fff00', 'd2691e', 'ff7f50', '6495ed', 'fff8dc', 'dc143c', '00ffff', '00008b', '008b8b', 'b8860b', 'a9a9a9', 'a9a9a9', '006400', 'bdb76b', '8b008b', '556b2f', 'ff8c00', '9932cc', '8b0000', 'e9967a', '8fbc8f', '483d8b', '2f4f4f', '2f4f4f', '00ced1', '9400d3', 'ff1493', '00bfff', '696969', '696969', '1e90ff', 'b22222', 'fffaf0', '228b22', 'ff00ff', 'dcdcdc', 'f8f8ff', 'ffd700', 'daa520', '808080', '808080', '008000', 'adff2f', 'f0fff0', 'ff69b4', 'cd5c5c', '4b0082', 'fffff0', 'f0e68c', 'e6e6fa', 'fff0f5', '7cfc00', 'fffacd', 'add8e6', 'f08080', 'e0ffff', 'fafad2', 'd3d3d3', 'd3d3d3', '90ee90', 'ffb6c1', 'ffa07a', '20b2aa', '87cefa', '778899', '778899', 'b0c4de', 'ffffe0', '00ff00', '32cd32', 'faf0e6', 'ff00ff', '800000', '66cdaa', '0000cd', 'ba55d3', '9370db', '3cb371', '7b68ee', '00fa9a', '48d1cc', 'c71585', '191970', 'f5fffa', 'ffe4e1', 'ffe4b5', 'ffdead', '000080', 'fdf5e6', '808000', '6b8e23', 'ffa500', 'ff4500', 'da70d6', 'eee8aa', '98fb98', 'afeeee', 'db7093', 'ffefd5', 'ffdab9', 'cd853f', 'ffc0cb', 'dda0dd', 'b0e0e6', '800080', '663399', 'ff0000', 'bc8f8f', '4169e1', '8b4513', 'fa8072', 'f4a460', '2e8b57', 'fff5ee', 'a0522d', 'c0c0c0', '87ceeb', '6a5acd', '708090', '708090', 'fffafa', '00ff7f', '4682b4', 'd2b48c', '008080', 'd8bfd8', 'ff6347', '40e0d0', 'ee82ee', 'f5deb3', 'ffffff', 'f5f5f5', 'ffff00', '9acd32'];\n        }\n    }\n\n    function roundDecimals(c) {\n        c.red = Number(c.red.toFixed(0));\n        c.green = Number(c.green.toFixed(0));\n        c.blue = Number(c.blue.toFixed(0));\n        c.hue = Number(c.hue.toFixed(0));\n        c.sat = Number(c.sat.toFixed(2));\n        c.lightness = Number(c.lightness.toFixed(2));\n        c.whiteness = Number(c.whiteness.toFixed(2));\n        c.blackness = Number(c.blackness.toFixed(2));\n        c.cyan = Number(c.cyan.toFixed(2));\n        c.magenta = Number(c.magenta.toFixed(2));\n        c.yellow = Number(c.yellow.toFixed(2));\n        c.black = Number(c.black.toFixed(2));\n        c.ncol = c.ncol.substr(0, 1) + Math.round(Number(c.ncol.substr(1)));\n        c.opacity = Number(c.opacity.toFixed(2));\n        return c;\n    }\n\n    function hslToRgb(hue, sat, light) {\n        var t1, t2, r, g, b;\n        hue = hue / 60;\n        if (light <= 0.5) {\n            t2 = light * (sat + 1);\n        } else {\n            t2 = light + sat - light * sat;\n        }\n        t1 = light * 2 - t2;\n        r = hueToRgb(t1, t2, hue + 2) * 255;\n        g = hueToRgb(t1, t2, hue) * 255;\n        b = hueToRgb(t1, t2, hue - 2) * 255;\n        return { r: r, g: g, b: b };\n    }\n\n    function hueToRgb(t1, t2, hue) {\n        if (hue < 0) hue += 6;\n        if (hue >= 6) hue -= 6;\n        if (hue < 1) return (t2 - t1) * hue + t1;else if (hue < 3) return t2;else if (hue < 4) return (t2 - t1) * (4 - hue) + t1;else return t1;\n    }\n\n    function hwbToRgb(hue, white, black) {\n        var i,\n            rgb,\n            rgbArr = [],\n            tot;\n        rgb = hslToRgb(hue, 1, 0.50);\n        rgbArr[0] = rgb.r / 255;\n        rgbArr[1] = rgb.g / 255;\n        rgbArr[2] = rgb.b / 255;\n        tot = white + black;\n        if (tot > 1) {\n            white = Number((white / tot).toFixed(2));\n            black = Number((black / tot).toFixed(2));\n        }\n        for (i = 0; i < 3; i++) {\n            rgbArr[i] *= 1 - white - black;\n            rgbArr[i] += white;\n            rgbArr[i] = Number(rgbArr[i] * 255);\n        }\n        return { r: rgbArr[0], g: rgbArr[1], b: rgbArr[2] };\n    }\n\n    function cmykToRgb(c, m, y, k) {\n        var r, g, b;\n        r = 255 - Math.min(1, c * (1 - k) + k) * 255;\n        g = 255 - Math.min(1, m * (1 - k) + k) * 255;\n        b = 255 - Math.min(1, y * (1 - k) + k) * 255;\n        return { r: r, g: g, b: b };\n    }\n\n    function ncolToRgb(ncol, white, black) {\n        var letter, percent, h, w, b;\n        h = ncol;\n        if (isNaN(ncol.substr(0, 1))) {\n            letter = ncol.substr(0, 1).toUpperCase();\n            percent = ncol.substr(1);\n            if (percent == \"\") {\n                percent = 0;\n            }\n            percent = Number(percent);\n            if (isNaN(percent)) {\n                return false;\n            }\n            if (letter == \"R\") {\n                h = 0 + percent * 0.6;\n            }\n            if (letter == \"Y\") {\n                h = 60 + percent * 0.6;\n            }\n            if (letter == \"G\") {\n                h = 120 + percent * 0.6;\n            }\n            if (letter == \"C\") {\n                h = 180 + percent * 0.6;\n            }\n            if (letter == \"B\") {\n                h = 240 + percent * 0.6;\n            }\n            if (letter == \"M\") {\n                h = 300 + percent * 0.6;\n            }\n            if (letter == \"W\") {\n                h = 0;\n                white = 1 - percent / 100;\n                black = percent / 100;\n            }\n        }\n        return hwbToRgb(h, white, black);\n    }\n\n    function hueToNcol(hue) {\n        while (hue >= 360) {\n            hue = hue - 360;\n        }\n        if (hue < 60) {\n            return \"R\" + hue / 0.6;\n        }\n        if (hue < 120) {\n            return \"Y\" + (hue - 60) / 0.6;\n        }\n        if (hue < 180) {\n            return \"G\" + (hue - 120) / 0.6;\n        }\n        if (hue < 240) {\n            return \"C\" + (hue - 180) / 0.6;\n        }\n        if (hue < 300) {\n            return \"B\" + (hue - 240) / 0.6;\n        }\n        if (hue < 360) {\n            return \"M\" + (hue - 300) / 0.6;\n        }\n    }\n\n    function ncsToRgb(ncs) {\n        var black, chroma, bc, percent, black1, chroma1, red1, factor1, blue1, red1, red2, green2, blue2, max, factor2, grey, r, g, b;\n        ncs = w3trim(ncs).toUpperCase();\n        ncs = ncs.replace(\"(\", \"\");\n        ncs = ncs.replace(\")\", \"\");\n        ncs = ncs.replace(\"NCS\", \"NCS \");\n        ncs = ncs.replace(/  /g, \" \");\n        if (ncs.indexOf(\"NCS\") == -1) {\n            ncs = \"NCS \" + ncs;\n        }\n        ncs = ncs.match(/^(?:NCS|NCS\\sS)\\s(\\d{2})(\\d{2})-(N|[A-Z])(\\d{2})?([A-Z])?$/);\n        if (ncs === null) return false;\n        black = parseInt(ncs[1], 10);\n        chroma = parseInt(ncs[2], 10);\n        bc = ncs[3];\n        if (bc != \"N\" && bc != \"Y\" && bc != \"R\" && bc != \"B\" && bc != \"G\") {\n            return false;\n        }\n        percent = parseInt(ncs[4], 10) || 0;\n        if (bc !== 'N') {\n            black1 = 1.05 * black - 5.25;\n            chroma1 = chroma;\n            if (bc === 'Y' && percent <= 60) {\n                red1 = 1;\n            } else if (bc === 'Y' && percent > 60 || bc === 'R' && percent <= 80) {\n                if (bc === 'Y') {\n                    factor1 = percent - 60;\n                } else {\n                    factor1 = percent + 40;\n                }\n                red1 = (Math.sqrt(14884 - Math.pow(factor1, 2)) - 22) / 100;\n            } else if (bc === 'R' && percent > 80 || bc === 'B') {\n                red1 = 0;\n            } else if (bc === 'G') {\n                factor1 = percent - 170;\n                red1 = (Math.sqrt(33800 - Math.pow(factor1, 2)) - 70) / 100;\n            }\n            if (bc === 'Y' && percent <= 80) {\n                blue1 = 0;\n            } else if (bc === 'Y' && percent > 80 || bc === 'R' && percent <= 60) {\n                if (bc === 'Y') {\n                    factor1 = percent - 80 + 20.5;\n                } else {\n                    factor1 = percent + 20 + 20.5;\n                }\n                blue1 = (104 - Math.sqrt(11236 - Math.pow(factor1, 2))) / 100;\n            } else if (bc === 'R' && percent > 60 || bc === 'B' && percent <= 80) {\n                if (bc === 'R') {\n                    factor1 = percent - 60 - 60;\n                } else {\n                    factor1 = percent + 40 - 60;\n                }\n                blue1 = (Math.sqrt(10000 - Math.pow(factor1, 2)) - 10) / 100;\n            } else if (bc === 'B' && percent > 80 || bc === 'G' && percent <= 40) {\n                if (bc === 'B') {\n                    factor1 = percent - 80 - 131;\n                } else {\n                    factor1 = percent + 20 - 131;\n                }\n                blue1 = (122 - Math.sqrt(19881 - Math.pow(factor1, 2))) / 100;\n            } else if (bc === 'G' && percent > 40) {\n                blue1 = 0;\n            }\n            if (bc === 'Y') {\n                green1 = (85 - 17 / 20 * percent) / 100;\n            } else if (bc === 'R' && percent <= 60) {\n                green1 = 0;\n            } else if (bc === 'R' && percent > 60) {\n                factor1 = percent - 60 + 35;\n                green1 = (67.5 - Math.sqrt(5776 - Math.pow(factor1, 2))) / 100;\n            } else if (bc === 'B' && percent <= 60) {\n                factor1 = 1 * percent - 68.5;\n                green1 = (6.5 + Math.sqrt(7044.5 - Math.pow(factor1, 2))) / 100;\n            } else if (bc === 'B' && percent > 60 || bc === 'G' && percent <= 60) {\n                green1 = 0.9;\n            } else if (bc === 'G' && percent > 60) {\n                factor1 = percent - 60;\n                green1 = (90 - 1 / 8 * factor1) / 100;\n            }\n            factor1 = (red1 + green1 + blue1) / 3;\n            red2 = (factor1 - red1) * (100 - chroma1) / 100 + red1;\n            green2 = (factor1 - green1) * (100 - chroma1) / 100 + green1;\n            blue2 = (factor1 - blue1) * (100 - chroma1) / 100 + blue1;\n            if (red2 > green2 && red2 > blue2) {\n                max = red2;\n            } else if (green2 > red2 && green2 > blue2) {\n                max = green2;\n            } else if (blue2 > red2 && blue2 > green2) {\n                max = blue2;\n            } else {\n                max = (red2 + green2 + blue2) / 3;\n            }\n            factor2 = 1 / max;\n            r = parseInt(red2 * factor2 * (100 - black1) / 100 * 255, 10);\n            g = parseInt(green2 * factor2 * (100 - black1) / 100 * 255, 10);\n            b = parseInt(blue2 * factor2 * (100 - black1) / 100 * 255, 10);\n            if (r > 255) {\n                r = 255;\n            }\n            if (g > 255) {\n                g = 255;\n            }\n            if (b > 255) {\n                b = 255;\n            }\n            if (r < 0) {\n                r = 0;\n            }\n            if (g < 0) {\n                g = 0;\n            }\n            if (b < 0) {\n                b = 0;\n            }\n        } else {\n            grey = parseInt((1 - black / 100) * 255, 10);\n            if (grey > 255) {\n                grey = 255;\n            }\n            if (grey < 0) {\n                grey = 0;\n            }\n            r = grey;\n            g = grey;\n            b = grey;\n        }\n        return {\n            r: r,\n            g: g,\n            b: b\n        };\n    }\n\n    function rgbToHsl(r, g, b) {\n        var min,\n            max,\n            i,\n            l,\n            s,\n            maxcolor,\n            h,\n            rgb = [];\n        rgb[0] = r / 255;\n        rgb[1] = g / 255;\n        rgb[2] = b / 255;\n        min = rgb[0];\n        max = rgb[0];\n        maxcolor = 0;\n        for (i = 0; i < rgb.length - 1; i++) {\n            if (rgb[i + 1] <= min) {\n                min = rgb[i + 1];\n            }\n            if (rgb[i + 1] >= max) {\n                max = rgb[i + 1];\n                maxcolor = i + 1;\n            }\n        }\n        if (maxcolor == 0) {\n            h = (rgb[1] - rgb[2]) / (max - min);\n        }\n        if (maxcolor == 1) {\n            h = 2 + (rgb[2] - rgb[0]) / (max - min);\n        }\n        if (maxcolor == 2) {\n            h = 4 + (rgb[0] - rgb[1]) / (max - min);\n        }\n        if (isNaN(h)) {\n            h = 0;\n        }\n        h = h * 60;\n        if (h < 0) {\n            h = h + 360;\n        }\n        l = (min + max) / 2;\n        if (min == max) {\n            s = 0;\n        } else {\n            if (l < 0.5) {\n                s = (max - min) / (max + min);\n            } else {\n                s = (max - min) / (2 - max - min);\n            }\n        }\n        s = s;\n        return { h: h, s: s, l: l };\n    }\n\n    function rgbToHwb(r, g, b) {\n        var h, w, bl;\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var chroma = max - min;\n        if (chroma == 0) {\n            h = 0;\n        } else if (r == max) {\n            h = (g - b) / chroma % 6 * 360;\n        } else if (g == max) {\n            h = ((b - r) / chroma + 2) % 6 * 360;\n        } else {\n            h = ((r - g) / chroma + 4) % 6 * 360;\n        }\n        w = min;\n        bl = 1 - max;\n        return { h: h, w: w, b: bl };\n    }\n\n    function rgbToCmyk(r, g, b) {\n        var c, m, y, k;\n        r = r / 255;\n        g = g / 255;\n        b = b / 255;\n        var max = Math.max(r, g, b);\n        k = 1 - max;\n        if (k == 1) {\n            c = 0;\n            m = 0;\n            y = 0;\n        } else {\n            c = (1 - r - k) / (1 - k);\n            m = (1 - g - k) / (1 - k);\n            y = (1 - b - k) / (1 - k);\n        }\n        return { c: c, m: m, y: y, k: k };\n    }\n\n    function toHex(n) {\n        var hex = n.toString(16);\n        while (hex.length < 2) {\n            hex = \"0\" + hex;\n        }\n        return hex;\n    }\n\n    function cl(x) {\n        console.log(x);\n    }\n\n    function w3trim(x) {\n        return x.replace(/^\\s+|\\s+$/g, '');\n    }\n\n    function isHex(x) {\n        return '0123456789ABCDEFabcdef'.indexOf(x) > -1;\n    }\n\n    window.w3color = w3color;\n})();\n\nfunction w3SetColorsByAttribute() {\n    var z, i, att;\n    z = document.getElementsByTagName(\"*\");\n    for (i = 0; i < z.length; i++) {\n        att = z[i].getAttribute(\"data-w3-color\");\n        if (att) {\n            z[i].style.backgroundColor = w3color(att).toRgbString();\n        }\n    }\n}\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/utils/w3color.js?");

/***/ }),

/***/ "./github/src/webgl/CanvasDrawingStylesWebgl2D.js":
/*!********************************************************!*\
  !*** ./github/src/webgl/CanvasDrawingStylesWebgl2D.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _lineWidth = Symbol('线宽度,默认1');\nvar _lineCap = Symbol('线连接样式，\"butt\", \"round\", \"square\" (默认: \"butt\")');\nvar _lineJoin = Symbol('线连接样式，\"round\", \"bevel\", \"miter\" (默认: \"miter\")');\nvar _miterLimit = Symbol('默认10');\n\nvar _font = Symbol('文字字体大小等，默认\"10px sans-serif\"');\nvar _textAlign = Symbol('文字对齐,\"start\", \"end\", \"left\", \"right\", \"center\" (默认: \"start\")');\nvar _textBaseline = Symbol('文字纵向对齐，\"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\" (默认: \"alphabetic\")');\n\nvar CanvasDrawingStylesWebgl2D = function () {\n    function CanvasDrawingStylesWebgl2D() {\n        _classCallCheck(this, CanvasDrawingStylesWebgl2D);\n\n        this[_lineWidth] = 1;\n        this[_lineCap] = \"butt\";\n        this[_lineJoin] = \"miter\";\n        this[_miterLimit] = 10;\n        this.font = '10px sans-serif';\n        this.textAlign = 'start';\n        this.textBaseline = 'alphabetic';\n    }\n\n    // line caps/joins\n\n\n    _createClass(CanvasDrawingStylesWebgl2D, [{\n        key: 'clone',\n        value: function clone() {\n            var c = new CanvasDrawingStylesWebgl2D();\n            c.textBaseline = this.textBaseline;\n            c.textAlign = this.textAlign;\n            c.font = this.font;\n            c.lineCap = this.lineCap;\n            c.lineJoin = this.lineJoin;\n            c.lineWidth = this.lineWidth;\n            return c;\n        }\n    }, {\n        key: 'lineWidth',\n        get: function get() {\n            return this[_lineWidth];\n        },\n        set: function set(lineWidth) {\n            this[_lineWidth] = lineWidth;\n        }\n    }, {\n        key: 'lineCap',\n        get: function get() {\n            return this[_lineCap];\n        },\n        set: function set(lineCap) {\n            this[_lineCap] = lineCap;\n        }\n    }, {\n        key: 'lineJoin',\n        get: function get() {\n            return this[_lineJoin];\n        },\n        set: function set(lineJoin) {\n            this[_lineJoin] = lineJoin;\n        }\n    }, {\n        key: 'miterLimit',\n        get: function get() {\n            return this[_miterLimit];\n        },\n        set: function set(miterLimit) {\n            this[_miterLimit] = miterLimit;\n        }\n\n        // 没有实现的：\n        // dashed lines\n        // void setLineDash(sequence<unrestricted double> segments); // (default: empty)\n        // sequence<unrestricted double> getLineDash();\n        // attribute unrestricted double lineDashOffset;\n\n\n        // text\n\n    }, {\n        key: 'font',\n        get: function get() {\n            return this[_font];\n        },\n        set: function set(font) {\n            this[_font] = font;\n        }\n    }, {\n        key: 'textAlign',\n        get: function get() {\n            return this[_textAlign];\n        },\n        set: function set(textAlign) {\n            this[_textAlign] = textAlign;\n        }\n    }, {\n        key: 'textBaseline',\n        get: function get() {\n            return this[_textBaseline];\n        },\n        set: function set(textBaseline) {\n            this[_textBaseline] = textBaseline;\n        }\n    }]);\n\n    return CanvasDrawingStylesWebgl2D;\n}();\n\nexports.default = CanvasDrawingStylesWebgl2D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/CanvasDrawingStylesWebgl2D.js?");

/***/ }),

/***/ "./github/src/webgl/CanvasRenderingContextWebgl2D.js":
/*!***********************************************************!*\
  !*** ./github/src/webgl/CanvasRenderingContextWebgl2D.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ContextState = __webpack_require__(/*! ./ContextState.js */ \"./github/src/webgl/ContextState.js\");\n\nvar _ContextState2 = _interopRequireDefault(_ContextState);\n\nvar _CanvasDrawingStylesWebgl2D = __webpack_require__(/*! ./CanvasDrawingStylesWebgl2D.js */ \"./github/src/webgl/CanvasDrawingStylesWebgl2D.js\");\n\nvar _CanvasDrawingStylesWebgl2D2 = _interopRequireDefault(_CanvasDrawingStylesWebgl2D);\n\nvar _Path3D = __webpack_require__(/*! ./Path3D.js */ \"./github/src/webgl/Path3D.js\");\n\nvar _Path3D2 = _interopRequireDefault(_Path3D);\n\nvar _Point3D = __webpack_require__(/*! ./Point3D.js */ \"./github/src/webgl/Point3D.js\");\n\nvar _Point3D2 = _interopRequireDefault(_Point3D);\n\nvar _SubPath3D = __webpack_require__(/*! ./SubPath3D.js */ \"./github/src/webgl/SubPath3D.js\");\n\nvar _SubPath3D2 = _interopRequireDefault(_SubPath3D);\n\nvar _Color = __webpack_require__(/*! ../utils/Color.js */ \"./github/src/utils/Color.js\");\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _RenderAction = __webpack_require__(/*! ./RenderAction.js */ \"./github/src/webgl/RenderAction.js\");\n\nvar _RenderAction2 = _interopRequireDefault(_RenderAction);\n\nvar _WebGLRender = __webpack_require__(/*! ./WebGLRender.js */ \"./github/src/webgl/WebGLRender.js\");\n\nvar _WebGLRender2 = _interopRequireDefault(_WebGLRender);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./github/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _canvas = Symbol('对应的Canvas');\nvar _stateStack = Symbol('状态栈');\nvar _stateArray = Symbol('状态数组，记录全部状态');\nvar _pathList = Symbol('路径列表');\nvar _renderActionList = Symbol('绘制动作List');\n\nvar CanvasRenderingContextWebgl2D = function () {\n    function CanvasRenderingContextWebgl2D(canvas, properties) {\n        _classCallCheck(this, CanvasRenderingContextWebgl2D);\n\n        if (properties == null || properties == undefined) properties = [];\n        this[_canvas] = canvas;\n        if (canvas == null || canvas == undefined) throw new Error('canvas can not be undefined or null');\n        this.gl = canvas.getContext('webgl');\n        if (this.gl == undefined) throw new Error('Current canvas doesnt support WebGL');\n        // this.defaultDepth = -canvas.height * 2;\n        var FOV = properties['FOV'] || 20;\n        var t = Math.tan(FOV * Math.PI / 180);\n        this.defaultDepth = -canvas.height / (2 * t);\n        this[_stateStack] = [];\n        this[_stateArray] = [];\n        this[_pathList] = [];\n        this[_renderActionList] = [];\n        this.webglRender = new _WebGLRender2.default(this.gl, properties['maxTransformNum'], properties['maxTextureSize'], properties['projectionType'], this.defaultDepth);\n        this.translate(0, 0, this.defaultDepth);\n    }\n\n    _createClass(CanvasRenderingContextWebgl2D, [{\n        key: \"clean\",\n        value: function clean() {\n            this[_pathList].length = 0;\n            this.webglRender.clean();\n        }\n\n        /**\r\n         * 没有实现,只能全部清空\r\n         * @param left\r\n         * @param top\r\n         * @param width\r\n         * @param height\r\n         */\n\n    }, {\n        key: \"clearRect\",\n        value: function clearRect(left, top, width, height) {\n            this.clean();\n        }\n\n        /************** CanvasPathMethods ************************/\n\n        // 没有实现的有这些：\n        // arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n        // arcTo(x1: number, y1: number, x2: number, y2: number, radiusX: number, radiusY: number, rotation: number): void;\n        // bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n        // quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n\n    }, {\n        key: \"beginPath\",\n        value: function beginPath() {\n            this.currentPath.clean();\n        }\n\n        /**\r\n         * 关闭当前Path，下面是规范说明\r\n         * The closePath() method must do nothing if the object's path has no subpaths.\r\n         * Otherwise, it must mark the last subpath as closed,\r\n         * create a new subpath whose first point is the same as the previous subpath's first point,\r\n         * and finally add this new subpath to the path.\r\n         */\n\n    }, {\n        key: \"closePath\",\n        value: function closePath() {\n            var path = this.currentPath;\n            if (path.subPathNumber == 0) return;\n            var lastSubPath = path.lastSubPath;\n            lastSubPath.close();\n            var firstPoint = lastSubPath.getPoint(0);\n            var newSubPath = new _SubPath3D2.default(firstPoint);\n            path.addSubPath(newSubPath);\n        }\n\n        /**\r\n         * 连接某个点x，y，下面是规范说明\r\n         * The lineTo(x, y) method must ensure there is a subpath for (x, y) if the object's path has no subpaths.\r\n         * Otherwise, it must connect the last point in the subpath to the given point (x, y) using a straight line,\r\n         * and must then add the given point (x, y) to the subpath.\r\n         * @param x\r\n         * @param y\r\n         * @param z\r\n         */\n\n    }, {\n        key: \"lineTo\",\n        value: function lineTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n            var currentSubPath = this.currentPath;\n            var lastSubPath = currentSubPath.lastSubPath;\n            var point = new _Point3D2.default(x, y, z);\n            var m = currentState.transformMatrix.matrix;\n            var temp = _Mat2.default.multiplyWithVertex(m, point.value);\n            point.x = temp[0];\n            point.y = temp[1];\n            point.z = temp[2];\n            // point.contextStateIndex = currentState.id;\n            // point.transformMatrixIndex = currentState.transformMatrixId;\n            currentState.fireDirty();\n            lastSubPath.pushPoint(point);\n        }\n\n        /**\r\n         * 规范说明\r\n         * The moveTo(x, y) method must create a new subpath with the specified point as its first (and only) point.\r\n         * When the user agent is to ensure there is a subpath for a coordinate (x, y) on a path,\r\n         * the user agent must check to see if the path has any subpaths,\r\n         * and if it does not, then the user agent must create a new subpath with the point (x, y) as its first\r\n         * (and only) point, as if the moveTo() method had been called.\r\n         * @param x\r\n         * @param y\r\n         * @param z\r\n         */\n\n    }, {\n        key: \"moveTo\",\n        value: function moveTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n            var currentSubPath = this.currentPath;\n            var point = new _Point3D2.default(x, y, z);\n            var m = currentState.transformMatrix.matrix;\n            var temp = _Mat2.default.multiplyWithVertex(m, point.value);\n            point.x = temp[0];\n            point.y = temp[1];\n            point.z = temp[2];\n            // point.contextStateIndex = currentState.id;\n            // point.transformMatrixIndex = currentState.transformMatrixId;\n            currentState.fireDirty();\n\n            var subPath = new _SubPath3D2.default(point);\n            currentSubPath.addSubPath(subPath);\n        }\n\n        /**\r\n         * The rect(x, y, w, h) method must create a new subpath containing just the four points\r\n         * (x, y), (x+w, y), (x+w, y+h), (x, y+h), with those four points connected by straight lines,\r\n         * and must then mark the subpath as closed.\r\n         * It must then create a new subpath with the point (x, y) as the only point in the subpath.\r\n         * @param x\r\n         * @param y\r\n         * @param w\r\n         * @param h\r\n         * @param depth 这个参数可选，不给的话就是0\r\n         */\n\n    }, {\n        key: \"rect\",\n        value: function rect(x, y, w, h, depth) {\n            if (depth == undefined) depth = 0;\n            this.moveTo(x, y, depth);\n            this.lineTo(x + w, y, depth);\n            this.lineTo(x + w, y + h, depth);\n            this.lineTo(x, y + h, depth);\n            var currentSubPath = this.currentPath.lastSubPath;\n            currentSubPath.type = _SubPath3D2.default.TYPE_RECTANGLE;\n            this.closePath();\n        }\n    }, {\n        key: \"ellipse\",\n        value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n            if (radiusX < 0 || radiusY < 0) throw new Error('半径必须不小于0. Radius should not be smaller than zero. BanJing BiXu BuXiaoYu Ling');\n            if (radiusX == 0 || radiusY == 0) return;\n            if (anticlockwise == undefined) anticlockwise = false;\n\n            var subpath = this.currentPath.lastSubPath;\n            if (subpath == undefined) {\n                subpath = new _SubPath3D2.default();\n                this.currentPath.addSubPath(subpath);\n            }\n\n            startAngle = adjustAngle(startAngle);\n            endAngle = adjustAngle(endAngle);\n\n            if (startAngle > endAngle && !anticlockwise || startAngle < endAngle && anticlockwise) {\n                if (startAngle < 0 || endAngle < 0) {\n                    endAngle -= 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle -= 2 * Math.PI;\n                }\n                if (startAngle > 0 || endAngle > 0) {\n                    endAngle += 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle += 2 * Math.PI;\n                }\n            }\n\n            var realRadius = Math.max(radiusX, radiusY); // 这个值要根据当前缩放算一下\n            var plusAngle = Math.asin(1 / realRadius) * 2;\n            var count = 0;\n            if (anticlockwise) {\n                plusAngle *= -1;\n            }\n\n            for (var radian = startAngle; Math.abs(radian) < Math.abs(endAngle); radian += plusAngle, count++) {\n                var _nextPoint = getPoint(x, y, radiusX, radiusY, radian);\n                this.lineTo(_nextPoint.x, _nextPoint.y);\n            }\n\n            // 连接上最后一个点：\n            var nextPoint = getPoint(x, y, radiusX, radiusY, endAngle);\n            this.lineTo(nextPoint.x, nextPoint.y);\n\n            function adjustAngle(angle) {\n                var PI2 = 2 * Math.PI;\n                var beishu = Math.floor(Math.abs(angle / PI2)) + 1;\n                if (Math.abs(angle) > PI2) beishu++;\n                if (angle < 0 && !anticlockwise) {\n                    angle += beishu * PI2;\n                }\n                if (angle > 0 && anticlockwise) {\n                    angle -= beishu * PI2;\n                }\n                return angle;\n            }\n\n            function getPoint(x, y, radiusX, radiusY, radian) {\n                var cos = Math.cos(radian);\n                var sin = Math.sin(radian);\n                var tan = sin / cos;\n                var x1 = Math.sqrt(radiusY * radiusY * radiusX * radiusX / (radiusY * radiusY + radiusX * radiusX * tan * tan));\n                var y1 = tan * x1;\n                if (cos * x1 < 0) x1 *= -1;\n                if (sin * y1 < 0) y1 *= -1;\n                x1 += x;\n                y1 += y;\n                if (rotation != 0) {\n                    var nx = (x1 - x) * Math.cos(rotation) - (y1 - y) * Math.sin(rotation) + x;\n                    var ny = (y1 - y) * Math.cos(rotation) + (x1 - x) * Math.sin(rotation) + y;\n                    x1 = nx;\n                    y1 = ny;\n                }\n                return { x: x1, y: y1 };\n            }\n        }\n\n        /**\r\n         * 该方法已经在canvas2d下模拟测试通过\r\n         * 规范说明\r\n         * The arc(x, y, radius, startAngle, endAngle, counterclockwise) method draws an arc.\r\n         * If the context has any subpaths, then the method must add a straight line from the last point in\r\n         * the subpath to the start point of the arc. In any case, it must draw the arc between the start point of\r\n         * the arc and the end point of the arc, and add the start and end points of the arc to the subpath.\r\n         * The arc and its start and end points are defined as follows:\r\n         * Consider a circle that has its origin at (x, y), and that has radius radius.\r\n         * The points at startAngle and endAngle this circle's circumference, measured in radians clockwise\r\n         * from the positive x-axis, are the start and end points respectively.\r\n         * If the counterclockwise argument false and endAngle-startAngle is equal to or greater than 2π,\r\n         * or if the counterclockwise argument is true and startAngle-endAngle is equal to or greater than 2π,\r\n         * then the arc is the whole circumference of this circle.\r\n         * Otherwise, the arc is the path along the circumference of this circle from the start point to the end point,\r\n         * going anti-clockwise if the counterclockwise argument is true, and clockwise otherwise.\r\n         * Since the points are on the circle, as opposed to being simply angles from zero,\r\n         * the arc can never cover an angle greater than 2π radians.\r\n         * If the two points are the same, or if the radius is zero, then the arc is defined as being of zero length in both directions.\r\n         * Negative values for radius must cause the implementation to throw an IndexSizeError exception.\r\n         * @param x\r\n         * @param y\r\n         * @param radius\r\n         * @param startAngle\r\n         * @param endAngle\r\n         * @param anticlockwise\r\n         */\n\n    }, {\n        key: \"arc\",\n        value: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n            this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);\n        }\n\n        /*************************** sate **************************/\n\n        /**\r\n         * push state on state stack\r\n         * 将当前状态放入状态栈中\r\n         */\n\n    }, {\n        key: \"save\",\n        value: function save() {\n            // 取出最后一个状态，克隆一个新状态，然后把新状态加入到栈内\n            var currentState = this.currentContextState;\n            var stateClone = currentState.clone();\n            this[_stateStack].push(stateClone);\n            this[_stateArray].push(stateClone);\n            stateClone.id = this[_stateArray].length - 1;\n        }\n\n        /**\r\n         * pop state stack and restore state\r\n         * 将当前状态弹出栈，即恢复之前的状态\r\n         */\n\n    }, {\n        key: \"restore\",\n        value: function restore() {\n            // 弹出栈底状态\n            if (this[_stateStack].length != 0) {\n                this[_stateStack].pop();\n            }\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            this.currentContextState.translate(x, y, z);\n        }\n\n        /**\r\n         * 默认2D是按照Z轴旋转\r\n         * @param radian\r\n         */\n\n    }, {\n        key: \"rotate\",\n        value: function rotate(radian) {\n            this.currentContextState.rotateZ(radian);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            this.currentContextState.rotateX(radian);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            this.currentContextState.rotateY(radian);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            this.currentContextState.scale(scaleX, scaleY, scaleZ);\n        }\n\n        /*********************** 绘制 */ //////////////\n\n    }, {\n        key: \"drawImage\",\n        value: function drawImage(image, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, depth) {\n            depth = depth || 0;\n            var texture = this.webglRender.textureManager.getTexture(image, this.gl, true);\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.textureIndex = texture.index;\n            var left = void 0,\n                top = void 0,\n                right = void 0,\n                bottom = void 0; // 图形对应矩形的四个点\n            var tx = void 0,\n                ty = void 0,\n                tr = void 0,\n                tb = void 0; // 贴图对应的四个点\n            // 只有x,y传入的调用\n            if (arguments.length == 3) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            if (arguments.length == 4) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = srcWidth;\n            }\n            // 有x,y,width,height传入的调用\n            if (arguments.length == 5) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            if (arguments.length == 6) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = dstX;\n            }\n            // 有9个参数传入的调用，即要调整贴图做镖\n            if (arguments.length == 9) {\n                left = dstX;\n                top = dstY;\n                right = dstX + dstWidth;\n                bottom = dstY + dstHeight;\n                tx = texture.x + srcX;\n                tr = texture.x + srcX + srcWidth;\n                ty = texture.y + srcY;\n                tb = texture.y + srcY + srcHeight;\n            }\n            this.beginPath();\n            this.rect(left, top, right - left, bottom - top, depth);\n\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            this[_renderActionList].push(action);\n            var texCoordArray = new Array(4);\n            texCoordArray[0] = [tx, ty]; // 左上角\n            texCoordArray[1] = [tr, ty]; // 右上角\n            texCoordArray[2] = [tr, tb]; // 右下角\n            texCoordArray[3] = [tx, tb]; // 左下角\n            var color = [255, 255, 255]; //白色，在glsl里会成为一个1,1,1的向量，这样就不会改变贴图数据了\n            action.collectVertexData(pathList, color, opacity, texCoordArray);\n        }\n    }, {\n        key: \"fill\",\n        value: function fill() {\n            var fillColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            this[_renderActionList].push(action);\n            action.collectVertexData(pathList, fillColor, opacity * fillColor[3], [0, 0]);\n        }\n    }, {\n        key: \"fillRect\",\n        value: function fillRect(x, y, w, h) {\n            this.beginPath();\n            this.rect(x, y, w, h);\n            this.fill();\n        }\n    }, {\n        key: \"stroke\",\n        value: function stroke() {\n            var strokeColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.strokeStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_STROKE);\n            this[_renderActionList].push(action);\n            action.collectVertexData(pathList, strokeColor, opacity * strokeColor[3], [0, 0]);\n        }\n\n        //******************** 扩展接口 *****************************//\n\n    }, {\n        key: \"turnOnLight\",\n        value: function turnOnLight() {\n            this.webglRender.enableLight(true);\n        }\n    }, {\n        key: \"turnOffLight\",\n        value: function turnOffLight() {\n            this.webglRender.enableLight(false);\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(x, y, z) {\n            this.webglRender.setLightPosition(x, y, z);\n        }\n    }, {\n        key: \"fillOrStroke\",\n        value: function fillOrStroke(fillColor, strokeColor) {\n            if (fillColor != undefined) {\n                this.fillStyle = fillColor;\n                this.fill();\n            }\n            if (strokeColor != undefined) {\n                this.strokeStyle = strokeColor;\n                this.stroke();\n            }\n        }\n    }, {\n        key: \"drawRectangle\",\n        value: function drawRectangle(x, y, w, h, fillColor, strokeColor) {\n            this.save();\n            this.beginPath();\n            this.rect(x, y, w, h);\n            this.fillOrStroke(fillColor, strokeColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawEllipse\",\n        value: function drawEllipse(x, y, r1, r2, fillColor, strokeColor, rotation) {\n            this.save();\n            this.beginPath();\n            this.ellipse(x, y, r1, r2, rotation, 0, _Tools2.default.PI2, false);\n            this.closePath();\n            this.fillOrStroke(fillColor, strokeColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawCircle\",\n        value: function drawCircle(x, y, r, fillColor, strokeColor) {\n            this.drawEllipse(x, y, r, r, fillColor, strokeColor, 0);\n        }\n    }, {\n        key: \"draw\",\n        value: function draw() {\n            this.webglRender.initRending();\n            this.webglRender.executeRenderAction(this[_renderActionList], this[_stateArray]);\n            this[_renderActionList] = [];\n            this[_stateArray] = [];\n            // debug:\n            // console.log(\"绘制调用次数：\", this.webglRender.DEBUG_DRAW_COUNT);\n        }\n    }, {\n        key: \"currentContextState\",\n        get: function get() {\n            if (this[_stateStack].length == 0) {\n                // 状态栈永远不为空\n                var state = new _ContextState2.default(new _CanvasDrawingStylesWebgl2D2.default());\n                this[_stateStack].push(state);\n                this[_stateArray].push(state);\n                state.id = this[_stateArray].length - 1;\n            }\n            return this[_stateStack][this[_stateStack].length - 1];\n        }\n    }, {\n        key: \"currentPath\",\n        get: function get() {\n            if (this[_pathList].length == 0) {\n                this[_pathList].push(new _Path3D2.default());\n            }\n            return this[_pathList][this[_pathList].length - 1];\n        }\n\n        /**************** 下面是标准接口实现 *************************/\n\n        /**\r\n         * back-reference to the canvas\r\n         * Canvas的回引用\r\n         * @returns {canvas}\r\n         */\n\n    }, {\n        key: \"canvas\",\n        get: function get() {\n            return this[_canvas];\n        }\n    }, {\n        key: \"strokeStyle\",\n        set: function set(stroke) {\n            this.currentContextState.strokeStyle = stroke;\n        },\n        get: function get() {\n            return this.currentContextState.strokeStyle;\n        }\n    }, {\n        key: \"fillStyle\",\n        set: function set(fill) {\n            this.currentContextState.fillStyle = fill;\n        },\n        get: function get() {\n            return this.currentContextState.fillStyle;\n        }\n    }, {\n        key: \"globalAlpha\",\n        set: function set(alpha) {\n            this.currentContextState.globalAlpha = alpha;\n        },\n        get: function get() {\n            return this.currentContextState.globalAlpha;\n        }\n    }]);\n\n    return CanvasRenderingContextWebgl2D;\n}();\n\nexports.default = CanvasRenderingContextWebgl2D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ }),

/***/ "./github/src/webgl/ContextState.js":
/*!******************************************!*\
  !*** ./github/src/webgl/ContextState.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./github/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _transformMatrix = Symbol('变换矩阵');\n\nvar ContextState = function () {\n    function ContextState(canvasDrawingStyle) {\n        _classCallCheck(this, ContextState);\n\n        this.canvasDrawingStyle = canvasDrawingStyle;\n        this.matrixIndex = 0;\n        this.fillStyle = '#000000';\n        this.strokeStyle = '#000000';\n        this.globalAlpha = 1;\n        this.id = -1;\n        this.matrixArray = [];\n        this.matrixArray.push(_Mat2.default.identity());\n        this.dirty = false;\n    }\n\n    _createClass(ContextState, [{\n        key: \"fireDirty\",\n        value: function fireDirty() {\n            this.dirty = true;\n        }\n    }, {\n        key: \"setTransformMatrix\",\n        value: function setTransformMatrix(value) {\n            var current = this.transformMatrix.matrix;\n            _Mat2.default.copy(value, current);\n        }\n    }, {\n        key: \"checkDirty\",\n        value: function checkDirty() {\n            // 如果当前的矩阵会被应用到某些节点上，则说明这个矩阵脏了，\n            // 一旦变换矩阵就要保存一下，并把这个矩阵的克隆放入数组底\n            if (this.dirty) {\n                var m1 = _Mat2.default.identity();\n                var lastMatrix = this.transformMatrix.matrix;\n                _Mat2.default.copy(lastMatrix, m1);\n                this.matrixArray.push(m1);\n                this.dirty = false;\n            }\n        }\n    }, {\n        key: \"applyTransform\",\n        value: function applyTransform(currentTransformMatrix) {\n            this.checkDirty();\n            var lastMatrix = this.transformMatrix.matrix;\n            _Mat2.default.multiply(lastMatrix, lastMatrix, currentTransformMatrix);\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            if (z === undefined) z = 0;\n            if (_Tools2.default.equals(x, 0) && _Tools2.default.equals(y, 0) && _Tools2.default.equals(z, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.translationMatrix(m, x, y, z);\n            this.applyTransform(m);\n        }\n\n        // 默然是按照z轴旋转\n\n    }, {\n        key: \"rotateZ\",\n        value: function rotateZ(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationZMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationXMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationYMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            if (scaleZ === undefined) scaleZ = 1;\n            if (_Tools2.default.equals(scaleX, 1) && _Tools2.default.equals(scaleY, 1) && _Tools2.default.equals(scaleZ, 1)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.scalingMatrix(m, scaleX, scaleY, scaleZ);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"clone\",\n        value: function clone() {\n            var newState = new ContextState(this.canvasDrawingStyle.clone());\n            newState.fillStyle = this.fillStyle;\n            newState.strokeStyle = this.strokeStyle;\n            newState.globalAlpha = this.globalAlpha;\n            newState.matrixIndex = this.matrixIndex;\n            // 把当前的矩阵作为新矩阵的最后一个\n            newState.setTransformMatrix(this.transformMatrix.matrix);\n            return newState;\n        }\n    }, {\n        key: \"transformMatrixId\",\n        get: function get() {\n            return this.matrixArray.length - 1;\n        }\n    }, {\n        key: \"transformMatrix\",\n        get: function get() {\n            var index = this.matrixArray.length - 1;\n            var m = this.matrixArray[index];\n            return { matrix: m, id: index };\n        }\n    }]);\n\n    return ContextState;\n}();\n\nexports.default = ContextState;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/ContextState.js?");

/***/ }),

/***/ "./github/src/webgl/DataBuffer.js":
/*!****************************************!*\
  !*** ./github/src/webgl/DataBuffer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MAX_SINGLE_BYTE_LENGTH = 32 * 6 * 100; // 默认buffer长度就是100个矩形的长度\nvar TYPE_FLOAT32 = 4;\nvar TYPE_FLOAT64 = 8;\nvar TYPE_UINT8 = 2;\nvar TYPE_UINT16 = 3;\nvar TYPE_UINT32 = 0;\nvar TYPE_INT8 = 5;\nvar TYPE_INT16 = 6;\nvar TYPE_INT32 = 7;\nvar TYPE_UINT8CLAMPED = 1;\nvar _currentByteIndex = Symbol('当前buffer数据所在的字节索引');\nvar _singleDataFragmentSize = Symbol('单个数据块字节大小');\nvar _dataStructure = Symbol('ArrayBuffer的数据存放结构');\nvar _currentStructureIndex = Symbol('当前所在结构中的索引');\nvar littleEndian = undefined; // DataView是否是按照低位存放\n\nvar DataBuffer = function () {\n    function DataBuffer(dataStructure, length) {\n        _classCallCheck(this, DataBuffer);\n\n        if (length === undefined) length = MAX_SINGLE_BYTE_LENGTH;\n        this.buffer = new ArrayBuffer(length);\n        this.dv = new DataView(this.buffer);\n        this.byteDv = new Uint8Array(this.buffer);\n        this[_dataStructure] = dataStructure;\n        var that = this;\n        var initDataStructure = function initDataStructure(dataStructure) {\n            if (dataStructure === undefined || dataStructure === null) {\n                // 如果没有设置数据结构，那就默认是单个float32进行添加\n                console.warn(\"DataStructure没有指定，默认单个float32数据进行存放。DataStructure必须是一个数组，其内部结构为 [...{type:type,count:count,byteSize:size},...]\");\n                that[_singleDataFragmentSize] = 4;\n                that[_dataStructure] = undefined;\n                return;\n            } else {\n                if (!(dataStructure instanceof Array)) {\n                    console.warn(\"DataStructure必须是一个数组，其内部结构为 [...{type:type,count:count,byteSize:size},...]\");\n                    that[_singleDataFragmentSize] = 4;\n                    that[_dataStructure] = undefined;\n                    return;\n                }\n                var size = 0;\n                var startByte = 0;\n                var endByte = 0;\n                for (var i = 0; i < dataStructure.length; i++) {\n                    var s = dataStructure[i];\n                    s.byteSize = that.getByteSize(s.type) * s.count;\n                    s.startByte = startByte;\n                    endByte = startByte + s.byteSize;\n                    s.endByte = endByte - 1;\n                    size += s.byteSize;\n                    startByte = endByte;\n                }\n                that[_singleDataFragmentSize] = size;\n            }\n        };\n\n        initDataStructure(this[_dataStructure]);\n        this[_currentStructureIndex] = 0;\n        this[_currentByteIndex] = 0;\n    }\n\n    _createClass(DataBuffer, [{\n        key: 'flush',\n        value: function flush(byteLength) {\n            if (byteLength != undefined) {\n                if (byteLength != this.buffer.byteLength) {\n                    this.buffer = new ArrayBuffer(byteLength);\n                    this.dv = new DataView(this.buffer);\n                    this.byteDv = new Uint8Array(this.buffer);\n                }\n            } else {\n                for (var i = 0; i < this.buffer.byteLength; i++) {\n                    this.byteDv[i] = 0.0;\n                }\n            }\n            this[_currentStructureIndex] = 0;\n            this[_currentByteIndex] = 0;\n        }\n    }, {\n        key: 'getByteSize',\n        value: function getByteSize(type) {\n            switch (type) {\n                case TYPE_FLOAT64:\n                    return 8;\n                case TYPE_UINT8CLAMPED:\n                case TYPE_INT8:\n                case TYPE_UINT8:\n                    return 1;\n                case TYPE_INT16:\n                case TYPE_UINT16:\n                    return 2;\n                case TYPE_FLOAT32:\n                case TYPE_INT32:\n                case TYPE_UINT32:\n                    return 4;\n            }\n            return 0;\n        }\n    }, {\n        key: 'put',\n        value: function put(value) {\n            if (value instanceof Array) {\n                for (var i = 0; i < value.length; i++) {\n                    this.put(value[i]);\n                }\n            } else {\n                if (this.dataStructure === undefined) {\n                    this.resizeBuffer(4);\n                    this.dv.setFloat32(this.currentIndex, value, DataBuffer.littleEndian);\n                    this[_currentByteIndex] += this.singleDataFragmentByteSize;\n                } else {\n                    var structure = this.dataStructure[this[_currentStructureIndex]];\n                    var size = this.getByteSize(structure.type);\n                    this.resizeBuffer(size);\n                    this.setValue(structure.type, value);\n                    var k = this.currentIndex % this.singleDataFragmentByteSize;\n                    if (k == 0) {\n                        this[_currentStructureIndex] = 0;\n                        return;\n                    }\n                    if (k > structure.endByte) {\n                        this[_currentStructureIndex]++;\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'get',\n        value: function get(offset, type) {\n            var littleEndian = DataBuffer.littleEndian;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    return this.dv.getFloat64(offset, littleEndian);\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    return this.dv.getUint8(offset);\n                    break;\n                case TYPE_INT8:\n                    return this.dv.getInt8(offset);\n                    break;\n                case TYPE_UINT8:\n                    return this.dv.getUint8(offset);\n                    break;\n                case TYPE_INT16:\n                    return this.dv.getInt16(offset, littleEndian);\n                    break;\n                case TYPE_UINT16:\n                    return this.dv.getUint16(offset, littleEndian);\n                    break;\n                case TYPE_FLOAT32:\n                    return this.dv.getFloat32(offset, littleEndian);\n                    break;\n                case TYPE_INT32:\n                    return this.dv.getInt32(offset, littleEndian);\n                    break;\n                case TYPE_UINT32:\n                    return this.dv.getUint32(offset, littleEndian);\n                    break;\n            }\n        }\n    }, {\n        key: 'setValue',\n        value: function setValue(type, value) {\n            var littleEndian = DataBuffer.littleEndian;\n            var index = this.currentIndex;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    this.dv.setFloat64(index, value, littleEndian);\n                    this[_currentByteIndex] += 8;\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    this.dv.setUint8(index, value);\n                    this[_currentByteIndex] += 1;\n                    break;\n                case TYPE_INT8:\n                    this.dv.setInt8(index, value);\n                    this[_currentByteIndex] += 1;\n                    break;\n                case TYPE_UINT8:\n                    this.dv.setUint8(index, value);\n                    this[_currentByteIndex] += 1;\n                    break;\n                case TYPE_INT16:\n                    this.dv.setInt16(index, value, littleEndian);\n                    this[_currentByteIndex] += 2;\n                    break;\n                case TYPE_UINT16:\n                    this.dv.setUint16(index, value, littleEndian);\n                    this[_currentByteIndex] += 2;\n                    break;\n                case TYPE_FLOAT32:\n                    this.dv.setFloat32(index, value, littleEndian);\n                    this[_currentByteIndex] += 4;\n                    break;\n                case TYPE_INT32:\n                    this.dv.setInt32(index, value, littleEndian);\n                    this[_currentByteIndex] += 4;\n                    break;\n                case TYPE_UINT32:\n                    this.dv.setUint32(index, value, littleEndian);\n                    this[_currentByteIndex] += 4;\n                    break;\n            }\n        }\n    }, {\n        key: 'addLength',\n        value: function addLength(additionLength) {\n            // ArrayBuffer是不能直接进行读取的，所以利用uint8一个一个字节复制过去,这里用了TypedArray的set方法\n            var sourceView = this.byteDv;\n            var destView = new Uint8Array(new ArrayBuffer(this.buffer.byteLength + additionLength));\n            destView.set(sourceView);\n            this.buffer = destView.buffer;\n            this.dv = new DataView(this.buffer);\n            this.byteDv = new Uint8Array(this.buffer);\n        }\n    }, {\n        key: 'resizeBuffer',\n        value: function resizeBuffer(additionLength) {\n            if (additionLength === undefined) additionLength = this.singleDataFragmentByteSize;\n            if (this[_currentByteIndex] + additionLength > this.buffer.byteLength) {\n                this.addLength(additionLength);\n            }\n        }\n    }, {\n        key: 'clean',\n        value: function clean() {\n            // 重新new一个出来\n            this.buffer = new ArrayBuffer(this.buffer.byteLength);\n            this.dv = new DataView(this.buffer);\n            this.byteDv = new Uint8Array(this.buffer);\n            this[_currentByteIndex] = 0;\n            this[_currentStructureIndex] = 0;\n        }\n    }, {\n        key: 'getVertex',\n        value: function getVertex(index) {\n            if (index > this.currentIndex || index < 0) throw new Error('Index Error');\n            return [this.dv.getFloat32(index), this.dv.getFloat32(index + 4), this.dv.getFloat32(index + 8)];\n        }\n    }, {\n        key: 'modifyVertex',\n        value: function modifyVertex(vertex, index) {\n            var littleEndian = DataBuffer.littleEndian;\n            if (index > this.currentIndex || index < 0) throw new Error('Index Error');\n            this.dv.setFloat32(index, vertex[0], littleEndian);\n            this.dv.setFloat32(index + 4, vertex[1], littleEndian);\n            this.dv.setFloat32(index + 8, vertex[2], littleEndian);\n        }\n    }, {\n        key: 'putVertexData',\n        value: function putVertexData(vertex, color, opacity, texcoord) {\n            this.resizeBuffer(this.singleDataFragmentByteSize);\n            var littleEndian = DataBuffer.littleEndian;\n            var index = this.currentIndex;\n            this.dv.setFloat32(index, vertex[0], littleEndian);\n            this.dv.setFloat32(index + 4, vertex[1], littleEndian);\n            this.dv.setFloat32(index + 8, vertex[2], littleEndian);\n            // this.dv.setFloat32(index + 12, trasnformMatrixIndex, littleEndian);\n            // 这里插入1位float类型的无用数据，为了数据对齐\n            this.dv.setFloat32(index + 16, 0, littleEndian);\n            // 再继续添加顶点数据\n            this.dv.setUint8(index + 20, color[0]);\n            this.dv.setUint8(index + 21, color[1]);\n            this.dv.setUint8(index + 22, color[2]);\n            this.dv.setUint8(index + 23, Math.floor(opacity * 100));\n            this.dv.setFloat32(index + 24, texcoord[0], littleEndian);\n            this.dv.setFloat32(index + 28, texcoord[1], littleEndian);\n\n            this[_currentByteIndex] += this.singleDataFragmentByteSize;\n        }\n    }, {\n        key: 'dataStructure',\n        get: function get() {\n            return this[_dataStructure];\n        }\n    }, {\n        key: 'currentIndex',\n        get: function get() {\n            return this[_currentByteIndex];\n        }\n    }, {\n        key: 'bufferByteLength',\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }, {\n        key: 'singleDataFragmentByteSize',\n        get: function get() {\n            return this[_singleDataFragmentSize];\n        }\n    }, {\n        key: 'vertexCount',\n        get: function get() {\n            return this.currentIndex / this.singleDataFragmentByteSize;\n        }\n    }, {\n        key: 'length',\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }], [{\n        key: 'TYPE_FLOAT32',\n        get: function get() {\n            return TYPE_FLOAT32;\n        }\n    }, {\n        key: 'TYPE_FLOAT64',\n        get: function get() {\n            return TYPE_FLOAT64;\n        }\n    }, {\n        key: 'TYPE_UINT8',\n        get: function get() {\n            return TYPE_UINT8;\n        }\n    }, {\n        key: 'TYPE_UINT16',\n        get: function get() {\n            return TYPE_UINT16;\n        }\n    }, {\n        key: 'TYPE_UINT32',\n        get: function get() {\n            return TYPE_UINT32;\n        }\n    }, {\n        key: 'TYPE_INT8',\n        get: function get() {\n            return TYPE_INT8;\n        }\n    }, {\n        key: 'TYPE_INT16',\n        get: function get() {\n            return TYPE_INT16;\n        }\n    }, {\n        key: 'TYPE_INT32',\n        get: function get() {\n            return TYPE_INT32;\n        }\n    }, {\n        key: 'TYPE_UINT8CLAMPED',\n        get: function get() {\n            return TYPE_UINT8CLAMPED;\n        }\n    }, {\n        key: 'littleEndian',\n        get: function get() {\n            if (littleEndian === undefined) {\n                // DataView是默认按照高位存放，这里要做判断，更改存放顺序\n                // PS: Float32Array却是按照低位存放的\n                var arrayBuffer = new ArrayBuffer(2);\n                var uint8Array = new Uint8Array(arrayBuffer);\n                var uint16array = new Uint16Array(arrayBuffer);\n                uint8Array[0] = 0xAA; // 第一位是AA\n                uint8Array[1] = 0xBB; // 第二位是BB\n                // 如果从16的view中读取数据，按照其排序就能得出高低位，以便DataView在设置值的时候能正确\n                if (uint16array[0] === 0xBBAA) littleEndian = true;\n                if (uint16array[0] === 0xAABB) littleEndian = false;\n            }\n            return littleEndian;\n        }\n    }]);\n\n    return DataBuffer;\n}();\n\nexports.default = DataBuffer;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/DataBuffer.js?");

/***/ }),

/***/ "./github/src/webgl/Path3D.js":
/*!************************************!*\
  !*** ./github/src/webgl/Path3D.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Path3D = function () {\n    function Path3D() {\n        _classCallCheck(this, Path3D);\n\n        this.subPathArray = [];\n    }\n\n    _createClass(Path3D, [{\n        key: \"addSubPath\",\n        value: function addSubPath(subPath) {\n            this.subPathArray.push(subPath);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.subPathArray.length = 0;\n        }\n    }, {\n        key: \"subPathNumber\",\n        get: function get() {\n            return this.subPathArray.length;\n        }\n    }, {\n        key: \"lastSubPath\",\n        get: function get() {\n            if (this.subPathNumber != 0) {\n                return this.subPathArray[this.subPathNumber - 1];\n            }\n        }\n    }]);\n\n    return Path3D;\n}();\n\nexports.default = Path3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/Path3D.js?");

/***/ }),

/***/ "./github/src/webgl/Point3D.js":
/*!*************************************!*\
  !*** ./github/src/webgl/Point3D.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _point = Symbol('存放坐标值的Float32数组');\nvar _transformMatrixIndex = Symbol('坐标转换矩阵索引');\n\nvar Point3D = function () {\n    function Point3D(x, y, z) {\n        _classCallCheck(this, Point3D);\n\n        this[_point] = new Float32Array(3);\n        this[_transformMatrixIndex] = new Uint16Array(2);\n        this[_point][0] = x;\n        this[_point][1] = y;\n        this[_point][2] = z;\n    }\n\n    _createClass(Point3D, [{\n        key: 'matrixIdData',\n        get: function get() {\n            return this[_transformMatrixIndex];\n        }\n    }, {\n        key: 'contextStateIndex',\n        get: function get() {\n            return this[_transformMatrixIndex][0];\n        },\n        set: function set(index) {\n            this[_transformMatrixIndex][0] = index;\n        }\n    }, {\n        key: 'transformMatrixIndex',\n        get: function get() {\n            return this[_transformMatrixIndex][1];\n        },\n        set: function set(index) {\n            this[_transformMatrixIndex][1] = index;\n        }\n    }, {\n        key: 'value',\n        get: function get() {\n            return this[_point];\n        },\n        set: function set(value) {\n            this[_point][0] = value[0];\n            this[_point][1] = value[1];\n            this[_point][2] = value[2];\n        }\n    }, {\n        key: 'x',\n        get: function get() {\n            return this[_point][0];\n        },\n        set: function set(x) {\n            this[_point][0] = x;\n        }\n    }, {\n        key: 'y',\n        get: function get() {\n            return this[_point][1];\n        },\n        set: function set(y) {\n            this[_point][1] = y;\n        }\n    }, {\n        key: 'z',\n        get: function get() {\n            return this[_point][2];\n        },\n        set: function set(z) {\n            this[_point][2] = z;\n        }\n    }]);\n\n    return Point3D;\n}();\n\nexports.default = Point3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/Point3D.js?");

/***/ }),

/***/ "./github/src/webgl/RenderAction.js":
/*!******************************************!*\
  !*** ./github/src/webgl/RenderAction.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _VertexData = __webpack_require__(/*! ./VertexData.js */ \"./github/src/webgl/VertexData.js\");\n\nvar _VertexData2 = _interopRequireDefault(_VertexData);\n\nvar _EarClipping = __webpack_require__(/*! ../geometry/EarClipping.js */ \"./github/src/geometry/EarClipping.js\");\n\nvar _EarClipping2 = _interopRequireDefault(_EarClipping);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ACTION_STROKE = 0; // stroke动作\nvar ACTION_FILL = 1; // fill动作\n\nvar RenderAction = function () {\n    function RenderAction(type) {\n        _classCallCheck(this, RenderAction);\n\n        this.type = type;\n        this.vertexData = null;\n        this.textureIndex = -1;\n    }\n\n    _createClass(RenderAction, [{\n        key: \"getVertexData\",\n        value: function getVertexData(vertexNumber) {\n            if (this.vertexData == null) {\n                this.vertexData = new _VertexData2.default(this.type, vertexNumber);\n            } else {\n                this.vertexData.resize(vertexNumber);\n            }\n            return this.vertexData;\n        }\n    }, {\n        key: \"collectVertexData\",\n        value: function collectVertexData(pathList, color, opacity, textureCoord) {\n            if (this.type == ACTION_FILL) {\n                this.collectVertexDataForFill(pathList, color, opacity, textureCoord);\n                return;\n            }\n            if (this.type == ACTION_STROKE) {\n                this.collectVertexDataForStroke(pathList, color, opacity, textureCoord);\n                return;\n            }\n        }\n    }, {\n        key: \"collectVertexDataForStroke\",\n        value: function collectVertexDataForStroke(pathList, color, opacity, textureCoord) {\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    var vertexCount = subPath.pointsNumber;\n                    if (vertexCount < 2) continue;\n                    if (subPath.isClosed) vertexCount++;\n                    var vertexData = this.getVertexData(vertexCount);\n                    for (var _i = 0; _i < vertexCount; _i++) {\n                        var index = _i % subPath.pointsNumber;\n                        vertexData.addMatrixIdData(subPath.getPoint(index).matrixIdData);\n                        vertexData.addVertexData(subPath.getPoint(index).value, color, opacity, textureCoord);\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"collectVertexDataForFill\",\n        value: function collectVertexDataForFill(pathList, color, opacity, textureCoord) {\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                if (path.subPathNumber == 0) {\n                    continue;\n                }\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    if (subPath.pointsNumber < 3) continue; // 小于三个无法填充成一个面\n                    this.organizeVertexForFill(subPath, color, opacity, textureCoord);\n                }\n            }\n        }\n    }, {\n        key: \"organizeVertexForFill\",\n        value: function organizeVertexForFill(subPath, color, opacity, textureCoord) {\n            var temp = new Array(subPath.pointsNumber * 2);\n            for (var i = 0; i < subPath.pointsNumber; i++) {\n                var p = subPath.getPoint(i);\n                var index = i * 2;\n                temp[index] = p.x;\n                temp[index + 1] = p.y;\n            }\n            var vertexOrg = _EarClipping2.default.earcut(temp);\n            var vertexData = this.getVertexData(vertexOrg.length);\n            for (var _i2 = 0; _i2 < vertexOrg.length; _i2++) {\n                var vertexIndex = vertexOrg[_i2];\n                vertexData.addMatrixIdData(subPath.getPoint(vertexIndex).matrixIdData);\n                if (textureCoord[0] instanceof Array) {\n                    vertexData.addVertexData(subPath.getPoint(vertexIndex).value, color, opacity, textureCoord[vertexIndex]);\n                } else {\n                    vertexData.addVertexData(subPath.getPoint(vertexIndex).value, color, opacity, textureCoord);\n                }\n            }\n        }\n    }], [{\n        key: \"ACTION_STROKE\",\n        get: function get() {\n            return ACTION_STROKE;\n        }\n    }, {\n        key: \"ACTION_FILL\",\n        get: function get() {\n            return ACTION_FILL;\n        }\n    }]);\n\n    return RenderAction;\n}();\n\nexports.default = RenderAction;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/RenderAction.js?");

/***/ }),

/***/ "./github/src/webgl/SubPath3D.js":
/*!***************************************!*\
  !*** ./github/src/webgl/SubPath3D.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TYPE_RECTANGLE = 0;\nvar TYPE_TRIANGLE = 1;\nvar TYPE_POLYGON = 2;\nvar TYPE_ELLIPSE = 3;\n\nvar SubPath3D = function () {\n    function SubPath3D(startPoint, type) {\n        _classCallCheck(this, SubPath3D);\n\n        this.pointsArray = [];\n        if (startPoint != undefined && startPoint != null) {\n            this.pushPoint(startPoint);\n        }\n        this.isClosed = false;\n        this.type = type || TYPE_POLYGON;\n    }\n\n    _createClass(SubPath3D, [{\n        key: \"close\",\n        value: function close() {\n            this.isClosed = true;\n        }\n    }, {\n        key: \"getPoint\",\n        value: function getPoint(index) {\n            return this.pointsArray[index];\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.pointsArray.length = 0;\n            this.isClosed = false;\n            // this.pointsArray = [];// 这样比length = 0 效率高???!!\n        }\n    }, {\n        key: \"pushPoint\",\n        value: function pushPoint(point) {\n            this.pointsArray.push(point);\n        }\n    }, {\n        key: \"popPoint\",\n        value: function popPoint() {\n            this.pointsArray.pop();\n        }\n    }, {\n        key: \"pointsNumber\",\n        get: function get() {\n            return this.pointsArray.length;\n        }\n    }], [{\n        key: \"TYPE_RECTANGLE\",\n        get: function get() {\n            return TYPE_RECTANGLE;\n        }\n    }, {\n        key: \"TYPE_POLYGON\",\n        get: function get() {\n            return TYPE_POLYGON;\n        }\n    }, {\n        key: \"TYPE_TRIANGLE\",\n        get: function get() {\n            return TYPE_TRIANGLE;\n        }\n    }, {\n        key: \"TYPE_ELLIPSE\",\n        get: function get() {\n            return TYPE_ELLIPSE;\n        }\n    }]);\n\n    return SubPath3D;\n}();\n\nexports.default = SubPath3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/SubPath3D.js?");

/***/ }),

/***/ "./github/src/webgl/TempCanvas.js":
/*!****************************************!*\
  !*** ./github/src/webgl/TempCanvas.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TempCanvas = function TempCanvas() {\n    _classCallCheck(this, TempCanvas);\n\n    return document.createElement('canvas');\n};\n\nexports.default = TempCanvas;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/TempCanvas.js?");

/***/ }),

/***/ "./github/src/webgl/TextureManager.js":
/*!********************************************!*\
  !*** ./github/src/webgl/TextureManager.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TempCanvas = __webpack_require__(/*! ./TempCanvas.js */ \"./github/src/webgl/TempCanvas.js\");\n\nvar _TempCanvas2 = _interopRequireDefault(_TempCanvas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _imageCatch = Symbol('图片缓存');\nvar _textCatch = Symbol('texture缓存');\n\nvar TextureManager = function () {\n    function TextureManager(maxWidth, maxHeight, maxTextureNum, space) {\n        _classCallCheck(this, TextureManager);\n\n        this.maxWidth = maxWidth || 1;\n        this.maxHeight = maxHeight || 1;\n        this.maxTextureNum = maxTextureNum || 1;\n        this[_imageCatch] = [];\n        this[_textCatch] = [];\n        this.imageDataArray = new Array(this.maxTextureNum);\n        this.textureArray = new Array(this.maxTextureNum);\n        this.singleTexture = undefined;\n        this.lastImageData = undefined;\n        this.space = space || 3;\n    }\n\n    _createClass(TextureManager, [{\n        key: 'getTexture',\n        value: function getTexture(image, gl, autoGenerateTexture) {\n            var index = this.imageCatch.indexOf(image);\n            if (index == -1) {\n                return this.registerImageData(image, gl, autoGenerateTexture);\n            } else {\n                return this[_textCatch][index];\n            }\n        }\n    }, {\n        key: 'registerImageData',\n        value: function registerImageData(image, gl, autoGenerateTexture) {\n            if (image == undefined || image == null) {\n                console.error('Image can not be null');\n                return;\n            }\n            if (autoGenerateTexture == undefined) autoGenerateTexture = false;\n            var x = 0;\n            var y = 0;\n            var imgW = image.width;\n            var imgH = image.height;\n            if (imgW > this.maxWidth || imgH > this.maxHeight) {\n                throw new Error('图片大小超过了最大限制：' + this.maxWidth + \" x \" + this.maxHeight);\n                return;\n            }\n            if (this.imageCatch.indexOf(image) == -1) {\n                var canvas = new _TempCanvas2.default(); // 这个地方用个类是为了便于微信小程序的适配\n                var ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                /**\r\n                 * 利用一个离屏canvas的2d context重新绘制一个套image并生成texture\r\n                 * 这个离屏canvas的0,0点是一个黑色的像素点，所以绘制其他image从[0,1]开始\r\n                 */\n                var currentTextureIndex = -1;\n                for (var i = 0; i < this.imageDataArray.length; i++) {\n                    var imageData = this.imageDataArray[i];\n                    if (imageData == undefined) {\n                        imageData = { imageData: undefined, startX: 0, startY: 0, width: 0, height: 0 };\n                        this.imageDataArray[i] = imageData;\n                        canvas.width = image.width;\n                        canvas.height = image.height + 1;\n                        x = 0;\n                        y = 1;\n                        ctx.fillStyle = \"#ffffff\";\n                        ctx.fillRect(0, 0, 1, 1); // 这个像素点是给一般fill用的texture颜色\n                        ctx.drawImage(image, 0, 1);\n                        // 保存当前绘制出来的图像数据\n                        imageData.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        imageData.startX = canvas.width + this.space;\n                        imageData.startY = 1;\n                        imageData.width = canvas.width;\n                        imageData.height = canvas.height;\n                    } else {\n                        var width = image.width;\n                        var height = image.height;\n                        x = imageData.startX;\n                        y = imageData.startY;\n                        if (x + width > this.maxWidth) {\n                            x = 0; // 从下一行开始画\n                            y = imageData.height + this.space;\n                            canvas.width = Math.max(imageData.width, width);\n                            canvas.height = y + height;\n                            console.log('换行');\n                        } else {\n                            canvas.width = Math.max(imageData.width, x + width);\n                            canvas.height = Math.max(imageData.height, y + height);\n                            console.log('不换行');\n                        }\n                        if (y + height > this.maxHeight) {\n                            // 图片已经超过最大可以绘制的空间，换另外一个texture\n                            console.log('图片超过贴图内存最大尺寸');\n                            continue;\n                        }\n                        // 将之前的像素数据放入新的canvas中\n                        ctx.putImageData(imageData.imageData, 0, 0);\n                        ctx.drawImage(image, x, y);\n                        imageData.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        imageData.startX = x + width + this.space;\n                        imageData.startY = y;\n                        imageData.width = canvas.width;\n                        imageData.height = canvas.height;\n                    }\n                    currentTextureIndex = i;\n                    break;\n                }\n\n                if (currentTextureIndex != -1) {\n                    this.imageCatch.push(image);\n                    var textureInfo = { x: x, y: y, width: imgW, height: imgH, index: currentTextureIndex };\n                    if (autoGenerateTexture) {\n                        this.createTexture(gl, currentTextureIndex, canvas);\n                    }\n                    this[_textCatch].push(textureInfo);\n                    return textureInfo;\n                }\n            }\n        }\n    }, {\n        key: 'createAllTexture',\n        value: function createAllTexture(gl) {\n            if (gl == undefined) return;\n            var canvas = new _TempCanvas2.default();\n            var ctx = canvas.getContext('2d');\n            for (var i = 0; i < this.textureArray.length; i++) {\n                this.createTexture(gl, i, canvas);\n            }\n        }\n    }, {\n        key: 'createTexture',\n        value: function createTexture(gl, index, canvas) {\n            if (gl == undefined || index == undefined || index == -1) return;\n            if (canvas == undefined) {\n                canvas = new _TempCanvas2.default();\n            }\n            var ctx = canvas.getContext('2d');\n            var texture = this.textureArray[index];\n            var imgData = this.imageDataArray[index];\n            if (imgData != undefined) {\n                canvas.width = imgData.width;\n                canvas.height = imgData.height;\n                ctx.putImageData(imgData.imageData, 0, 0);\n                if (texture == undefined) {\n                    texture = gl.createTexture();\n                    this.textureArray[index] = texture;\n                }\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                if (TextureManager.isPOT(canvas.width) && TextureManager.isPOT(canvas.height)) {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                } else {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            }\n        }\n    }, {\n        key: 'imageCatch',\n        get: function get() {\n            return this[_imageCatch];\n        }\n    }], [{\n        key: 'isPOT',\n        value: function isPOT(value) {\n            return value > 0 && (value - 1 & value) === 0;\n        }\n    }]);\n\n    return TextureManager;\n}();\n\nexports.default = TextureManager;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/TextureManager.js?");

/***/ }),

/***/ "./github/src/webgl/VertexData.js":
/*!****************************************!*\
  !*** ./github/src/webgl/VertexData.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataBuffer = __webpack_require__(/*! ./DataBuffer.js */ \"./github/src/webgl/DataBuffer.js\");\n\nvar _DataBuffer2 = _interopRequireDefault(_DataBuffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// 这里每个节点大小如下：\n// 1. 三位是坐标，float类型，共3*4 , 12字节\n// 2. 两位是贴图坐标，float类型，共2*4 , 8个字节\n// 3. 四位颜色坐标, unsigleint类型，共4个字节\n// 4. 有两位float类型，是空的，只是为了让整个数据块成为16的倍数,这不是强迫症，而是叫做数据对齐\nvar VERTEX_DATA_STRUCTURE = [{ type: _DataBuffer2.default.TYPE_FLOAT32, count: 3 }, { type: _DataBuffer2.default.TYPE_FLOAT32, count: 2 }, { type: _DataBuffer2.default.TYPE_UINT8, count: 4 }, { type: _DataBuffer2.default.TYPE_FLOAT32, count: 2 }];\nvar VERTEX_BYTE_LENGTH = 32;\n\nvar MATRIX_INDEX_STRUCTURE = [{ type: _DataBuffer2.default.TYPE_FLOAT32, count: 1 }];\nvar MATRIX_INDEX_BYTE_LENGTH = 4;\n\nvar MATRIX_ID_STRUCTURE = [{ type: _DataBuffer2.default.TYPE_UINT16, count: 2 }];\nvar MATRIX_ID_BYTE_LENGTH = 4;\n\nvar TYPE_FILL = 0;\nvar TYPE_STROKE = 1;\n\nvar VertexData = function () {\n    function VertexData(type, vertexNum) {\n        _classCallCheck(this, VertexData);\n\n        this.type = type;\n        this.dataBuffer = new _DataBuffer2.default(VERTEX_DATA_STRUCTURE, vertexNum * VERTEX_BYTE_LENGTH);\n        // 因为attribute不允许int类型，只有用float代替了\n        this.matrixIndexBuffer = new _DataBuffer2.default(MATRIX_INDEX_STRUCTURE, vertexNum * MATRIX_INDEX_BYTE_LENGTH);\n        // this.matrixIdBuffer = new DataBuffer(MATRIX_ID_STRUCTURE, vertexNum * MATRIX_ID_BYTE_LENGTH);\n        this.matrixIdArray = [];\n    }\n\n    _createClass(VertexData, [{\n        key: \"resize\",\n        value: function resize(vertexNum) {\n            this.dataBuffer.addLength(vertexNum * VERTEX_BYTE_LENGTH);\n            this.matrixIndexBuffer.addLength(vertexNum * MATRIX_INDEX_BYTE_LENGTH);\n            // this.matrixIdBuffer.addLength(vertexNum * MATRIX_ID_BYTE_LENGTH);\n        }\n    }, {\n        key: \"addVertexData\",\n        value: function addVertexData(points, color, opacity, textureCoor) {\n            this.dataBuffer.putVertexData(points, color, opacity, textureCoor);\n            // this.matrixIndexBuffer.put(transformMatrixId);\n        }\n    }, {\n        key: \"addMatrixIdData\",\n        value: function addMatrixIdData(data) {\n            this.matrixIdArray.push(data);\n        }\n    }, {\n        key: \"getMatrixIdData\",\n        value: function getMatrixIdData(vertexIndex) {\n            return this.matrixIdArray[vertexIndex];\n        }\n    }, {\n        key: \"getContextStateIndex\",\n        value: function getContextStateIndex(vertexIndex) {\n            return this.matrixIdArray[vertexIndex][0];\n        }\n    }, {\n        key: \"getMatrixIndex\",\n        value: function getMatrixIndex(vertexIndex) {\n            return this.matrixIdArray[vertexIndex][1];\n        }\n    }, {\n        key: \"putMatrixId\",\n        value: function putMatrixId(id) {\n            this.matrixIndexBuffer.put(id);\n        }\n    }, {\n        key: \"vertexNumber\",\n        get: function get() {\n            return this.bufferSize / VERTEX_BYTE_LENGTH;\n        }\n    }, {\n        key: \"bufferSize\",\n        get: function get() {\n            return this.dataBuffer.currentIndex;\n        }\n    }], [{\n        key: \"VERTEX_BYTE_SIZE\",\n        get: function get() {\n            return VERTEX_BYTE_LENGTH;\n        }\n    }, {\n        key: \"TYPE_FILL\",\n        get: function get() {\n            return TYPE_FILL;\n        }\n    }, {\n        key: \"TYPE_STROKE\",\n        get: function get() {\n            return TYPE_STROKE;\n        }\n    }]);\n\n    return VertexData;\n}();\n\nexports.default = VertexData;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/VertexData.js?");

/***/ }),

/***/ "./github/src/webgl/WebGLRender.js":
/*!*****************************************!*\
  !*** ./github/src/webgl/WebGLRender.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TextureManager = __webpack_require__(/*! ./TextureManager.js */ \"./github/src/webgl/TextureManager.js\");\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _RenderAction = __webpack_require__(/*! ./RenderAction.js */ \"./github/src/webgl/RenderAction.js\");\n\nvar _RenderAction2 = _interopRequireDefault(_RenderAction);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./github/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SINGLE_DATA_BYTE_LENGTH = 32;\nvar fsSource = \"\\n  precision mediump float;\\n  varying vec4 currentColor;\\n  varying vec2 v_texcoord;\\n  varying vec3 normal;\\n  varying vec3 v_position;\\n  uniform vec2 singleCanvas;\\n  uniform vec3 u_lightPosition;\\n  uniform float enableLight;\\n  uniform sampler2D u_texture;\\n  void main() {\\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\\n        vec4 color = currentColor;\\n        vec3 r_normal = normalize(normal);    \\n        vec3 forward = u_lightPosition - v_position;\\n        vec3 lightLocation = normalize(forward);    \\n        gl_FragColor = color * texture2D(u_texture,coord);\\n        if(enableLight == 1.0){\\n            gl_FragColor.rgb *= abs(dot(r_normal,lightLocation));\\n        }\\n  }\\n  \";\n/**\r\n precision mediump float;\r\n varying vec4 currentColor;\r\n varying vec2 v_texcoord;\r\n uniform vec2 singleCanvas;\r\n uniform sampler2D u_texture;\r\n void main() {\r\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\r\n        vec4 color = currentColor;\r\n        gl_FragColor = color * texture2D(u_texture,coord);\r\n  }\r\n */\n\nvar _program = Symbol('WebGL的program');\nvar _maxTransformMatrixNum = Symbol('转换矩阵变量可用的最大数量');\n\nvar WebGLRender = function () {\n    function WebGLRender(gl, maxTransformNum, textureMaxSize, projectionType, defaultDepth, enableLight) {\n        _classCallCheck(this, WebGLRender);\n\n        this.gl = gl;\n        this.firstTIMEDEBUG = true;\n        this.DEBUG_DRAW_COUNT = 0;\n        this.configured = false;\n        projectionType = projectionType || 0;\n        textureMaxSize = textureMaxSize || gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n        var maxVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        // 顶点作色器里已经用了一个mat4了，就是4个vector,减去这4个然后除以4就得到可以定义的最大mat4数组\n        maxTransformNum = maxTransformNum || Math.floor((maxVectors - 4) / 4);\n        maxTransformNum = 2;\n        this[_maxTransformMatrixNum] = maxTransformNum;\n        // this[_maxTransformMatrixNum] = 10; // 测试设置\n        this.textureManager = null;\n        this.lightPosition = new Float32Array(3);\n        this.lightPosition[0] = gl.canvas.clientWidth / 2;\n        this.lightPosition[1] = gl.canvas.clientHeight / 2;\n        this.lightPosition[2] = 0;\n        this.init(projectionType, defaultDepth);\n        this.textureManager.maxHeight = textureMaxSize;\n        this.textureManager.maxWidth = this.textureManager.maxHeight;\n        enableLight = enableLight || false;\n        this.enableLight(enableLight);\n    }\n\n    _createClass(WebGLRender, [{\n        key: \"enableLight\",\n        value: function enableLight(flag) {\n            var value = 0;\n            if (flag) value = 1.0;else value = 0;\n            this.gl.uniform1f(this.shaderInformation.enableLight, value);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.DEBUG_DRAW_COUNT = 0;\n            this.gl.clearColor(0, 0, 0, 0);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n        }\n    }, {\n        key: \"initRending\",\n        value: function initRending() {\n            var gl = this.gl;\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        }\n    }, {\n        key: \"rendVertexArray\",\n        value: function rendVertexArray(type, vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex) {\n            var gl = this.gl;\n            this.gl.uniform3f(this.shaderInformation.lightPosition, this.lightPosition[0], this.lightPosition[1], this.lightPosition[2]);\n            switch (type) {\n                case _RenderAction2.default.ACTION_FILL:\n                    this.fillRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex);\n                    break;\n                case _RenderAction2.default.ACTION_STROKE:\n                    this.strokeRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex);\n                    break;\n            }\n        }\n    }, {\n        key: \"setUniformTransformMatrix\",\n        value: function setUniformTransformMatrix(matrix, id) {\n            var gl = this.gl;\n            gl.uniformMatrix4fv(this.shaderInformation.transformMatrixArray[id], false, matrix);\n        }\n    }, {\n        key: \"configVerticesBufferData\",\n        value: function configVerticesBufferData(vertexDataArray, firstVerticesStart, lastVerticesEnd) {\n            var size = 0;\n            var vertexNumber = 0;\n            if (firstVerticesStart == undefined) firstVerticesStart = 0;\n            for (var i = 0; i < vertexDataArray.length; i++) {\n                size += vertexDataArray[i].bufferSize;\n                if (i == vertexDataArray.length - 1 && lastVerticesEnd != undefined) {\n                    vertexNumber += lastVerticesEnd + 1;\n                } else {\n                    vertexNumber += vertexDataArray[i].vertexNumber;\n                }\n            }\n            vertexNumber -= firstVerticesStart;\n            var gl = this.gl;\n            this.prepareVertexDatas(size);\n            this.prepareMatrixIndexDatas(size / 8); //因为单个顶点的大小为32，矩阵索引是4，所以就是8倍的关系\n\n            var offset = 0;\n            var offset1 = 0;\n            for (var _i = 0; _i < vertexDataArray.length; _i++) {\n                var vertexData = vertexDataArray[_i];\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.shaderInformation.verticesBuffer);\n                this.gl.bufferSubData(this.gl.ARRAY_BUFFER, offset, vertexData.dataBuffer.buffer);\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.shaderInformation.matrixIndexBuffer);\n                this.gl.bufferSubData(this.gl.ARRAY_BUFFER, offset1, vertexData.matrixIndexBuffer.buffer);\n                offset += vertexData.dataBuffer.currentIndex;\n                offset1 += vertexData.matrixIndexBuffer.currentIndex;\n            }\n            return vertexNumber;\n        }\n    }, {\n        key: \"fillRendVertexArray\",\n        value: function fillRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex) {\n            if (firstVerticesStart == undefined) firstVerticesStart = 0;\n            if (vertexDataArray.length == 0) return;\n            this.configTexture(textureIndex);\n            var vertexNumber = this.configVerticesBufferData(vertexDataArray, firstVerticesStart, lastVerticesEnd);\n            if (vertexNumber < 3) return;\n            this.gl.drawArrays(this.gl.TRIANGLES, 0, vertexNumber);\n            this.DEBUG_DRAW_COUNT++;\n        }\n    }, {\n        key: \"strokeRendVertexArray\",\n        value: function strokeRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd) {\n            if (firstVerticesStart == undefined) firstVerticesStart = 0;\n            if (vertexDataArray.length == 0) return;\n            this.configTexture();\n            var vertexNumber = this.configVerticesBufferData(vertexDataArray, firstVerticesStart, lastVerticesEnd);\n            if (vertexNumber < 2) return;\n            this.gl.drawArrays(this.gl.LINE_STRIP, 0, vertexNumber);\n            this.DEBUG_DRAW_COUNT++;\n        }\n\n        // executeRenderAction(actionList, stateArray) {\n        //     let matrixIndex = 1; // 每次绘制都要重新设置矩阵的索引\n        //     let lastAction = undefined;\n        //     let vertexDataArray = [];\n        //     let matrixMap = {}; // 由状态id和状态内矩阵id组合成一个key，value是对应的矩阵索引值\n        //     let firstVerticesStart = 0;\n        //\n        //\n        //     for (let i = 0; i < actionList.length; i++) {\n        //         let currentAction = actionList[i];\n        //         if (lastAction == undefined) lastAction = currentAction;\n        //         if (currentAction.type == RenderAction.ACTION_STROKE) {\n        //             if (lastAction != currentAction && lastAction != undefined) {\n        //                 this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n        //             }\n        //             vertexDataArray = [];\n        //             vertexDataArray.push(currentAction.vertexData);\n        //             matrixIndex = 1;\n        //             matrixMap = {};\n        //             lastAction = currentAction;\n        //             for (let k = 0; k < currentAction.vertexData.vertexNumber; k++) {\n        //                 let mid = currentAction.vertexData.getMatrixIndex(k);\n        //                 let sid = currentAction.vertexData.getContextStateIndex(k);\n        //                 let key = sid.toString() + '-' + mid.toString();\n        //                 let currentMatrixIndex = matrixMap[key];\n        //                 if (currentMatrixIndex == undefined) {\n        //                     currentMatrixIndex = matrixIndex;\n        //                     if ((currentMatrixIndex + 1) > this.maxTransformMatrixNum) {\n        //                         //为了能让一个绘制动作顺利结束，只能自己计算坐标咯\n        //                         let m = stateArray[sid].matrixArray[mid];\n        //                         let vertex = currentAction.vertexData.dataBuffer.getVertex(k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n        //                         vertex = Mat4.multiplyWithVertex(m, vertex);\n        //                         currentAction.vertexData.dataBuffer.modifyVertex(vertex, k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n        //                         currentAction.vertexData.matrixIndexBuffer.put(0);\n        //                     } else {\n        //                         let m = stateArray[sid].matrixArray[mid];\n        //                         matrixMap[key] = currentMatrixIndex;\n        //                         this.setUniformTransformMatrix(m, currentMatrixIndex);\n        //                         currentAction.vertexData.matrixIndexBuffer.put(currentMatrixIndex);\n        //                         matrixIndex++;\n        //                     }\n        //                 } else {\n        //                     currentAction.vertexData.matrixIndexBuffer.put(currentMatrixIndex);\n        //                 }\n        //             }\n        //             this.rendVertexArray(currentAction.type, vertexDataArray);\n        //             matrixMap = {};\n        //             vertexDataArray = [];\n        //             matrixIndex = 1;\n        //             continue;\n        //         } else {\n        //             // 先收集顶点数据，顶点的矩阵在下一步再设置\n        //             if (currentAction.type == lastAction.type) { // 同个Fill绘制可以进行叠加统一绘制\n        //                 if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n        //                     this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n        //                     vertexDataArray = [];\n        //                     lastAction = currentAction;\n        //                     matrixIndex = 1;\n        //                     matrixMap = {};\n        //                 }\n        //                 if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n        //                     lastAction = currentAction;\n        //                 }\n        //                 vertexDataArray.push(currentAction.vertexData); // 叠加\n        //             } else {\n        //                 // 如果类型不一样，先绘制之前的类型，并且当前的index退回去\n        //                 this.rendVertexArray(lastAction.type, vertexDataArray);\n        //                 matrixIndex = 1;\n        //                 i--;\n        //                 lastAction = undefined;\n        //                 vertexDataArray = [];\n        //                 continue;\n        //             }\n        //         }\n        //\n        //         // 开始设置顶点的变换矩阵\n        //         for (let k = 0; k < currentAction.vertexData.vertexNumber; k++) {\n        //             let mid = currentAction.vertexData.getMatrixIndex(k);\n        //             let sid = currentAction.vertexData.getContextStateIndex(k);\n        //             let key = sid.toString() + '-' + mid.toString();\n        //             let currentMatrixIndex = matrixMap[key];\n        //             if (currentMatrixIndex == undefined) {\n        //                 currentMatrixIndex = matrixIndex;\n        //                 if ((currentMatrixIndex + 1) > this.maxTransformMatrixNum) {\n        //                     // 如果Index已经超过最大限制，就先绘制之前的\n        //                     if (k == 0) {\n        //                         vertexDataArray.pop();\n        //                         this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n        //                         matrixMap = {};\n        //                         matrixIndex = 1;\n        //                         vertexDataArray = [];\n        //                         lastAction = undefined;\n        //                         i--;\n        //                         break;\n        //                     } else {\n        //                         //为了能让一个绘制动作顺利结束，只能自己计算坐标咯\n        //                         let m = stateArray[sid].matrixArray[mid];\n        //                         let vertex = currentAction.vertexData.dataBuffer.getVertex(k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n        //                         vertex = Mat4.multiplyWithVertex(m, vertex);\n        //                         currentAction.vertexData.dataBuffer.modifyVertex(vertex, k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n        //                         currentAction.vertexData.matrixIndexBuffer.put(0);\n        //                     }\n        //                 } else {\n        //                     let m = stateArray[sid].matrixArray[mid];\n        //                     matrixMap[key] = currentMatrixIndex;\n        //                     this.setUniformTransformMatrix(m, currentMatrixIndex);\n        //                     currentAction.vertexData.matrixIndexBuffer.put(currentMatrixIndex);\n        //                     matrixIndex++;\n        //                 }\n        //             } else {\n        //                 currentAction.vertexData.matrixIndexBuffer.put(currentMatrixIndex);\n        //             }\n        //         }\n        //     }\n        //\n        //     if (vertexDataArray.length != 0 && lastAction != undefined) {\n        //         this.rendVertexArray(lastAction.type, vertexDataArray, firstVerticesStart, undefined, lastAction.textureIndex);\n        //     }\n        // }\n\n\n    }, {\n        key: \"executeRenderAction\",\n        value: function executeRenderAction(actionList, stateArray) {\n            var matrixIndex = 1; // 每次绘制都要重新设置矩阵的索引\n            var lastAction = undefined;\n            var vertexDataArray = [];\n            var matrixMap = {}; // 由状态id和状态内矩阵id组合成一个key，value是对应的矩阵索引值\n            var firstVerticesStart = 0;\n\n            for (var i = 0; i < actionList.length; i++) {\n                var currentAction = actionList[i];\n                if (lastAction == undefined) lastAction = currentAction;\n                if (currentAction.type == _RenderAction2.default.ACTION_STROKE) {\n                    if (lastAction != currentAction && lastAction != undefined) {\n                        if (lastAction.type != _RenderAction2.default.ACTION_STROKE) this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n                    }\n                    vertexDataArray = [];\n                    vertexDataArray.push(currentAction.vertexData);\n                    lastAction = currentAction;\n                    this.rendVertexArray(currentAction.type, vertexDataArray);\n                    vertexDataArray = [];\n                    continue;\n                } else {\n                    // 先收集顶点数据，顶点的矩阵在下一步再设置\n                    if (currentAction.type == lastAction.type) {\n                        // 同个Fill绘制可以进行叠加统一绘制\n                        if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                            this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n                            vertexDataArray = [];\n                            lastAction = currentAction;\n                        }\n                        if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n                            lastAction = currentAction;\n                        }\n                        vertexDataArray.push(currentAction.vertexData); // 叠加\n                    } else {\n                        // 如果类型不一样，先绘制之前的类型，并且当前的index退回去\n                        this.rendVertexArray(lastAction.type, vertexDataArray);\n                        i--;\n                        lastAction = undefined;\n                        continue;\n                    }\n                }\n            }\n\n            if (vertexDataArray.length != 0 && lastAction != undefined) {\n                this.rendVertexArray(lastAction.type, vertexDataArray, firstVerticesStart, undefined, lastAction.textureIndex);\n            }\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(x, y, z) {\n            this.lightPosition[0] = x;\n            this.lightPosition[1] = y;\n            this.lightPosition[2] = z;\n        }\n    }, {\n        key: \"configTexture\",\n        value: function configTexture(textureIndex) {\n            if (textureIndex == undefined) textureIndex = -1;\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.uniform1i(shaderInfo.textureLocation, 0);\n            var texture = void 0;\n            var c = void 0;\n            if (textureIndex == -1) {\n                texture = shaderInfo.blackTexture;\n                c = { width: 1, height: 1 };\n            } else {\n                texture = this.textureManager.textureArray[textureIndex];\n                c = this.textureManager.imageDataArray[textureIndex];\n            }\n            gl.uniform2f(shaderInfo.singleCanvas, c.width, c.height);\n            gl.activeTexture(gl.TEXTURE0 + 0);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n        }\n    }, {\n        key: \"prepareVertexDatas\",\n        value: function prepareVertexDatas(dataByteLength) {\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.enableVertexAttribArray(shaderInfo.vertexAttribute);\n            gl.enableVertexAttribArray(shaderInfo.colorAttribute);\n            gl.enableVertexAttribArray(shaderInfo.textureCoordAttribute);\n            // gl.enableVertexAttribArray(shaderInfo.transformMatrixIndex);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.verticesBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, dataByteLength, gl.DYNAMIC_DRAW);\n\n            // 设置如何从buffer中读出顶点\n            var floatByteSize = 4;\n\n            // 设置如何从buffer中读出顶点\n            var size = 3; // 这是表示这组数据由多少个数组element组成\n            var type = gl.FLOAT; // 给出数据的类型\n            var normalize = false; // 是否要标准化，比如gl.UNSIGN8BIT,就会变成[1-0】之间的数字\n            var stride = SINGLE_DATA_BYTE_LENGTH; // 读取的时候移动多少字节到达该类型数据的下一个，这个很关键，一般都是这个数据layout的单个组成所有数据的大小\n            // 比如现在，就是3个顶点坐标+2个贴图坐标+2个无用float，因为都设置成了float，再加上4位颜色 所以这个stride值就是 7*4+4 =32;\n            var offset = 0; // 读取的起始位置，和stride一样，移动的位置也是字节大小。顶点数据是在整个layout的开始，所以是0，而颜色数据在顶点之后，则是3*4\n            gl.vertexAttribPointer(shaderInfo.vertexAttribute, size, type, normalize, stride, offset);\n\n            // type = gl.FLOAT;\n            // size = 1;\n            // offset = 3 * floatByteSize;\n            // gl.vertexAttribPointer(shaderInfo.transformMatrixIndex, size, type, normalize, stride, offset);\n\n            type = gl.UNSIGNED_BYTE;\n            size = 4;\n            offset = 5 * floatByteSize; // 注意：这里要跳过两个无用的float类型数据\n            gl.vertexAttribPointer(shaderInfo.colorAttribute, size, type, normalize, stride, offset);\n\n            type = gl.FLOAT;\n            size = 2;\n            offset += 4;\n            gl.vertexAttribPointer(shaderInfo.textureCoordAttribute, size, type, normalize, stride, offset);\n        }\n    }, {\n        key: \"prepareMatrixIndexDatas\",\n        value: function prepareMatrixIndexDatas(length) {\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n\n            gl.enableVertexAttribArray(shaderInfo.transformMatrixIndex);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.matrixIndexBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, length, gl.DYNAMIC_DRAW);\n            var type = gl.FLOAT;\n            var size = 1;\n            var offset = 0;\n            var stripe = 4;\n            gl.vertexAttribPointer(shaderInfo.transformMatrixIndex, size, type, false, stripe, offset);\n        }\n    }, {\n        key: \"registerTexture\",\n        value: function registerTexture(image) {}\n    }, {\n        key: \"createShaderProgram\",\n        value: function createShaderProgram() {\n            var gl = this.gl;\n            var vertexShader = this.loadShader(gl.VERTEX_SHADER, this.getVertexShaderSource(this.maxTransformMatrixNum));\n            var fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);\n\n            // 创建Shader程序，一个是顶点shader一个是片段shader\n            var shaderProgram = gl.createProgram();\n            gl.attachShader(shaderProgram, vertexShader);\n            gl.attachShader(shaderProgram, fragmentShader);\n            gl.linkProgram(shaderProgram);\n\n            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n                console.error('无法初始化Program: ' + gl.getProgramInfoLog(shaderProgram));\n                gl.deleteProgram(shaderProgram);\n                return null;\n            }\n            gl.useProgram(shaderProgram);\n            return shaderProgram;\n        }\n    }, {\n        key: \"init\",\n        value: function init(projectionType, defaultDepth) {\n            var gl = this.gl;\n            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n            this.gl.enable(this.gl.BLEND);\n            this.gl.disable(this.gl.DEPTH_TEST);\n            this[_program] = this.createShaderProgram();\n            var program = this[_program];\n            this.shaderInformation = this.initShaderInformation(program);\n            this.textureManager = new _TextureManager2.default(801, 801, 10, 4);\n            // 设置透视矩阵\n            var m1 = void 0;\n            var near = 1;\n            if (projectionType == 0) {\n                m1 = _Mat2.default.orthoProjection(0, 0, gl.canvas.width, gl.canvas.height, near, Math.abs(defaultDepth * 2));\n            } else {\n                var theta = Math.atan2(gl.canvas.clientHeight / 2, Math.abs(defaultDepth));\n                m1 = _Mat2.default.perspective3(theta * 2, gl.canvas.clientWidth, gl.canvas.clientHeight, near, Math.abs(defaultDepth * 2));\n            }\n            gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m1);\n        }\n    }, {\n        key: \"setPerspective\",\n        value: function setPerspective(viewAngel, near, far) {\n            var aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight;\n            var m = _Mat2.default.perspective2(0, 0, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight, near, far);\n            m = _Mat2.default.perspective(viewAngel, aspect, near, far);\n            m = _Mat2.default.perspective3(viewAngel, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight, near, far);\n            this.gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m);\n        }\n    }, {\n        key: \"initShaderInformation\",\n        value: function initShaderInformation(program) {\n            var gl = this.gl;\n\n            var textureCoordAttribute = gl.getAttribLocation(program, \"u_texCoord\");\n            gl.enableVertexAttribArray(textureCoordAttribute);\n\n            var vertexAttribute = gl.getAttribLocation(program, \"a_position\");\n            gl.enableVertexAttribArray(vertexAttribute);\n\n            var transformMatrixIndex = gl.getAttribLocation(program, \"transform_matrix_index\");\n            gl.enableVertexAttribArray(transformMatrixIndex);\n\n            var colorAttribute = gl.getAttribLocation(program, 'color');\n            gl.enableVertexAttribArray(colorAttribute);\n\n            // 转化矩阵全局变量\n            var perspectiveMatrix = gl.getUniformLocation(program, \"perspective_matrix\");\n            var transformMatrixArray = new Array(this.maxTransformMatrixNum);\n            for (var i = 0; i < transformMatrixArray.length; i++) {\n                transformMatrixArray[i] = gl.getUniformLocation(program, \"transform_matrix_array[\" + i + \"]\");\n            }\n            var rawMatrix = _Mat2.default.identity();\n            // 为了配合预设的深度\n            // Mat4.translationMatrix(rawMatrix, 0, 0, -Math.max(gl.canvas.clientWidth, gl.canvas.clientHeight));\n            gl.uniformMatrix4fv(transformMatrixArray[0], false, rawMatrix);\n            var singleCanvas = gl.getUniformLocation(program, \"singleCanvas\");\n            var lightPosition = gl.getUniformLocation(program, \"u_lightPosition\");\n            var enableLight = gl.getUniformLocation(program, \"enableLight\");\n            var textureLocation = gl.getUniformLocation(program, \"u_texture\");\n            // 创建数据缓存\n            var verticesBuffer = gl.createBuffer();\n            var matrixIndexBuffer = gl.createBuffer();\n            var blackTexture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, blackTexture);\n            var blackPixel = new Uint8Array([255, 255, 255, 255]);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, blackPixel);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            return {\n                vertexAttribute: vertexAttribute,\n                colorAttribute: colorAttribute,\n                textureCoordAttribute: textureCoordAttribute,\n                verticesBuffer: verticesBuffer,\n                matrixIndexBuffer: matrixIndexBuffer,\n                perspectiveMatrix: perspectiveMatrix,\n                transformMatrixArray: transformMatrixArray,\n                transformMatrixIndex: transformMatrixIndex,\n                singleCanvas: singleCanvas,\n                textureLocation: textureLocation,\n                blackTexture: blackTexture,\n                lightPosition: lightPosition,\n                enableLight: enableLight,\n                webgl: gl\n            };\n        }\n\n        /**\r\n         * 创建作色器\r\n         * @param type 着色器类型\r\n         * @param source 代码源\r\n         * @returns {*} Shader对象\r\n         */\n\n    }, {\n        key: \"loadShader\",\n        value: function loadShader(type, source) {\n            var gl = this.gl;\n            var shader = gl.createShader(type);\n            // 把GLSL代码给shader\n            gl.shaderSource(shader, source);\n            // 编译着色器程序\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error('着色器编译错误: ' + gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        /**\r\n           这样我看得更清楚些\r\n           attribute vec4 color;\r\n         attribute vec4 a_position;\r\n         attribute vec2 u_texCoord;\r\n         attribute vec2 transform_matrix_index;\r\n         varying vec2 v_texcoord;\r\n         varying vec4 currentColor;\r\n         uniform mat4 texture_matrix;\r\n         uniform mat4 perspective_matrix;\r\n         uniform mat4 transform_matrix_array[transformMatrixCount];\r\n         void main() {\r\n                // v_texcoord = u_texCoord;\r\n                vec4 new_position = transform_matrix_array[0] * a_position;\r\n                vec4 finalPosition = perspective_matrix* new_position;\r\n                currentColor = vec4 (color.xyz/255.0,color.w/100.0);\r\n                gl_Position = finalPosition;\r\n        };\r\n           * @param transformMatrixCount\r\n         * @returns {string}\r\n         */\n\n    }, {\n        key: \"getVertexShaderSource\",\n        value: function getVertexShaderSource(transformMatrixCount) {\n            var vsSource = ' attribute vec4 color;\\n' + '     attribute vec4 a_position;\\n' + '     attribute vec2 u_texCoord;\\n' + '     varying vec3 v_position;\\n' + '     attribute float transform_matrix_index;\\n' + '     varying vec2 v_texcoord;\\n' + '     varying vec4 currentColor;\\n' + '     varying vec3 normal;\\n' + '     uniform mat4 perspective_matrix;\\n' + '     uniform mat4 transform_matrix_array[' + transformMatrixCount + '];\\n' + '     void main() {\\n' + '             normal = vec3(0,0,1);\\n' + '             vec4 yuandian = vec4(0,0,0,1);\\n' + '             v_texcoord = u_texCoord;\\n' + '            vec4 new_position = transform_matrix_array[int(transform_matrix_index)] * a_position;\\n' + '            v_position = vec3(new_position.xyz);\\n' + '            vec4 n_y = transform_matrix_array[int(transform_matrix_index)] * yuandian;\\n' + '            vec4 n_n = transform_matrix_array[int(transform_matrix_index)] * vec4(normal,1);\\n' + '            normal = vec3(n_n.x-n_y.x,n_n.y-n_y.y,n_n.z-n_y.z);\\n' + '            vec4 finalPosition = perspective_matrix* new_position;\\n' + '            currentColor = vec4 (color.xyz/255.0,color.w/100.0);\\n' + '            gl_Position = finalPosition;\\n' + '    }';\n            return vsSource;\n        }\n    }, {\n        key: \"maxTransformMatrixNum\",\n        get: function get() {\n            return this[_maxTransformMatrixNum];\n        }\n    }]);\n\n    return WebGLRender;\n}();\n\nexports.default = WebGLRender;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/WebGLRender.js?");

/***/ }),

/***/ 0:
/*!*****************************************************************!*\
  !*** multi ./github/src/webgl/CanvasRenderingContextWebgl2D.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./github/src/webgl/CanvasRenderingContextWebgl2D.js */\"./github/src/webgl/CanvasRenderingContextWebgl2D.js\");\n\n\n//# sourceURL=webpack://tielifa.WebGL2D/multi_./github/src/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ })

/******/ })["default"];
});