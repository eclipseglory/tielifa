(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebGL2D"] = factory();
	else
		root["tielifa"] = root["tielifa"] || {}, root["tielifa"]["WebGL2D"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./github/src/geometry/EarClipping.js":
/*!********************************************!*\
  !*** ./github/src/geometry/EarClipping.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Node = __webpack_require__(/*! ./Node.js */ \"./github/src/geometry/Node.js\");\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EarClipping = function () {\n    function EarClipping() {\n        _classCallCheck(this, EarClipping);\n    }\n\n    _createClass(EarClipping, null, [{\n        key: 'earcut',\n        value: function earcut(data, holeIndices, dim) {\n\n            dim = dim || 2;\n\n            var hasHoles = holeIndices && holeIndices.length,\n                outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n                outerNode = this.linkedList(data, 0, outerLen, dim, true),\n                triangles = [];\n\n            if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n            var minX = void 0,\n                minY = void 0,\n                maxX = void 0,\n                maxY = void 0,\n                x = void 0,\n                y = void 0,\n                invSize = void 0;\n\n            if (hasHoles) outerNode = this.eliminateHoles(data, holeIndices, outerNode, dim);\n\n            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n            if (data.length > 80 * dim) {\n                minX = maxX = data[0];\n                minY = maxY = data[1];\n\n                for (var i = dim; i < outerLen; i += dim) {\n                    x = data[i];\n                    y = data[i + 1];\n                    if (x < minX) minX = x;\n                    if (y < minY) minY = y;\n                    if (x > maxX) maxX = x;\n                    if (y > maxY) maxY = y;\n                }\n\n                // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n                invSize = Math.max(maxX - minX, maxY - minY);\n                invSize = invSize !== 0 ? 1 / invSize : 0;\n            }\n\n            this.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n            return triangles;\n        }\n\n        // create a circular doubly linked list from polygon points in the specified winding order\n\n    }, {\n        key: 'linkedList',\n        value: function linkedList(data, start, end, dim, clockwise) {\n            var i, last;\n\n            if (clockwise === EarClipping.signedArea(data, start, end, dim) > 0) {\n                for (i = start; i < end; i += dim) {\n                    last = this.insertNode(i, data[i], data[i + 1], last);\n                }\n            } else {\n                for (i = end - dim; i >= start; i -= dim) {\n                    last = this.insertNode(i, data[i], data[i + 1], last);\n                }\n            }\n\n            if (last && EarClipping.equals(last, last.next)) {\n                this.removeNode(last);\n                last = last.next;\n            }\n\n            return last;\n        }\n\n        // eliminate colinear or duplicate points\n\n    }, {\n        key: 'filterPoints',\n        value: function filterPoints(start, end) {\n            if (!start) return start;\n            if (!end) end = start;\n\n            var p = start,\n                again;\n            do {\n                again = false;\n\n                if (!p.steiner && (EarClipping.equals(p, p.next) || EarClipping.area(p.prev, p, p.next) === 0)) {\n                    this.removeNode(p);\n                    p = end = p.prev;\n                    if (p === p.next) break;\n                    again = true;\n                } else {\n                    p = p.next;\n                }\n            } while (again || p !== end);\n\n            return end;\n        }\n\n        // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n    }, {\n        key: 'earcutLinked',\n        value: function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n            if (!ear) return;\n\n            // interlink polygon nodes in z-order\n            if (!pass && invSize) this.indexCurve(ear, minX, minY, invSize);\n\n            var stop = ear,\n                prev,\n                next;\n\n            // iterate through ears, slicing them one by one\n            while (ear.prev !== ear.next) {\n                prev = ear.prev;\n                next = ear.next;\n\n                if (invSize ? this.isEarHashed(ear, minX, minY, invSize) : this.isEar(ear)) {\n                    // cut off the triangle\n                    triangles.push(prev.i / dim);\n                    triangles.push(ear.i / dim);\n                    triangles.push(next.i / dim);\n\n                    this.removeNode(ear);\n\n                    // skipping the next vertex leads to less sliver triangles\n                    ear = next.next;\n                    stop = next.next;\n\n                    continue;\n                }\n\n                ear = next;\n\n                // if we looped through the whole remaining polygon and can't find any more ears\n                if (ear === stop) {\n                    // try filtering points and slicing again\n                    if (!pass) {\n                        this.earcutLinked(this.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                        // if this didn't work, try curing all small self-intersections locally\n                    } else if (pass === 1) {\n                        ear = this.cureLocalIntersections(ear, triangles, dim);\n                        this.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                        // as a last resort, try splitting the remaining polygon into two\n                    } else if (pass === 2) {\n                        this.splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // check whether a polygon node forms a valid ear with adjacent nodes\n\n    }, {\n        key: 'isEar',\n        value: function isEar(ear) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // now make sure we don't have other points inside the potential ear\n            var p = ear.next.next;\n\n            while (p !== ear.prev) {\n                if (this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.next;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'isEarHashed',\n        value: function isEarHashed(ear, minX, minY, invSize) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // triangle bbox; min & max are calculated like this for speed\n            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n                minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n                maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n                maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n\n            // z-order range for the current triangle bbox;\n            var minZ = this.zOrder(minTX, minTY, minX, minY, invSize),\n                maxZ = this.zOrder(maxTX, maxTY, minX, minY, invSize);\n\n            var p = ear.prevZ,\n                n = ear.nextZ;\n\n            // look for points inside the triangle in both directions\n            while (p && p.z >= minZ && n && n.z <= maxZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            // look for remaining points in decreasing z-order\n            while (p && p.z >= minZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n            }\n\n            // look for remaining points in increasing z-order\n            while (n && n.z <= maxZ) {\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            return true;\n        }\n\n        // go through all polygon nodes and cure small local self-intersections\n\n    }, {\n        key: 'cureLocalIntersections',\n        value: function cureLocalIntersections(start, triangles, dim) {\n            var p = start;\n            do {\n                var a = p.prev,\n                    b = p.next.next;\n\n                if (!EarClipping.equals(a, b) && this.intersects(a, p, p.next, b) && this.locallyInside(a, b) && this.locallyInside(b, a)) {\n\n                    triangles.push(a.i / dim);\n                    triangles.push(p.i / dim);\n                    triangles.push(b.i / dim);\n\n                    // remove two nodes involved\n                    this.removeNode(p);\n                    this.removeNode(p.next);\n\n                    p = start = b;\n                }\n                p = p.next;\n            } while (p !== start);\n\n            return p;\n        }\n\n        // try splitting polygon into two and triangulate them independently\n\n    }, {\n        key: 'splitEarcut',\n        value: function splitEarcut(start, triangles, dim, minX, minY, invSize) {\n            // look for a valid diagonal that divides the polygon into two\n            var a = start;\n            do {\n                var b = a.next.next;\n                while (b !== a.prev) {\n                    if (a.i !== b.i && this.isValidDiagonal(a, b)) {\n                        // split the polygon in two by the diagonal\n                        var c = this.splitPolygon(a, b);\n\n                        // filter colinear points around the cuts\n                        a = this.filterPoints(a, a.next);\n                        c = this.filterPoints(c, c.next);\n\n                        // run earcut on each half\n                        this.earcutLinked(a, triangles, dim, minX, minY, invSize);\n                        this.earcutLinked(c, triangles, dim, minX, minY, invSize);\n                        return;\n                    }\n                    b = b.next;\n                }\n                a = a.next;\n            } while (a !== start);\n        }\n\n        // link every hole into the outer loop, producing a single-ring polygon without holes\n\n    }, {\n        key: 'eliminateHoles',\n        value: function eliminateHoles(data, holeIndices, outerNode, dim) {\n            var queue = [],\n                i,\n                len,\n                start,\n                end,\n                list;\n\n            for (i = 0, len = holeIndices.length; i < len; i++) {\n                start = holeIndices[i] * dim;\n                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                list = this.linkedList(data, start, end, dim, false);\n                if (list === list.next) list.steiner = true;\n                queue.push(this.getLeftmost(list));\n            }\n\n            queue.sort(this.compareX);\n\n            // process holes from left to right\n            for (i = 0; i < queue.length; i++) {\n                this.eliminateHole(queue[i], outerNode);\n                outerNode = this.filterPoints(outerNode, outerNode.next);\n            }\n\n            return outerNode;\n        }\n    }, {\n        key: 'compareX',\n        value: function compareX(a, b) {\n            return a.x - b.x;\n        }\n\n        // find a bridge between vertices that connects hole with an outer ring and and link it\n\n    }, {\n        key: 'eliminateHole',\n        value: function eliminateHole(hole, outerNode) {\n            outerNode = this.findHoleBridge(hole, outerNode);\n            if (outerNode) {\n                var b = this.splitPolygon(outerNode, hole);\n                this.filterPoints(b, b.next);\n            }\n        }\n\n        // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n    }, {\n        key: 'findHoleBridge',\n        value: function findHoleBridge(hole, outerNode) {\n            var p = outerNode,\n                hx = hole.x,\n                hy = hole.y,\n                qx = -Infinity,\n                m;\n\n            // find a segment intersected by a ray from the hole's leftmost point to the left;\n            // segment's endpoint with lesser x will be potential connection point\n            do {\n                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                    if (x <= hx && x > qx) {\n                        qx = x;\n                        if (x === hx) {\n                            if (hy === p.y) return p;\n                            if (hy === p.next.y) return p.next;\n                        }\n                        m = p.x < p.next.x ? p : p.next;\n                    }\n                }\n                p = p.next;\n            } while (p !== outerNode);\n\n            if (!m) return null;\n\n            if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n            // look for points inside the triangle of hole point, segment intersection and endpoint;\n            // if there are no points found, we have a valid connection;\n            // otherwise choose the point of the minimum angle with the ray as connection point\n\n            var stop = m,\n                mx = m.x,\n                my = m.y,\n                tanMin = Infinity,\n                tan;\n\n            p = m.next;\n\n            while (p !== stop) {\n                if (hx >= p.x && p.x >= mx && hx !== p.x && this.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n                    tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                    if ((tan < tanMin || tan === tanMin && p.x > m.x) && this.locallyInside(p, hole)) {\n                        m = p;\n                        tanMin = tan;\n                    }\n                }\n\n                p = p.next;\n            }\n\n            return m;\n        }\n\n        // interlink polygon nodes in z-order\n\n    }, {\n        key: 'indexCurve',\n        value: function indexCurve(start, minX, minY, invSize) {\n            var p = start;\n            do {\n                if (p.z === null) p.z = this.zOrder(p.x, p.y, minX, minY, invSize);\n                p.prevZ = p.prev;\n                p.nextZ = p.next;\n                p = p.next;\n            } while (p !== start);\n\n            p.prevZ.nextZ = null;\n            p.prevZ = null;\n\n            this.sortLinked(p);\n        }\n\n        // Simon Tatham's linked list merge sort algorithm\n        // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n    }, {\n        key: 'sortLinked',\n        value: function sortLinked(list) {\n            var i,\n                p,\n                q,\n                e,\n                tail,\n                numMerges,\n                pSize,\n                qSize,\n                inSize = 1;\n\n            do {\n                p = list;\n                list = null;\n                tail = null;\n                numMerges = 0;\n\n                while (p) {\n                    numMerges++;\n                    q = p;\n                    pSize = 0;\n                    for (i = 0; i < inSize; i++) {\n                        pSize++;\n                        q = q.nextZ;\n                        if (!q) break;\n                    }\n                    qSize = inSize;\n\n                    while (pSize > 0 || qSize > 0 && q) {\n\n                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                            e = p;\n                            p = p.nextZ;\n                            pSize--;\n                        } else {\n                            e = q;\n                            q = q.nextZ;\n                            qSize--;\n                        }\n\n                        if (tail) tail.nextZ = e;else list = e;\n\n                        e.prevZ = tail;\n                        tail = e;\n                    }\n\n                    p = q;\n                }\n\n                tail.nextZ = null;\n                inSize *= 2;\n            } while (numMerges > 1);\n\n            return list;\n        }\n\n        // z-order of a point given coords and inverse of the longer side of data bbox\n\n    }, {\n        key: 'zOrder',\n        value: function zOrder(x, y, minX, minY, invSize) {\n            // coords are transformed into non-negative 15-bit integer range\n            x = 32767 * (x - minX) * invSize;\n            y = 32767 * (y - minY) * invSize;\n\n            x = (x | x << 8) & 0x00FF00FF;\n            x = (x | x << 4) & 0x0F0F0F0F;\n            x = (x | x << 2) & 0x33333333;\n            x = (x | x << 1) & 0x55555555;\n\n            y = (y | y << 8) & 0x00FF00FF;\n            y = (y | y << 4) & 0x0F0F0F0F;\n            y = (y | y << 2) & 0x33333333;\n            y = (y | y << 1) & 0x55555555;\n\n            return x | y << 1;\n        }\n\n        // find the leftmost node of a polygon ring\n\n    }, {\n        key: 'getLeftmost',\n        value: function getLeftmost(start) {\n            var p = start,\n                leftmost = start;\n            do {\n                if (p.x < leftmost.x) leftmost = p;\n                p = p.next;\n            } while (p !== start);\n\n            return leftmost;\n        }\n\n        // check if a point lies within a convex triangle\n\n    }, {\n        key: 'pointInTriangle',\n        value: function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n        }\n\n        // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n    }, {\n        key: 'isValidDiagonal',\n        value: function isValidDiagonal(a, b) {\n            return a.next.i !== b.i && a.prev.i !== b.i && !this.intersectsPolygon(a, b) && this.locallyInside(a, b) && this.locallyInside(b, a) && this.middleInside(a, b);\n        }\n\n        // signed area of a triangle\n\n    }, {\n        key: 'area',\n        value: function area(p, q, r) {\n            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        }\n\n        // check if two points are equal\n\n    }, {\n        key: 'equals',\n        value: function equals(p1, p2) {\n            return p1.x === p2.x && p1.y === p2.y;\n        }\n\n        // check if two segments intersect\n\n    }, {\n        key: 'intersects',\n        value: function intersects(p1, q1, p2, q2) {\n            if (EarClipping.equals(p1, q1) && EarClipping.equals(p2, q2) || EarClipping.equals(p1, q2) && EarClipping.equals(p2, q1)) return true;\n            return EarClipping.area(p1, q1, p2) > 0 !== EarClipping.area(p1, q1, q2) > 0 && EarClipping.area(p2, q2, p1) > 0 !== EarClipping.area(p2, q2, q1) > 0;\n        }\n\n        // check if a polygon diagonal intersects any polygon segments\n\n    }, {\n        key: 'intersectsPolygon',\n        value: function intersectsPolygon(a, b) {\n            var p = a;\n            do {\n                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && this.intersects(p, p.next, a, b)) return true;\n                p = p.next;\n            } while (p !== a);\n\n            return false;\n        }\n\n        // check if a polygon diagonal is locally inside the polygon\n\n    }, {\n        key: 'locallyInside',\n        value: function locallyInside(a, b) {\n            return EarClipping.area(a.prev, a, a.next) < 0 ? EarClipping.area(a, b, a.next) >= 0 && EarClipping.area(a, a.prev, b) >= 0 : EarClipping.area(a, b, a.prev) < 0 || EarClipping.area(a, a.next, b) < 0;\n        }\n\n        // check if the middle point of a polygon diagonal is inside the polygon\n\n    }, {\n        key: 'middleInside',\n        value: function middleInside(a, b) {\n            var p = a,\n                inside = false,\n                px = (a.x + b.x) / 2,\n                py = (a.y + b.y) / 2;\n            do {\n                if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n                p = p.next;\n            } while (p !== a);\n\n            return inside;\n        }\n\n        // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n        // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n    }, {\n        key: 'splitPolygon',\n        value: function splitPolygon(a, b) {\n            var a2 = new _Node2.default(a.i, a.x, a.y),\n                b2 = new _Node2.default(b.i, b.x, b.y),\n                an = a.next,\n                bp = b.prev;\n\n            a.next = b;\n            b.prev = a;\n\n            a2.next = an;\n            an.prev = a2;\n\n            b2.next = a2;\n            a2.prev = b2;\n\n            bp.next = b2;\n            b2.prev = bp;\n\n            return b2;\n        }\n\n        // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n    }, {\n        key: 'insertNode',\n        value: function insertNode(i, x, y, last) {\n            var p = new _Node2.default(i, x, y);\n\n            if (!last) {\n                p.prev = p;\n                p.next = p;\n            } else {\n                p.next = last.next;\n                p.prev = last;\n                last.next.prev = p;\n                last.next = p;\n            }\n            return p;\n        }\n    }, {\n        key: 'removeNode',\n        value: function removeNode(p) {\n            p.next.prev = p.prev;\n            p.prev.next = p.next;\n\n            if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n            if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n        }\n    }, {\n        key: 'signedArea',\n        value: function signedArea(data, start, end, dim) {\n            var sum = 0;\n            for (var i = start, j = end - dim; i < end; i += dim) {\n                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n                j = i;\n            }\n            return sum;\n        }\n\n        // return a percentage difference between the polygon area and its triangulation area;\n        // used to verify correctness of triangulation\n\n    }, {\n        key: 'deviation',\n        value: function deviation(data, holeIndices, dim, triangles) {\n            var hasHoles = holeIndices && holeIndices.length;\n            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n            var polygonArea = Math.abs(this.signedArea(data, 0, outerLen, dim));\n            if (hasHoles) {\n                for (var i = 0, len = holeIndices.length; i < len; i++) {\n                    var start = holeIndices[i] * dim;\n                    var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                    polygonArea -= Math.abs(this.signedArea(data, start, end, dim));\n                }\n            }\n\n            var trianglesArea = 0;\n            for (i = 0; i < triangles.length; i += 3) {\n                var a = triangles[i] * dim;\n                var b = triangles[i + 1] * dim;\n                var c = triangles[i + 2] * dim;\n                trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n            }\n\n            return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n        }\n    }, {\n        key: 'flatten',\n\n\n        // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form EarClipping accepts\n        value: function flatten(data) {\n            var dim = data[0][0].length,\n                result = { vertices: [], holes: [], dimensions: dim },\n                holeIndex = 0;\n\n            for (var i = 0; i < data.length; i++) {\n                for (var j = 0; j < data[i].length; j++) {\n                    for (var d = 0; d < dim; d++) {\n                        result.vertices.push(data[i][j][d]);\n                    }\n                }\n                if (i > 0) {\n                    holeIndex += data[i - 1].length;\n                    result.holes.push(holeIndex);\n                }\n            }\n            return result;\n        }\n    }]);\n\n    return EarClipping;\n}();\n\nexports.default = EarClipping;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/geometry/EarClipping.js?");

/***/ }),

/***/ "./github/src/geometry/LineToRectangle.js":
/*!************************************************!*\
  !*** ./github/src/geometry/LineToRectangle.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _MathTools = __webpack_require__(/*! ../math/MathTools.js */ \"./github/src/math/MathTools.js\");\n\nvar _MathTools2 = _interopRequireDefault(_MathTools);\n\nvar _Vector = __webpack_require__(/*! ../math/Vector3.js */ \"./github/src/math/Vector3.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar LEFT_90_RADIAN = -Math.PI / 2;\n\nvar LineToRectangle = function () {\n    function LineToRectangle(lineWidth) {\n        _classCallCheck(this, LineToRectangle);\n\n        this.dim = 3;\n        this.points = null;\n        this.isClosed = false;\n        this.lineWidth = lineWidth || 1;\n        this.faceDirection = _Vector2.default.TEMP_VECTORS[3];\n        this.faceDirection.z = 1;\n    }\n\n    _createClass(LineToRectangle, [{\n        key: \"generatePoints\",\n        value: function generatePoints() {\n            if (this.points == null || this.points.length / this.dim < 2) return [];\n            var pointsCount = this.points.length / this.dim;\n            var preRectLastPoints = { r1: null, r2: null, r3: null, r4: null };\n            var rectPoints = [];\n            var lineCount = pointsCount - 1;\n            var that = this;\n            //不确定设定的面朝向法向量是否是单位向量：\n            _Vector2.default.normalize(this.faceDirection, this.faceDirection);\n            if (this.isClosed) lineCount++;\n            for (var i = 0; i < lineCount; i++) {\n                var index = i * this.dim;\n                var x1 = this.points[index];\n                var y1 = this.points[index + 1];\n                var pv1 = { x: x1, y: y1, z: 0 };\n                if (this.dim == 3) {\n                    pv1.z = this.points[index + 2];\n                }\n\n                var nextIndex = (i + 1) * this.dim;\n                if (nextIndex >= this.points.length) nextIndex = 0;\n                var x2 = this.points[nextIndex];\n                var y2 = this.points[nextIndex + 1];\n                var pv2 = { x: x2, y: y2, z: 0 };\n                if (this.dim == 3) {\n                    pv2.z = this.points[nextIndex + 2];\n                }\n\n                var lv = { x: x2 - x1, y: y2 - y1, z: pv2.z - pv1.z };\n\n                var r1 = { x: 0, y: 0, z: 0 };\n                var r2 = { x: 0, y: 0, z: 0 };\n                var r3 = { x: 0, y: 0, z: 0 };\n                var r4 = { x: 0, y: 0, z: 0 };\n                var temp = _Vector2.default.TEMP_VECTORS[0];\n                _Vector2.default.cross(temp, lv, this.faceDirection);\n                _Vector2.default.normalize(temp, temp);\n                _Vector2.default.multiplyValue(temp, temp, this.lineWidth / 2);\n                _Vector2.default.plus(r1, temp, pv1);\n                _Vector2.default.plus(r2, temp, pv2);\n                // 反向\n                temp.x = -temp.x;\n                temp.y = -temp.y;\n                temp.z = -temp.z;\n                _Vector2.default.plus(r3, temp, pv2);\n                _Vector2.default.plus(r4, temp, pv1);\n\n                var lastR1 = preRectLastPoints.r1;\n                var lastR4 = preRectLastPoints.r4;\n                var lastR2 = preRectLastPoints.r2;\n                var lastR3 = preRectLastPoints.r3;\n                if (lastR1 != null) {\n                    updateConnectPoints(lastR1, lastR2, lastR3, lastR4, r1, r2, r3, r4, i, lv);\n                }\n\n                //组织三角形\n                addPoint(r1);\n                addPoint(r2);\n                addPoint(r3);\n\n                addPoint(r3);\n                addPoint(r4);\n                addPoint(r1);\n\n                preRectLastPoints.r1 = r1;\n                preRectLastPoints.r2 = r2;\n                preRectLastPoints.r3 = r3;\n                preRectLastPoints.r4 = r4;\n            }\n\n            if (this.isClosed) {\n                //开始和结尾的地方连接点要改一下\n                var endIndex = rectPoints.length / this.dim;\n                var _r = getPoint(0);\n                var _r2 = getPoint(1);\n                var lr1 = getPoint(endIndex - 1);\n                var lr2 = getPoint(endIndex - 5);\n\n                var _r3 = getPoint(4);\n                var lr3 = getPoint(endIndex - 3);\n                var lr4 = getPoint(endIndex - 2);\n\n                var _temp = _Vector2.default.TEMP_VECTORS[0];\n                _temp.x = lr2.x - lr1.x;\n                _temp.y = lr2.y - lr1.y;\n                _temp.z = lr2.z - lr1.z;\n                var u1 = { x: 0, y: 0, z: 0 };\n                _Vector2.default.normalize(u1, _temp);\n                var temp1 = _Vector2.default.TEMP_VECTORS[1];\n                temp1.x = _r.x - _r2.x;\n                temp1.y = _r.y - _r2.y;\n                temp1.z = _r.z - _r2.z;\n                var n = { x: 0, y: 0, z: 0 };\n                _Vector2.default.cross(_temp, temp1, that.faceDirection);\n                _Vector2.default.normalize(n, _temp);\n                var p1 = _MathTools2.default.calculateIntersectionOfPlane(n, u1, lr2, _r2);\n                if (p1 != undefined) {\n                    setPointValue(p1.x, p1.y, p1.z, 0);\n                    setPointValue(p1.x, p1.y, p1.z, 5);\n                    setPointValue(p1.x, p1.y, p1.z, endIndex - 5);\n                }\n                _temp.x = lr3.x - lr4.x;\n                _temp.y = lr3.y - lr4.y;\n                _temp.z = lr3.z - lr4.z;\n                _Vector2.default.normalize(u1, _temp);\n\n                var p2 = _MathTools2.default.calculateIntersectionOfPlane(n, u1, lr3, _r3);\n                if (p2 != undefined) {\n                    setPointValue(p2.x, p2.y, p2.z, 4);\n                    setPointValue(p2.x, p2.y, p2.z, endIndex - 3);\n                    setPointValue(p2.x, p2.y, p2.z, endIndex - 4);\n                }\n            }\n\n            function updateConnectPoints(lastR1, lastR2, lastR3, lastR4, r1, r2, r3, r4, lineIndex, lineDirection) {\n                var temp = _Vector2.default.TEMP_VECTORS[0];\n                temp.x = lastR2.x - lastR1.x;\n                temp.y = lastR2.y - lastR1.y;\n                temp.z = lastR2.z - lastR1.z;\n                var u1 = { x: 0, y: 0, z: 0 };\n                _Vector2.default.normalize(u1, temp);\n                var n = { x: 0, y: 0, z: 0 };\n                _Vector2.default.cross(temp, lineDirection, that.faceDirection);\n                _Vector2.default.normalize(n, temp);\n                var p1 = _MathTools2.default.calculateIntersectionOfPlane(n, u1, lastR2, r2);\n                if (p1 != undefined) {\n                    //更新上个矩形r2和这个矩形的r1\n                    r1.x = p1.x;\n                    r1.y = p1.y;\n                    r1.z = p1.z;\n                }\n                temp.x = lastR3.x - lastR4.x;\n                temp.y = lastR3.y - lastR4.y;\n                temp.z = lastR3.z - lastR4.z;\n                _Vector2.default.normalize(u1, temp);\n                var p2 = _MathTools2.default.calculateIntersectionOfPlane(n, u1, lastR3, r4);\n                if (p2 != undefined) {\n                    //更新上个矩形r3和这个矩形的r4\n                    r4.x = p2.x;\n                    r4.y = p2.y;\n                    r4.z = p2.z;\n                }\n                updateRectPoint(p1, p2, lineIndex - 1);\n            }\n\n            function updateRectPoint(p, p1, index) {\n                index = index * 6 * that.dim;\n                var r2Index = index + that.dim;\n                var r3Index = r2Index + that.dim;\n                if (p != undefined) {\n                    rectPoints[r2Index] = p.x;\n                    rectPoints[r2Index + 1] = p.y;\n                    rectPoints[r2Index + 2] = p.z;\n                }\n                if (p1 != undefined) {\n                    rectPoints[r3Index] = p1.x;\n                    rectPoints[r3Index + 1] = p1.y;\n                    rectPoints[r3Index + 2] = p1.z;\n                    r3Index += that.dim;\n                    rectPoints[r3Index] = p1.x;\n                    rectPoints[r3Index + 1] = p1.y;\n                    rectPoints[r3Index + 2] = p1.z;\n                }\n            }\n\n            function addPoint(point) {\n\n                rectPoints.push(point.x);\n                rectPoints.push(point.y);\n                if (that.dim == 3) rectPoints.push(point.z);\n            }\n\n            function setPointValue(x, y, z, index) {\n                index = index * that.dim;\n                rectPoints[index] = x;\n                rectPoints[index + 1] = y;\n                if (that.dim == 3 && z != undefined) {\n                    rectPoints[index + 2] = z;\n                }\n            }\n\n            function getPoint(index) {\n                index = index * that.dim;\n                if (that.dim == 2) {\n                    return { x: rectPoints[index], y: rectPoints[index + 1] };\n                }\n                if (that.dim == 3) {\n                    return { x: rectPoints[index], y: rectPoints[index + 1], z: rectPoints[index + 2] };\n                }\n            }\n\n            return rectPoints;\n        }\n    }]);\n\n    return LineToRectangle;\n}();\n\nexports.default = LineToRectangle;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/geometry/LineToRectangle.js?");

/***/ }),

/***/ "./github/src/geometry/Node.js":
/*!*************************************!*\
  !*** ./github/src/geometry/Node.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function Node(i, x, y) {\n        _classCallCheck(this, Node);\n\n        // vertex index in coordinates array\n        this.i = i;\n\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n\n        // previous and next vertex nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n\n        // z-order curve value\n        this.z = null;\n\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n\n        // indicates whether this is a steiner point\n        this.steiner = false;\n};\n\nexports.default = Node;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/geometry/Node.js?");

/***/ }),

/***/ "./github/src/math/Mat4.js":
/*!*********************************!*\
  !*** ./github/src/math/Mat4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp_mat4 = undefined;\n\nvar Mat4 = function () {\n    function Mat4() {\n        _classCallCheck(this, Mat4);\n    }\n\n    _createClass(Mat4, null, [{\n        key: \"perspective2\",\n        value: function perspective2(left, top, right, bottom, near, far) {\n            return [2 * near / (right - left), 0, 0, 0, 0, 2 * near / (top - bottom), 0, 0, (right + left) / (right - left), (bottom + top) / (top - bottom), (-near - far) / (far - near), -1, 0, 0, -near * far * 2 / (far - near), 0];\n        }\n    }, {\n        key: \"perspective3\",\n        value: function perspective3(fieldOfViewInRadians, width, height, near, far) {\n            var m = this.perspective(fieldOfViewInRadians, width / height, near, far);\n            var m1 = Mat4.TEMP_MAT4[0];\n            Mat4.translationMatrix(m1, -width / 2, -height / 2, 0);\n            Mat4.multiply(m, m, m1);\n            return m;\n        }\n    }, {\n        key: \"perspective\",\n        value: function perspective(fieldOfViewInRadians, aspect, near, far) {\n            var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\n            if (_Tools2.default.equals(f, 1)) f = 1;\n            var rangeInv = 1.0 / (near - far);\n            var m = this.identity();\n            m[0] = f / aspect;\n            m[5] = -f;\n            m[10] = (near + far) * rangeInv;\n            m[11] = -1;\n            m[14] = near * far * rangeInv * 2;\n\n            // return [\n            //     f / aspect, 0, 0, 0,\n            //     0, f, 0, 0,\n            //     0, 0, (near + far) * rangeInv, -1,\n            //     0, 0, near * far * rangeInv * 2, 0\n            // ];\n            return m;\n        }\n    }, {\n        key: \"orthoProjection\",\n        value: function orthoProjection(left, top, right, bottom, near, far) {\n            return new Float32Array([2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, 2 / (near - far), 0, (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1]);\n        }\n    }, {\n        key: \"copy\",\n        value: function copy(from, to) {\n            to[0] = from[0];\n            to[1] = from[1];\n            to[2] = from[2];\n            to[3] = from[3];\n            to[4] = from[4];\n            to[5] = from[5];\n            to[6] = from[6];\n            to[7] = from[7];\n            to[8] = from[8];\n            to[9] = from[9];\n            to[10] = from[10];\n            to[11] = from[11];\n            to[12] = from[12];\n            to[13] = from[13];\n            to[14] = from[14];\n            to[15] = from[15];\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(a, b) {\n            var a0 = a[0],\n                a1 = a[1],\n                a2 = a[2],\n                a3 = a[3];\n            var a4 = a[4],\n                a5 = a[5],\n                a6 = a[6],\n                a7 = a[7];\n            var a8 = a[8],\n                a9 = a[9],\n                a10 = a[10],\n                a11 = a[11];\n            var a12 = a[12],\n                a13 = a[13],\n                a14 = a[14],\n                a15 = a[15];\n\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            var b4 = b[4],\n                b5 = b[5],\n                b6 = b[6],\n                b7 = b[7];\n            var b8 = b[8],\n                b9 = b[9],\n                b10 = b[10],\n                b11 = b[11];\n            var b12 = b[12],\n                b13 = b[13],\n                b14 = b[14],\n                b15 = b[15];\n\n            return Math.abs(a0 - b0) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _Tools2.default.EPSILON.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n        }\n    }, {\n        key: \"exactEquals\",\n        value: function exactEquals(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n        }\n    }, {\n        key: \"projection\",\n        value: function projection(width, height, depth) {\n            var m = this.identity();\n            m[0] = 2 / width;\n            m[5] = -2 / height;\n            m[10] = 2 / depth;\n            m[12] = -1;\n            m[13] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identity\",\n        value: function identity() {\n            var m = new Float32Array(16);\n            m[0] = 1;\n            m[5] = 1;\n            m[10] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identityMatrix\",\n        value: function identityMatrix(matrix) {\n            var m = matrix;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translationMatrix\",\n        value: function translationMatrix(out, tx, ty, tz) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translation\",\n        value: function translation(tx, ty, tz) {\n            var m = this.identity();\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            return m;\n        }\n    }, {\n        key: \"rotationZMatrix\",\n        value: function rotationZMatrix(out, radian) {\n            var m = out;\n            m[2] = 0;\n            m[3] = 0;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n        }\n    }, {\n        key: \"rotationZ\",\n        value: function rotationZ(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationXMatrix\",\n        value: function rotationXMatrix(out, radian) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationX\",\n        value: function rotationX(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationYMatrix\",\n        value: function rotationYMatrix(out, radian) {\n            var m = out;\n            m[1] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[9] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationY\",\n        value: function rotationY(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"scalingMatrix\",\n        value: function scalingMatrix(out, sx, sy, sz) {\n            var m = out;\n            m[0] = sx;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = sy;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = sz;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"scaling\",\n        value: function scaling(sx, sy, sz) {\n            var m = this.identity();\n            m[0] = sx;\n            m[5] = sy;\n            m[10] = sz;\n            return m;\n        }\n    }, {\n        key: \"multiplyWithVertex\",\n        value: function multiplyWithVertex(matrix, vertex) {\n            var a00 = matrix[0];\n            var a01 = matrix[1];\n            var a02 = matrix[2];\n            var a03 = matrix[3];\n            var a10 = matrix[4];\n            var a11 = matrix[5];\n            var a12 = matrix[6];\n            var a13 = matrix[7];\n            var a20 = matrix[8];\n            var a21 = matrix[9];\n            var a22 = matrix[10];\n            var a23 = matrix[11];\n            var a30 = matrix[12];\n            var a31 = matrix[13];\n            var a32 = matrix[14];\n            var a33 = matrix[15];\n\n            var b00 = vertex[0];\n            var b01 = vertex[1];\n            var b02 = vertex[2];\n            var b03 = vertex[3];\n            if (b02 == undefined) b02 = 0;\n            if (b03 == undefined) b03 = 1;\n\n            return [b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33];\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(out, a, b) {\n            var a00 = a[0],\n                a01 = a[1],\n                a02 = a[2],\n                a03 = a[3];\n            var a10 = a[4],\n                a11 = a[5],\n                a12 = a[6],\n                a13 = a[7];\n            var a20 = a[8],\n                a21 = a[9],\n                a22 = a[10],\n                a23 = a[11];\n            var a30 = a[12],\n                a31 = a[13],\n                a32 = a[14],\n                a33 = a[15];\n\n            // Cache only the current line of the second matrix\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[4];\n            b1 = b[5];\n            b2 = b[6];\n            b3 = b[7];\n            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[8];\n            b1 = b[9];\n            b2 = b[10];\n            b3 = b[11];\n            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[12];\n            b1 = b[13];\n            b2 = b[14];\n            b3 = b[15];\n            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            return out;\n        }\n    }, {\n        key: \"TEMP_MAT4\",\n        get: function get() {\n            if (temp_mat4 == undefined) {\n                temp_mat4 = [Mat4.identity(), Mat4.identity(), Mat4.identity(), Mat4.identity()];\n            }\n            return temp_mat4;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return _Tools2.default.EPSILON;\n        }\n    }]);\n\n    return Mat4;\n}();\n\nexports.default = Mat4;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/math/Mat4.js?");

/***/ }),

/***/ "./github/src/math/MathTools.js":
/*!**************************************!*\
  !*** ./github/src/math/MathTools.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ./Vector3.js */ \"./github/src/math/Vector3.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MathTools = function () {\n    function MathTools() {\n        _classCallCheck(this, MathTools);\n    }\n\n    /**\r\n     * 计算方法来自：http://geomalgorithms.com/a05-_intersect-1.html\r\n     * @param n 面的法向量（单位向量）\r\n     * @param u 线的向量 （单位向量）\r\n     * @param p 线上某点\r\n     * @param v 面上某点\r\n     * @returns {*}\r\n     */\n\n\n    _createClass(MathTools, null, [{\n        key: 'calculateIntersectionOfPlane',\n        value: function calculateIntersectionOfPlane(n, u, p, v) {\n            var down = _Vector2.default.dot(n, u);\n            if (down == 0) return null;\n            var w = { x: v.x - p.x, y: v.y - p.y, z: v.z - p.z };\n            var length = _Vector2.default.dot(w, n) / down;\n            var result = { x: 0, y: 0, z: 0 };\n            _Vector2.default.multiplyValue(result, u, length);\n            _Vector2.default.plus(result, result, p);\n            return result;\n        }\n    }, {\n        key: 'calculateIntersectionOfTowLines',\n        value: function calculateIntersectionOfTowLines(p1, p2, p3, p4) {\n            var x1 = p1.x;\n            var y1 = p1.y;\n\n            var x2 = p2.x;\n            var y2 = p2.y;\n\n            var x3 = p3.x;\n            var y3 = p3.y;\n\n            var x4 = p4.x;\n            var y4 = p4.y;\n\n            var share = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n            if (share == 0) return undefined;\n            var px = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n            px = px / share;\n\n            var py = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n            py = py / share;\n\n            return { x: px, y: py };\n        }\n    }, {\n        key: 'calculateLineFunctionConstant',\n        value: function calculateLineFunctionConstant(point1, point2) {\n            var deltaX = point1.x - point2.x;\n            var deltaY = point1.y - point2.y;\n\n            var x1 = point1.x;\n            var y1 = point1.y;\n            var x2 = point2.x;\n            var y2 = point2.y;\n\n            // if (deltaY < 0) {\n            //     let x = x1;\n            //     x1 = x2;\n            //     x2 = x;\n            //     let y = y1;\n            //     y1 = y2;\n            //     y2 = y;\n            // }\n            // 根据直线方程 kx+b=y 计算 k和b的值\n            var b = 0;\n            var k = 0;\n            if (deltaX == 0) {\n                return { k: undefined, b: -x1 };\n            }\n            if (deltaY == 0) {\n                return { k: 0, b: y1 };\n            }\n            if (deltaX != 0 && deltaY != 0) {\n                b = (y2 * x1 - y1 * x2) / (x1 - x2);\n                if (x2 != 0) {\n                    k = (y2 - b) / x2;\n                } else {\n                    k = (y1 - b) / x1;\n                }\n            }\n            return { 'b': b, 'k': k };\n        }\n    }]);\n\n    return MathTools;\n}();\n\nexports.default = MathTools;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/math/MathTools.js?");

/***/ }),

/***/ "./github/src/math/Vector3.js":
/*!************************************!*\
  !*** ./github/src/math/Vector3.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp = undefined;\n\nvar Vector3 = function () {\n    function Vector3(x, y, z) {\n        _classCallCheck(this, Vector3);\n\n        this.value = [0, 0, 0];\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n    }\n\n    _createClass(Vector3, [{\n        key: \"x\",\n        get: function get() {\n            return this.value[0];\n        },\n        set: function set(v) {\n            this.value[0] = v;\n        }\n    }, {\n        key: \"y\",\n        get: function get() {\n            return this.value[1];\n        },\n        set: function set(v) {\n            this.value[1] = v;\n        }\n    }, {\n        key: \"z\",\n        get: function get() {\n            return this.value[2];\n        },\n        set: function set(v) {\n            this.value[2] = v;\n        }\n    }, {\n        key: \"magnitude\",\n        get: function get() {\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        }\n    }], [{\n        key: \"dot\",\n        value: function dot(v1, v2) {\n            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n        }\n    }, {\n        key: \"normalize\",\n        value: function normalize(out, v) {\n            var length = v.magnitude;\n            if (length == 0) {\n                out.x = 0;\n                out.y = 0;\n                out.z = 0;\n            } else {\n                out.x = v.x / length;\n                out.y = v.y / length;\n                out.z = v.z / length;\n            }\n        }\n    }, {\n        key: \"plus\",\n        value: function plus(out, v1, v2) {\n            out.x = v1.x + v2.x;\n            out.y = v1.y + v2.y;\n            out.z = v1.z + v2.z;\n            return out;\n        }\n    }, {\n        key: \"multiplyValue\",\n        value: function multiplyValue(out, v, value) {\n            out.x = v.x * value;\n            out.y = v.y * value;\n            out.z = v.z * value;\n            return out;\n        }\n    }, {\n        key: \"cross\",\n        value: function cross(out, v1, v) {\n            out.x = v1.y * v.z - v1.z * v.y;\n            out.y = v1.z * v.x - v1.x * v.z;\n            out.z = v1.x * v.y - v1.y * v.x;\n            return out;\n        }\n    }, {\n        key: \"TEMP_VECTORS\",\n        get: function get() {\n            if (temp == undefined) {\n                temp = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n            }\n            return temp;\n        }\n    }]);\n\n    return Vector3;\n}();\n\nexports.default = Vector3;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/math/Vector3.js?");

/***/ }),

/***/ "./github/src/utils/Color.js":
/*!***********************************!*\
  !*** ./github/src/utils/Color.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _W3Color = __webpack_require__(/*! ./W3Color.js */ \"./github/src/utils/W3Color.js\");\n\nvar _W3Color2 = _interopRequireDefault(_W3Color);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _instance = void 0;\n\nvar Color = function () {\n    function Color() {\n        _classCallCheck(this, Color);\n\n        if (_instance) {\n            return _instance;\n        }\n        _instance = this;\n        this.colorMap = {};\n    }\n\n    _createClass(Color, [{\n        key: 'convertStringToColor',\n        value: function convertStringToColor(string) {\n            var vec3 = this.colorMap[string];\n            if (vec3 != undefined) return vec3;\n            string = string.toLowerCase();\n            if (Color.isRGBAString(string)) {\n                return this.rgba2vec(string);\n            }\n            if (Color.isHSLAString(string)) {\n                return this.hsla2vet3(string);\n            }\n            return this.getVec(string, string, 1);\n        }\n    }, {\n        key: 'hsla2vet3',\n        value: function hsla2vet3(hsl) {\n            var temp = hsl;\n            var vec3 = this.colorMap[temp];\n            if (vec3 != undefined) return vec3;\n            hsl = hsl.match(new RegExp(\",\", \"g\"));\n            hsl = hsl || [];\n            var a = 1.0;\n            if (hsl.length == 3) {\n                hsl = temp;\n                var i = hsl.lastIndexOf(',');\n                var i1 = hsl.lastIndexOf(')');\n                var as = hsl.substring(i + 1, i1);\n                a = parseFloat(as);\n                hsl = hsl.substring(0, i);\n                hsl += ')';\n            } else {\n                hsl = temp;\n            }\n            hsl = hsl.replace('a', '');\n            var v = w3color(hsl);\n            if (v.valid) {\n                vec3 = [v.r, v.g, v.b, a];\n                this.colorMap[temp] = vec3;\n                return vec3;\n            } else {\n                return [0, 0, 0, 1];\n            }\n        }\n    }, {\n        key: 'rgba2vec',\n        value: function rgba2vec(rgb) {\n            var temp = rgb;\n            var vec3 = this.colorMap[temp];\n            if (vec3 != undefined) return vec3;\n            rgb = rgb.match(new RegExp(\",\", \"g\"));\n            rgb = rgb || [];\n            var a = 1.0;\n            if (rgb.length == 3) {\n                rgb = temp;\n                var i = rgb.lastIndexOf(',');\n                var i1 = rgb.lastIndexOf(')');\n                var as = rgb.substring(i + 1, i1);\n                a = parseFloat(as);\n                rgb = rgb.substring(0, i);\n                rgb += ')';\n            } else {\n                rgb = temp;\n            }\n            rgb = rgb.replace('a', '');\n            return this.getVec(rgb, temp, a);\n        }\n    }, {\n        key: 'getVec',\n        value: function getVec(string, key, alpha) {\n            var vec3 = this.colorMap[key];\n            if (vec3 != undefined) return vec3;\n            var v = new _W3Color2.default(string);\n            if (v.valid) {\n                var v1 = v.toRgb();\n                var _vec = [v1.r, v1.g, v1.b, alpha];\n                if (this.colorMap[key] == undefined) this.colorMap[key] = _vec;\n                return _vec;\n            } else {\n                return [0, 0, 0, 1];\n            }\n        }\n    }], [{\n        key: 'getInstance',\n        value: function getInstance() {\n            if (!_instance) {\n                _instance = new Color();\n            }\n            return _instance;\n        }\n    }, {\n        key: 'isRGBAString',\n        value: function isRGBAString(string) {\n            if (string) {\n                if (string.indexOf('rgba') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'isHSLAString',\n        value: function isHSLAString(string) {\n            if (string) {\n                if (string.indexOf('hsla') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }]);\n\n    return Color;\n}();\n\nexports.default = Color;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/utils/Color.js?");

/***/ }),

/***/ "./github/src/utils/Tools.js":
/*!***********************************!*\
  !*** ./github/src/utils/Tools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EPSILON = 0.00001;\nvar PI2 = Math.PI * 2;\nvar littleEndian = undefined;\n\nvar Tools = function () {\n    function Tools() {\n        _classCallCheck(this, Tools);\n\n        this.instance = null;\n    }\n\n    _createClass(Tools, null, [{\n        key: \"equals\",\n        value: function equals(a, b) {\n            // return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n            return Math.abs(a - b) <= EPSILON;\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance(point1, point2) {\n            var dx = point1.x - point2.x;\n            var dy = point1.y - point2.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // static collisionResponse(v1, m1, v2, m2, n, e) {\n        //     if (e == undefined) e = 1; // 恢复系数默认为1\n        //     let m1d = undefined;\n        //     let m2d = undefined;\n        //     if (m1 == Infinity) {\n        //         m2d = 1;\n        //         m1d = 0;\n        //     }\n        //     if (m2 == Infinity) {\n        //         m2d = 0;\n        //         m1d = 1;\n        //     }\n        //     if (m1d == undefined && m2d == undefined) {\n        //         m1d = 1 / m1;\n        //         m2d = 1 / m2;\n        //     }\n        //     let up = 0 - (1 + e);\n        //     let v12 = Vector2.TEMP_VECTORS[0];\n        //     v12.x = v1.x - v2.x;\n        //     v12.y = v1.y - v2.y;\n        //     up = up * Vector2.dot(v12, n);\n        //     let tempVector = v12;// {x: n.x, y: n.y};\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, (m1d + m2d));\n        //     let down = Vector2.dot(n, tempVector);\n        //     let j = up / down;\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m1d);\n        //     let newV1 = {x: 0, y: 0};\n        //     Vector2.add(newV1, v1, tempVector);\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m2d);\n        //     let newV2 = {x: 0, y: 0};\n        //     Vector2.sub(newV2, v2, tempVector);\n        //\n        //     return {newV1: newV1, newV2: newV2};\n        // }\n        //\n        //\n        // getProjectionPointOnLine(point, linePoint1, linePoint2) {\n        //     let p = point; // 线外一点p\n        //     let a = linePoint1; // 线上端点a\n        //     let b = linePoint2; // 线上端点b\n        //     let ap = new Vector2(p.x - a.x, p.y - a.y);\n        //     let ab = new Vector2(b.x - a.x, b.y - a.y);\n        //     let abN = Vector2.normalize(ab, ab);//计算出ab的单位向量\n        //     let compAP = Vector2.dot(ap, abN);//ap在ab上分量\n        //     abN.multiply(compAP); //ap在ab上的投影,返回值就是abN\n        //     let p0 = {x: 0, y: 0};\n        //     Vector2.plus(p0, a, abN);\n        //     return p0;\n        // }\n\n    }, {\n        key: \"clamp\",\n        value: function clamp(value, min, max) {\n            if (value > max) {\n                return max;\n            }\n            if (value < min) {\n                return min;\n            }\n            return value;\n        }\n    }, {\n        key: \"getInsance\",\n        value: function getInsance() {\n            if (this.instance == null) {\n                this.instance = new Tools();\n            }\n            return this.instance;\n        }\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(bounds1, bounds2) {\n            var a = bounds1;\n            var b = bounds2;\n            return a.left <= b.right && a.right >= b.left && a.bottom >= b.top && a.top <= b.bottom;\n        }\n    }, {\n        key: \"isHit\",\n        value: function isHit(rect1, rect2) {\n            var result = false;\n            var x = rect1.left;\n            var y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left + rect1.width;\n            y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n\n            x = rect1.left + rect1.width;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            if (!result) {\n                x = rect2.left;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left + rect2.width;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n\n                x = rect2.left + rect2.width;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n            }\n            return result;\n        }\n    }, {\n        key: \"isInTheRect\",\n        value: function isInTheRect(x, y, rect) {\n            var fx = rect.left;\n            var fy = rect.top;\n            var currentWidth = rect.width;\n            var currentHeight = rect.height;\n            if (x > fx && x < fx + currentWidth && y > fy && y < fy + currentHeight) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: \"PI2\",\n        get: function get() {\n            return PI2;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return EPSILON;\n        }\n    }, {\n        key: \"littleEndian\",\n        get: function get() {\n            if (littleEndian === undefined) {\n                // DataView是默认按照高位存放，这里要做判断，更改存放顺序\n                // PS: Float32Array却是按照低位存放的\n                var arrayBuffer = new ArrayBuffer(2);\n                var uint8Array = new Uint8Array(arrayBuffer);\n                var uint16array = new Uint16Array(arrayBuffer);\n                uint8Array[0] = 0xAA; // 第一位是AA\n                uint8Array[1] = 0xBB; // 第二位是BB\n                // 如果从16的view中读取数据，按照其排序就能得出高低位，以便DataView在设置值的时候能正确\n                if (uint16array[0] === 0xBBAA) littleEndian = true;\n                if (uint16array[0] === 0xAABB) littleEndian = false;\n            }\n            return littleEndian;\n        }\n    }]);\n\n    return Tools;\n}();\n\nexports.default = Tools;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/utils/Tools.js?");

/***/ }),

/***/ "./github/src/utils/W3Color.js":
/*!*************************************!*\
  !*** ./github/src/utils/W3Color.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* w3color_removed.js ver.1.18 by w3schools.com (Do not remove this line)*/\n/*用es6 class重构一下*/\nvar W3Color = function () {\n    function W3Color(color, elmnt) {\n        _classCallCheck(this, W3Color);\n\n        if (!(this instanceof W3Color)) {\n            return new W3Color(color, elmnt);\n        }\n        if ((typeof color === \"undefined\" ? \"undefined\" : _typeof(color)) == \"object\") {\n            return color;\n        }\n        this.attachValues(W3Color.toColorObject(color));\n        if (elmnt) {\n            elmnt.style.backgroundColor = this.toRgbString();\n        }\n    }\n\n    _createClass(W3Color, [{\n        key: \"attachValues\",\n        value: function attachValues(color) {\n            this.red = color.red;\n            this.green = color.green;\n            this.blue = color.blue;\n            this.hue = color.hue;\n            this.sat = color.sat;\n            this.lightness = color.lightness;\n            this.whiteness = color.whiteness;\n            this.blackness = color.blackness;\n            this.cyan = color.cyan;\n            this.magenta = color.magenta;\n            this.yellow = color.yellow;\n            this.black = color.black;\n            this.ncol = color.ncol;\n            this.opacity = color.opacity;\n            this.valid = color.valid;\n        }\n    }, {\n        key: \"toRgbString\",\n        value: function toRgbString() {\n            return \"rgb(\" + this.red + \", \" + this.green + \", \" + this.blue + \")\";\n        }\n    }, {\n        key: \"toRgbaString\",\n        value: function toRgbaString() {\n            return \"rgba(\" + this.red + \", \" + this.green + \", \" + this.blue + \", \" + this.opacity + \")\";\n        }\n    }, {\n        key: \"toHwbString\",\n        value: function toHwbString() {\n            return \"hwb(\" + this.hue + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%)\";\n        }\n    }, {\n        key: \"toHwbStringDecimal\",\n        value: function toHwbStringDecimal() {\n            return \"hwb(\" + this.hue + \", \" + this.whiteness + \", \" + this.blackness + \")\";\n        }\n    }, {\n        key: \"toHwbaString\",\n        value: function toHwbaString() {\n            return \"hwba(\" + this.hue + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%, \" + this.opacity + \")\";\n        }\n    }, {\n        key: \"toHslString\",\n        value: function toHslString() {\n            return \"hsl(\" + this.hue + \", \" + Math.round(this.sat * 100) + \"%, \" + Math.round(this.lightness * 100) + \"%)\";\n        }\n    }, {\n        key: \"toHslStringDecimal\",\n        value: function toHslStringDecimal() {\n            return \"hsl(\" + this.hue + \", \" + this.sat + \", \" + this.lightness + \")\";\n        }\n    }, {\n        key: \"toHslaString\",\n        value: function toHslaString() {\n            return \"hsla(\" + this.hue + \", \" + Math.round(this.sat * 100) + \"%, \" + Math.round(this.lightness * 100) + \"%, \" + this.opacity + \")\";\n        }\n    }, {\n        key: \"toCmykString\",\n        value: function toCmykString() {\n            return \"cmyk(\" + Math.round(this.cyan * 100) + \"%, \" + Math.round(this.magenta * 100) + \"%, \" + Math.round(this.yellow * 100) + \"%, \" + Math.round(this.black * 100) + \"%)\";\n        }\n    }, {\n        key: \"toCmykStringDecimal\",\n        value: function toCmykStringDecimal() {\n            return \"cmyk(\" + this.cyan + \", \" + this.magenta + \", \" + this.yellow + \", \" + this.black + \")\";\n        }\n    }, {\n        key: \"toNcolString\",\n        value: function toNcolString() {\n            return this.ncol + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%\";\n        }\n    }, {\n        key: \"toNcolStringDecimal\",\n        value: function toNcolStringDecimal() {\n            return this.ncol + \", \" + this.whiteness + \", \" + this.blackness;\n        }\n    }, {\n        key: \"toNcolaString\",\n        value: function toNcolaString() {\n            return this.ncol + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%, \" + this.opacity;\n        }\n    }, {\n        key: \"toName\",\n        value: function toName() {\n            var r,\n                g,\n                b,\n                colorhexs = getColorArr('hexs');\n            for (i = 0; i < colorhexs.length; i++) {\n                r = parseInt(colorhexs[i].substr(0, 2), 16);\n                g = parseInt(colorhexs[i].substr(2, 2), 16);\n                b = parseInt(colorhexs[i].substr(4, 2), 16);\n                if (this.red == r && this.green == g && this.blue == b) {\n                    return getColorArr('names')[i];\n                }\n            }\n            return \"\";\n        }\n    }, {\n        key: \"toHexString\",\n        value: function toHexString() {\n            var r = toHex(this.red);\n            var g = toHex(this.green);\n            var b = toHex(this.blue);\n            return \"#\" + r + g + b;\n        }\n    }, {\n        key: \"toRgb\",\n        value: function toRgb() {\n            return { r: this.red, g: this.green, b: this.blue, a: this.opacity };\n        }\n    }, {\n        key: \"toHsl\",\n        value: function toHsl() {\n            return { h: this.hue, s: this.sat, l: this.lightness, a: this.opacity };\n        }\n    }, {\n        key: \"toHwb\",\n        value: function toHwb() {\n            return { h: this.hue, w: this.whiteness, b: this.blackness, a: this.opacity };\n        }\n    }, {\n        key: \"toCmyk\",\n        value: function toCmyk() {\n            return { c: this.cyan, m: this.magenta, y: this.yellow, k: this.black, a: this.opacity };\n        }\n    }, {\n        key: \"toNcol\",\n        value: function toNcol() {\n            return { ncol: this.ncol, w: this.whiteness, b: this.blackness, a: this.opacity };\n        }\n    }, {\n        key: \"isDark\",\n        value: function isDark(n) {\n            var m = n || 128;\n            return (this.red * 299 + this.green * 587 + this.blue * 114) / 1000 < m;\n        }\n    }, {\n        key: \"saturate\",\n        value: function saturate(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.sat += x;\n            if (this.sat > 1) {\n                this.sat = 1;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n    }, {\n        key: \"desaturate\",\n        value: function desaturate(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.sat -= x;\n            if (this.sat < 0) {\n                this.sat = 0;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n    }, {\n        key: \"lighter\",\n        value: function lighter(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.lightness += x;\n            if (this.lightness > 1) {\n                this.lightness = 1;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n    }, {\n        key: \"darker\",\n        value: function darker(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.lightness -= x;\n            if (this.lightness < 0) {\n                this.lightness = 0;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n\n        // (function () {\n\n    }], [{\n        key: \"w3color\",\n        value: function (_w3color) {\n            function w3color(_x, _x2) {\n                return _w3color.apply(this, arguments);\n            }\n\n            w3color.toString = function () {\n                return _w3color.toString();\n            };\n\n            return w3color;\n        }(function (color, elmnt) {\n            if (!(this instanceof w3color)) {\n                return new w3color(color, elmnt);\n            }\n            if ((typeof color === \"undefined\" ? \"undefined\" : _typeof(color)) == \"object\") {\n                return color;\n            }\n            this.attachValues(toColorObject(color));\n            if (elmnt) {\n                elmnt.style.backgroundColor = this.toRgbString();\n            }\n        })\n    }, {\n        key: \"toColorObject\",\n        value: function toColorObject(c) {\n            var x,\n                y,\n                typ,\n                arr = [],\n                arrlength,\n                i,\n                opacity,\n                match,\n                a,\n                hue,\n                sat,\n                rgb,\n                colornames = [],\n                colorhexs = [];\n            c = this.w3trim(c.toLowerCase());\n            x = c.substr(0, 1).toUpperCase();\n            y = c.substr(1);\n            a = 1;\n            if ((x == \"R\" || x == \"Y\" || x == \"G\" || x == \"C\" || x == \"B\" || x == \"M\" || x == \"W\") && !isNaN(y)) {\n                if (c.length == 6 && c.indexOf(\",\") == -1) {} else {\n                    c = \"ncol(\" + c + \")\";\n                }\n            }\n            if (c.length != 3 && c.length != 6 && !isNaN(c)) {\n                c = \"ncol(\" + c + \")\";\n            }\n            if (c.indexOf(\",\") > 0 && c.indexOf(\"(\") == -1) {\n                c = \"ncol(\" + c + \")\";\n            }\n            if (c.substr(0, 3) == \"rgb\" || c.substr(0, 3) == \"hsl\" || c.substr(0, 3) == \"hwb\" || c.substr(0, 4) == \"ncol\" || c.substr(0, 4) == \"cmyk\") {\n                if (c.substr(0, 4) == \"ncol\") {\n                    if (c.split(\",\").length == 4 && c.indexOf(\"ncola\") == -1) {\n                        c = c.replace(\"ncol\", \"ncola\");\n                    }\n                    typ = \"ncol\";\n                    c = c.substr(4);\n                } else if (c.substr(0, 4) == \"cmyk\") {\n                    typ = \"cmyk\";\n                    c = c.substr(4);\n                } else {\n                    typ = c.substr(0, 3);\n                    c = c.substr(3);\n                }\n                arrlength = 3;\n                opacity = false;\n                if (c.substr(0, 1).toLowerCase() == \"a\") {\n                    arrlength = 4;\n                    opacity = true;\n                    c = c.substr(1);\n                } else if (typ == \"cmyk\") {\n                    arrlength = 4;\n                    if (c.split(\",\").length == 5) {\n                        arrlength = 5;\n                        opacity = true;\n                    }\n                }\n                c = c.replace(\"(\", \"\");\n                c = c.replace(\")\", \"\");\n                arr = c.split(\",\");\n                if (typ == \"rgb\") {\n                    if (arr.length != arrlength) {\n                        return this.emptyObject();\n                    }\n                    for (i = 0; i < arrlength; i++) {\n                        if (arr[i] == \"\" || arr[i] == \" \") {\n                            arr[i] = \"0\";\n                        }\n                        if (arr[i].indexOf(\"%\") > -1) {\n                            arr[i] = arr[i].replace(\"%\", \"\");\n                            arr[i] = Number(arr[i] / 100);\n                            if (i < 3) {\n                                arr[i] = Math.round(arr[i] * 255);\n                            }\n                        }\n                        if (isNaN(arr[i])) {\n                            return this.emptyObject();\n                        }\n                        if (parseInt(arr[i]) > 255) {\n                            arr[i] = 255;\n                        }\n                        if (i < 3) {\n                            arr[i] = parseInt(arr[i]);\n                        }\n                        if (i == 3 && Number(arr[i]) > 1) {\n                            arr[i] = 1;\n                        }\n                    }\n                    rgb = { r: arr[0], g: arr[1], b: arr[2] };\n                    if (opacity == true) {\n                        a = Number(arr[3]);\n                    }\n                }\n                if (typ == \"hsl\" || typ == \"hwb\" || typ == \"ncol\") {\n                    while (arr.length < arrlength) {\n                        arr.push(\"0\");\n                    }\n                    if (typ == \"hsl\" || typ == \"hwb\") {\n                        if (parseInt(arr[0]) >= 360) {\n                            arr[0] = 0;\n                        }\n                    }\n                    for (i = 1; i < arrlength; i++) {\n                        if (arr[i].indexOf(\"%\") > -1) {\n                            arr[i] = arr[i].replace(\"%\", \"\");\n                            arr[i] = Number(arr[i]);\n                            if (isNaN(arr[i])) {\n                                return this.emptyObject();\n                            }\n                            arr[i] = arr[i] / 100;\n                        } else {\n                            arr[i] = Number(arr[i]);\n                        }\n                        if (Number(arr[i]) > 1) {\n                            arr[i] = 1;\n                        }\n                        if (Number(arr[i]) < 0) {\n                            arr[i] = 0;\n                        }\n                    }\n                    if (typ == \"hsl\") {\n                        rgb = this.hslToRgb(arr[0], arr[1], arr[2]);\n                        hue = Number(arr[0]);\n                        sat = Number(arr[1]);\n                    }\n                    if (typ == \"hwb\") {\n                        rgb = this.hwbToRgb(arr[0], arr[1], arr[2]);\n                    }\n                    if (typ == \"ncol\") {\n                        rgb = this.ncolToRgb(arr[0], arr[1], arr[2]);\n                    }\n                    if (opacity == true) {\n                        a = Number(arr[3]);\n                    }\n                }\n                if (typ == \"cmyk\") {\n                    while (arr.length < arrlength) {\n                        arr.push(\"0\");\n                    }\n                    for (i = 0; i < arrlength; i++) {\n                        if (arr[i].indexOf(\"%\") > -1) {\n                            arr[i] = arr[i].replace(\"%\", \"\");\n                            arr[i] = Number(arr[i]);\n                            if (isNaN(arr[i])) {\n                                return this.emptyObject();\n                            }\n                            arr[i] = arr[i] / 100;\n                        } else {\n                            arr[i] = Number(arr[i]);\n                        }\n                        if (Number(arr[i]) > 1) {\n                            arr[i] = 1;\n                        }\n                        if (Number(arr[i]) < 0) {\n                            arr[i] = 0;\n                        }\n                    }\n                    rgb = this.cmykToRgb(arr[0], arr[1], arr[2], arr[3]);\n                    if (opacity == true) {\n                        a = Number(arr[4]);\n                    }\n                }\n            } else if (c.substr(0, 3) == \"ncs\") {\n                rgb = this.ncsToRgb(c);\n            } else {\n                match = false;\n                colornames = this.getColorArr('names');\n                for (i = 0; i < colornames.length; i++) {\n                    if (c.toLowerCase() == colornames[i].toLowerCase()) {\n                        colorhexs = this.getColorArr('hexs');\n                        match = true;\n                        rgb = {\n                            r: parseInt(colorhexs[i].substr(0, 2), 16),\n                            g: parseInt(colorhexs[i].substr(2, 2), 16),\n                            b: parseInt(colorhexs[i].substr(4, 2), 16)\n                        };\n                        break;\n                    }\n                }\n                if (match == false) {\n                    c = c.replace(\"#\", \"\");\n                    if (c.length == 3) {\n                        c = c.substr(0, 1) + c.substr(0, 1) + c.substr(1, 1) + c.substr(1, 1) + c.substr(2, 1) + c.substr(2, 1);\n                    }\n                    for (i = 0; i < c.length; i++) {\n                        if (!this.isHex(c.substr(i, 1))) {\n                            return this.emptyObject();\n                        }\n                    }\n                    arr[0] = parseInt(c.substr(0, 2), 16);\n                    arr[1] = parseInt(c.substr(2, 2), 16);\n                    arr[2] = parseInt(c.substr(4, 2), 16);\n                    for (i = 0; i < 3; i++) {\n                        if (isNaN(arr[i])) {\n                            return this.emptyObject();\n                        }\n                    }\n                    rgb = {\n                        r: arr[0],\n                        g: arr[1],\n                        b: arr[2]\n                    };\n                }\n            }\n            return this.colorObject(rgb, a, hue, sat);\n        }\n    }, {\n        key: \"colorObject\",\n        value: function colorObject(rgb, a, h, s) {\n            var hsl, hwb, cmyk, ncol, color, hue, sat;\n            if (!rgb) {\n                return this.emptyObject();\n            }\n            if (!a) {\n                a = 1;\n            }\n            hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);\n            hwb = this.rgbToHwb(rgb.r, rgb.g, rgb.b);\n            cmyk = this.rgbToCmyk(rgb.r, rgb.g, rgb.b);\n            hue = h || hsl.h;\n            sat = s || hsl.s;\n            ncol = this.hueToNcol(hue);\n            color = {\n                red: rgb.r,\n                green: rgb.g,\n                blue: rgb.b,\n                hue: hue,\n                sat: sat,\n                lightness: hsl.l,\n                whiteness: hwb.w,\n                blackness: hwb.b,\n                cyan: cmyk.c,\n                magenta: cmyk.m,\n                yellow: cmyk.y,\n                black: cmyk.k,\n                ncol: ncol,\n                opacity: a,\n                valid: true\n            };\n            color = this.roundDecimals(color);\n            return color;\n        }\n    }, {\n        key: \"emptyObject\",\n        value: function emptyObject() {\n            return {\n                red: 0,\n                green: 0,\n                blue: 0,\n                hue: 0,\n                sat: 0,\n                lightness: 0,\n                whiteness: 0,\n                blackness: 0,\n                cyan: 0,\n                magenta: 0,\n                yellow: 0,\n                black: 0,\n                ncol: \"R\",\n                opacity: 1,\n                valid: false\n            };\n        }\n    }, {\n        key: \"getColorArr\",\n        value: function getColorArr(x) {\n            if (x == \"names\") {\n                return ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];\n            }\n            if (x == \"hexs\") {\n                return ['f0f8ff', 'faebd7', '00ffff', '7fffd4', 'f0ffff', 'f5f5dc', 'ffe4c4', '000000', 'ffebcd', '0000ff', '8a2be2', 'a52a2a', 'deb887', '5f9ea0', '7fff00', 'd2691e', 'ff7f50', '6495ed', 'fff8dc', 'dc143c', '00ffff', '00008b', '008b8b', 'b8860b', 'a9a9a9', 'a9a9a9', '006400', 'bdb76b', '8b008b', '556b2f', 'ff8c00', '9932cc', '8b0000', 'e9967a', '8fbc8f', '483d8b', '2f4f4f', '2f4f4f', '00ced1', '9400d3', 'ff1493', '00bfff', '696969', '696969', '1e90ff', 'b22222', 'fffaf0', '228b22', 'ff00ff', 'dcdcdc', 'f8f8ff', 'ffd700', 'daa520', '808080', '808080', '008000', 'adff2f', 'f0fff0', 'ff69b4', 'cd5c5c', '4b0082', 'fffff0', 'f0e68c', 'e6e6fa', 'fff0f5', '7cfc00', 'fffacd', 'add8e6', 'f08080', 'e0ffff', 'fafad2', 'd3d3d3', 'd3d3d3', '90ee90', 'ffb6c1', 'ffa07a', '20b2aa', '87cefa', '778899', '778899', 'b0c4de', 'ffffe0', '00ff00', '32cd32', 'faf0e6', 'ff00ff', '800000', '66cdaa', '0000cd', 'ba55d3', '9370db', '3cb371', '7b68ee', '00fa9a', '48d1cc', 'c71585', '191970', 'f5fffa', 'ffe4e1', 'ffe4b5', 'ffdead', '000080', 'fdf5e6', '808000', '6b8e23', 'ffa500', 'ff4500', 'da70d6', 'eee8aa', '98fb98', 'afeeee', 'db7093', 'ffefd5', 'ffdab9', 'cd853f', 'ffc0cb', 'dda0dd', 'b0e0e6', '800080', '663399', 'ff0000', 'bc8f8f', '4169e1', '8b4513', 'fa8072', 'f4a460', '2e8b57', 'fff5ee', 'a0522d', 'c0c0c0', '87ceeb', '6a5acd', '708090', '708090', 'fffafa', '00ff7f', '4682b4', 'd2b48c', '008080', 'd8bfd8', 'ff6347', '40e0d0', 'ee82ee', 'f5deb3', 'ffffff', 'f5f5f5', 'ffff00', '9acd32'];\n            }\n        }\n    }, {\n        key: \"roundDecimals\",\n        value: function roundDecimals(c) {\n            c.red = Number(c.red.toFixed(0));\n            c.green = Number(c.green.toFixed(0));\n            c.blue = Number(c.blue.toFixed(0));\n            c.hue = Number(c.hue.toFixed(0));\n            c.sat = Number(c.sat.toFixed(2));\n            c.lightness = Number(c.lightness.toFixed(2));\n            c.whiteness = Number(c.whiteness.toFixed(2));\n            c.blackness = Number(c.blackness.toFixed(2));\n            c.cyan = Number(c.cyan.toFixed(2));\n            c.magenta = Number(c.magenta.toFixed(2));\n            c.yellow = Number(c.yellow.toFixed(2));\n            c.black = Number(c.black.toFixed(2));\n            c.ncol = c.ncol.substr(0, 1) + Math.round(Number(c.ncol.substr(1)));\n            c.opacity = Number(c.opacity.toFixed(2));\n            return c;\n        }\n    }, {\n        key: \"hslToRgb\",\n        value: function hslToRgb(hue, sat, light) {\n            var t1, t2, r, g, b;\n            hue = hue / 60;\n            if (light <= 0.5) {\n                t2 = light * (sat + 1);\n            } else {\n                t2 = light + sat - light * sat;\n            }\n            t1 = light * 2 - t2;\n            r = hueToRgb(t1, t2, hue + 2) * 255;\n            g = hueToRgb(t1, t2, hue) * 255;\n            b = hueToRgb(t1, t2, hue - 2) * 255;\n            return { r: r, g: g, b: b };\n        }\n    }, {\n        key: \"hueToRgb\",\n        value: function hueToRgb(t1, t2, hue) {\n            if (hue < 0) hue += 6;\n            if (hue >= 6) hue -= 6;\n            if (hue < 1) return (t2 - t1) * hue + t1;else if (hue < 3) return t2;else if (hue < 4) return (t2 - t1) * (4 - hue) + t1;else return t1;\n        }\n    }, {\n        key: \"hwbToRgb\",\n        value: function hwbToRgb(hue, white, black) {\n            var i,\n                rgb,\n                rgbArr = [],\n                tot;\n            rgb = hslToRgb(hue, 1, 0.50);\n            rgbArr[0] = rgb.r / 255;\n            rgbArr[1] = rgb.g / 255;\n            rgbArr[2] = rgb.b / 255;\n            tot = white + black;\n            if (tot > 1) {\n                white = Number((white / tot).toFixed(2));\n                black = Number((black / tot).toFixed(2));\n            }\n            for (i = 0; i < 3; i++) {\n                rgbArr[i] *= 1 - white - black;\n                rgbArr[i] += white;\n                rgbArr[i] = Number(rgbArr[i] * 255);\n            }\n            return { r: rgbArr[0], g: rgbArr[1], b: rgbArr[2] };\n        }\n    }, {\n        key: \"cmykToRgb\",\n        value: function cmykToRgb(c, m, y, k) {\n            var r, g, b;\n            r = 255 - Math.min(1, c * (1 - k) + k) * 255;\n            g = 255 - Math.min(1, m * (1 - k) + k) * 255;\n            b = 255 - Math.min(1, y * (1 - k) + k) * 255;\n            return { r: r, g: g, b: b };\n        }\n    }, {\n        key: \"ncolToRgb\",\n        value: function ncolToRgb(ncol, white, black) {\n            var letter, percent, h, w, b;\n            h = ncol;\n            if (isNaN(ncol.substr(0, 1))) {\n                letter = ncol.substr(0, 1).toUpperCase();\n                percent = ncol.substr(1);\n                if (percent == \"\") {\n                    percent = 0;\n                }\n                percent = Number(percent);\n                if (isNaN(percent)) {\n                    return false;\n                }\n                if (letter == \"R\") {\n                    h = 0 + percent * 0.6;\n                }\n                if (letter == \"Y\") {\n                    h = 60 + percent * 0.6;\n                }\n                if (letter == \"G\") {\n                    h = 120 + percent * 0.6;\n                }\n                if (letter == \"C\") {\n                    h = 180 + percent * 0.6;\n                }\n                if (letter == \"B\") {\n                    h = 240 + percent * 0.6;\n                }\n                if (letter == \"M\") {\n                    h = 300 + percent * 0.6;\n                }\n                if (letter == \"W\") {\n                    h = 0;\n                    white = 1 - percent / 100;\n                    black = percent / 100;\n                }\n            }\n            return hwbToRgb(h, white, black);\n        }\n    }, {\n        key: \"hueToNcol\",\n        value: function hueToNcol(hue) {\n            while (hue >= 360) {\n                hue = hue - 360;\n            }\n            if (hue < 60) {\n                return \"R\" + hue / 0.6;\n            }\n            if (hue < 120) {\n                return \"Y\" + (hue - 60) / 0.6;\n            }\n            if (hue < 180) {\n                return \"G\" + (hue - 120) / 0.6;\n            }\n            if (hue < 240) {\n                return \"C\" + (hue - 180) / 0.6;\n            }\n            if (hue < 300) {\n                return \"B\" + (hue - 240) / 0.6;\n            }\n            if (hue < 360) {\n                return \"M\" + (hue - 300) / 0.6;\n            }\n        }\n    }, {\n        key: \"ncsToRgb\",\n        value: function ncsToRgb(ncs) {\n            var black, chroma, bc, percent, black1, chroma1, red1, factor1, blue1, red1, red2, green2, blue2, max, factor2, grey, r, g, b;\n            ncs = w3trim(ncs).toUpperCase();\n            ncs = ncs.replace(\"(\", \"\");\n            ncs = ncs.replace(\")\", \"\");\n            ncs = ncs.replace(\"NCS\", \"NCS \");\n            ncs = ncs.replace(/  /g, \" \");\n            if (ncs.indexOf(\"NCS\") == -1) {\n                ncs = \"NCS \" + ncs;\n            }\n            ncs = ncs.match(/^(?:NCS|NCS\\sS)\\s(\\d{2})(\\d{2})-(N|[A-Z])(\\d{2})?([A-Z])?$/);\n            if (ncs === null) return false;\n            black = parseInt(ncs[1], 10);\n            chroma = parseInt(ncs[2], 10);\n            bc = ncs[3];\n            if (bc != \"N\" && bc != \"Y\" && bc != \"R\" && bc != \"B\" && bc != \"G\") {\n                return false;\n            }\n            percent = parseInt(ncs[4], 10) || 0;\n            if (bc !== 'N') {\n                black1 = 1.05 * black - 5.25;\n                chroma1 = chroma;\n                if (bc === 'Y' && percent <= 60) {\n                    red1 = 1;\n                } else if (bc === 'Y' && percent > 60 || bc === 'R' && percent <= 80) {\n                    if (bc === 'Y') {\n                        factor1 = percent - 60;\n                    } else {\n                        factor1 = percent + 40;\n                    }\n                    red1 = (Math.sqrt(14884 - Math.pow(factor1, 2)) - 22) / 100;\n                } else if (bc === 'R' && percent > 80 || bc === 'B') {\n                    red1 = 0;\n                } else if (bc === 'G') {\n                    factor1 = percent - 170;\n                    red1 = (Math.sqrt(33800 - Math.pow(factor1, 2)) - 70) / 100;\n                }\n                if (bc === 'Y' && percent <= 80) {\n                    blue1 = 0;\n                } else if (bc === 'Y' && percent > 80 || bc === 'R' && percent <= 60) {\n                    if (bc === 'Y') {\n                        factor1 = percent - 80 + 20.5;\n                    } else {\n                        factor1 = percent + 20 + 20.5;\n                    }\n                    blue1 = (104 - Math.sqrt(11236 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'R' && percent > 60 || bc === 'B' && percent <= 80) {\n                    if (bc === 'R') {\n                        factor1 = percent - 60 - 60;\n                    } else {\n                        factor1 = percent + 40 - 60;\n                    }\n                    blue1 = (Math.sqrt(10000 - Math.pow(factor1, 2)) - 10) / 100;\n                } else if (bc === 'B' && percent > 80 || bc === 'G' && percent <= 40) {\n                    if (bc === 'B') {\n                        factor1 = percent - 80 - 131;\n                    } else {\n                        factor1 = percent + 20 - 131;\n                    }\n                    blue1 = (122 - Math.sqrt(19881 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'G' && percent > 40) {\n                    blue1 = 0;\n                }\n                var green1 = void 0;\n                if (bc === 'Y') {\n                    green1 = (85 - 17 / 20 * percent) / 100;\n                } else if (bc === 'R' && percent <= 60) {\n                    green1 = 0;\n                } else if (bc === 'R' && percent > 60) {\n                    factor1 = percent - 60 + 35;\n                    green1 = (67.5 - Math.sqrt(5776 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'B' && percent <= 60) {\n                    factor1 = 1 * percent - 68.5;\n                    green1 = (6.5 + Math.sqrt(7044.5 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'B' && percent > 60 || bc === 'G' && percent <= 60) {\n                    green1 = 0.9;\n                } else if (bc === 'G' && percent > 60) {\n                    factor1 = percent - 60;\n                    green1 = (90 - 1 / 8 * factor1) / 100;\n                }\n                factor1 = (red1 + green1 + blue1) / 3;\n                red2 = (factor1 - red1) * (100 - chroma1) / 100 + red1;\n                green2 = (factor1 - green1) * (100 - chroma1) / 100 + green1;\n                blue2 = (factor1 - blue1) * (100 - chroma1) / 100 + blue1;\n                if (red2 > green2 && red2 > blue2) {\n                    max = red2;\n                } else if (green2 > red2 && green2 > blue2) {\n                    max = green2;\n                } else if (blue2 > red2 && blue2 > green2) {\n                    max = blue2;\n                } else {\n                    max = (red2 + green2 + blue2) / 3;\n                }\n                factor2 = 1 / max;\n                r = parseInt(red2 * factor2 * (100 - black1) / 100 * 255, 10);\n                g = parseInt(green2 * factor2 * (100 - black1) / 100 * 255, 10);\n                b = parseInt(blue2 * factor2 * (100 - black1) / 100 * 255, 10);\n                if (r > 255) {\n                    r = 255;\n                }\n                if (g > 255) {\n                    g = 255;\n                }\n                if (b > 255) {\n                    b = 255;\n                }\n                if (r < 0) {\n                    r = 0;\n                }\n                if (g < 0) {\n                    g = 0;\n                }\n                if (b < 0) {\n                    b = 0;\n                }\n            } else {\n                grey = parseInt((1 - black / 100) * 255, 10);\n                if (grey > 255) {\n                    grey = 255;\n                }\n                if (grey < 0) {\n                    grey = 0;\n                }\n                r = grey;\n                g = grey;\n                b = grey;\n            }\n            return {\n                r: r,\n                g: g,\n                b: b\n            };\n        }\n    }, {\n        key: \"rgbToHsl\",\n        value: function rgbToHsl(r, g, b) {\n            var min,\n                max,\n                i,\n                l,\n                s,\n                maxcolor,\n                h,\n                rgb = [];\n            rgb[0] = r / 255;\n            rgb[1] = g / 255;\n            rgb[2] = b / 255;\n            min = rgb[0];\n            max = rgb[0];\n            maxcolor = 0;\n            for (i = 0; i < rgb.length - 1; i++) {\n                if (rgb[i + 1] <= min) {\n                    min = rgb[i + 1];\n                }\n                if (rgb[i + 1] >= max) {\n                    max = rgb[i + 1];\n                    maxcolor = i + 1;\n                }\n            }\n            if (maxcolor == 0) {\n                h = (rgb[1] - rgb[2]) / (max - min);\n            }\n            if (maxcolor == 1) {\n                h = 2 + (rgb[2] - rgb[0]) / (max - min);\n            }\n            if (maxcolor == 2) {\n                h = 4 + (rgb[0] - rgb[1]) / (max - min);\n            }\n            if (isNaN(h)) {\n                h = 0;\n            }\n            h = h * 60;\n            if (h < 0) {\n                h = h + 360;\n            }\n            l = (min + max) / 2;\n            if (min == max) {\n                s = 0;\n            } else {\n                if (l < 0.5) {\n                    s = (max - min) / (max + min);\n                } else {\n                    s = (max - min) / (2 - max - min);\n                }\n            }\n            s = s;\n            return { h: h, s: s, l: l };\n        }\n    }, {\n        key: \"rgbToHwb\",\n        value: function rgbToHwb(r, g, b) {\n            var h, w, bl;\n            r = r / 255;\n            g = g / 255;\n            b = b / 255;\n            var max = Math.max(r, g, b);\n            var min = Math.min(r, g, b);\n            var chroma = max - min;\n            if (chroma == 0) {\n                h = 0;\n            } else if (r == max) {\n                h = (g - b) / chroma % 6 * 360;\n            } else if (g == max) {\n                h = ((b - r) / chroma + 2) % 6 * 360;\n            } else {\n                h = ((r - g) / chroma + 4) % 6 * 360;\n            }\n            w = min;\n            bl = 1 - max;\n            return { h: h, w: w, b: bl };\n        }\n    }, {\n        key: \"rgbToCmyk\",\n        value: function rgbToCmyk(r, g, b) {\n            var c, m, y, k;\n            r = r / 255;\n            g = g / 255;\n            b = b / 255;\n            var max = Math.max(r, g, b);\n            k = 1 - max;\n            if (k == 1) {\n                c = 0;\n                m = 0;\n                y = 0;\n            } else {\n                c = (1 - r - k) / (1 - k);\n                m = (1 - g - k) / (1 - k);\n                y = (1 - b - k) / (1 - k);\n            }\n            return { c: c, m: m, y: y, k: k };\n        }\n    }, {\n        key: \"toHex\",\n        value: function toHex(n) {\n            var hex = n.toString(16);\n            while (hex.length < 2) {\n                hex = \"0\" + hex;\n            }\n            return hex;\n        }\n    }, {\n        key: \"cl\",\n        value: function cl(x) {\n            console.log(x);\n        }\n    }, {\n        key: \"w3trim\",\n        value: function w3trim(x) {\n            return x.replace(/^\\s+|\\s+$/g, '');\n        }\n    }, {\n        key: \"isHex\",\n        value: function isHex(x) {\n            return '0123456789ABCDEFabcdef'.indexOf(x) > -1;\n        }\n    }]);\n\n    return W3Color;\n}();\n\nexports.default = W3Color;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/utils/W3Color.js?");

/***/ }),

/***/ "./github/src/webgl/BaseBufferData.js":
/*!********************************************!*\
  !*** ./github/src/webgl/BaseBufferData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TYPE_FLOAT32 = 4;\nvar TYPE_FLOAT64 = 8;\nvar TYPE_UINT8 = 2;\nvar TYPE_UINT16 = 3;\nvar TYPE_UINT32 = 0;\nvar TYPE_INT8 = 5;\nvar TYPE_INT16 = 6;\nvar TYPE_INT32 = 7;\nvar TYPE_UINT8CLAMPED = 1;\n\nvar _littleEndian = undefined;\n\nvar BaseBufferData = function () {\n    function BaseBufferData(dataNum, singleDataByteLength) {\n        _classCallCheck(this, BaseBufferData);\n\n        this.singleDataByteLength = singleDataByteLength;\n        this.buffer = new ArrayBuffer(dataNum * singleDataByteLength);\n        this.dv = new DataView(this.buffer);\n        this.currentIndex = 0;\n        this.isLittleEndian = BaseBufferData.littleEndian();\n    }\n\n    _createClass(BaseBufferData, [{\n        key: 'init',\n        value: function init() {\n            this.currentIndex = 0;\n        }\n    }, {\n        key: 'getData',\n        value: function getData(index, type, offset) {\n            index = index * this.singleDataByteLength;\n            if (type == undefined) type = TYPE_FLOAT32;\n            if (offset == undefined) offset = 0;\n            index += offset;\n            var littleEndian = this.isLittleEndian;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    return this.dv.getFloat64(index, littleEndian);\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    return this.dv.getUint8(index);\n                    break;\n                case TYPE_INT8:\n                    return this.dv.getInt8(index);\n                    break;\n                case TYPE_UINT8:\n                    return this.dv.getUint8(index);\n                    break;\n                case TYPE_INT16:\n                    return this.dv.getInt16(index, littleEndian);\n                    break;\n                case TYPE_UINT16:\n                    return this.dv.getUint16(index, littleEndian);\n                    break;\n                case TYPE_FLOAT32:\n                    return this.dv.getFloat32(index, littleEndian);\n                    break;\n                case TYPE_INT32:\n                    return this.dv.getInt32(index, littleEndian);\n                    break;\n                case TYPE_UINT32:\n                    return this.dv.getUint32(index, littleEndian);\n                    break;\n            }\n        }\n    }, {\n        key: 'setData',\n        value: function setData(value, index, type, offset) {\n            var littleEndian = this.isLittleEndian;\n            if (offset == undefined) offset = 0;\n            if (type == undefined) type = TYPE_FLOAT32;\n            index = index * this.singleDataByteLength;\n            index += offset;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    this.dv.setFloat64(index, value, littleEndian);\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    this.dv.setUint8(index, value);\n                    break;\n                case TYPE_INT8:\n                    this.dv.setInt8(index, value);\n                    break;\n                case TYPE_UINT8:\n                    this.dv.setUint8(index, value);\n                    break;\n                case TYPE_INT16:\n                    this.dv.setInt16(index, value, littleEndian);\n                    break;\n                case TYPE_UINT16:\n                    this.dv.setUint16(index, value, littleEndian);\n                    break;\n                case TYPE_FLOAT32:\n                    this.dv.setFloat32(index, value, littleEndian);\n                    break;\n                case TYPE_INT32:\n                    this.dv.setInt32(index, value, littleEndian);\n                    break;\n                case TYPE_UINT32:\n                    this.dv.setUint32(index, value, littleEndian);\n                    break;\n            }\n        }\n    }, {\n        key: 'resize',\n        value: function resize(length) {\n            if (length < this.totalByteLength) throw Error('new length should not less than old length');\n            var oldBuffer = this.buffer;\n            this.buffer = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this.buffer);\n            ndv.set(dv1, 0);\n            this.dv = new DataView(this.buffer);\n        }\n    }, {\n        key: 'totalByteLength',\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }], [{\n        key: 'littleEndian',\n        value: function littleEndian() {\n            if (_littleEndian == undefined) {\n                var arrayBuffer = new ArrayBuffer(2);\n                var uint8Array = new Uint8Array(arrayBuffer);\n                var uint16array = new Uint16Array(arrayBuffer);\n                uint8Array[0] = 0xAA; // 第一位是AA\n                uint8Array[1] = 0xBB; // 第二位是BB\n                // 如果从16的view中读取数据，按照其排序就能得出高低位，以便DataView在设置值的时候能正确\n                if (uint16array[0] === 0xBBAA) _littleEndian = true;\n                if (uint16array[0] === 0xAABB) _littleEndian = false;\n                return _littleEndian;\n            } else {\n                return _littleEndian;\n            }\n        }\n    }, {\n        key: 'TYPE_FLOAT32',\n        get: function get() {\n            return TYPE_FLOAT32;\n        }\n    }, {\n        key: 'TYPE_FLOAT64',\n        get: function get() {\n            return TYPE_FLOAT64;\n        }\n    }, {\n        key: 'TYPE_UINT8',\n        get: function get() {\n            return TYPE_UINT8;\n        }\n    }, {\n        key: 'TYPE_UINT16',\n        get: function get() {\n            return TYPE_UINT16;\n        }\n    }, {\n        key: 'TYPE_UINT32',\n        get: function get() {\n            return TYPE_UINT32;\n        }\n    }, {\n        key: 'TYPE_INT8',\n        get: function get() {\n            return TYPE_INT8;\n        }\n    }, {\n        key: 'TYPE_INT16',\n        get: function get() {\n            return TYPE_INT16;\n        }\n    }, {\n        key: 'TYPE_INT32',\n        get: function get() {\n            return TYPE_INT32;\n        }\n    }, {\n        key: 'TYPE_UINT8CLAMPED',\n        get: function get() {\n            return TYPE_UINT8CLAMPED;\n        }\n    }]);\n\n    return BaseBufferData;\n}();\n\nexports.default = BaseBufferData;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/BaseBufferData.js?");

/***/ }),

/***/ "./github/src/webgl/CanvasDrawingStylesWebgl2D.js":
/*!********************************************************!*\
  !*** ./github/src/webgl/CanvasDrawingStylesWebgl2D.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _lineWidth = Symbol('线宽度,默认1');\nvar _lineCap = Symbol('线连接样式，\"butt\", \"round\", \"square\" (默认: \"butt\")');\nvar _lineJoin = Symbol('线连接样式，\"round\", \"bevel\", \"miter\" (默认: \"miter\")');\nvar _miterLimit = Symbol('默认10');\n\nvar _font = Symbol('文字字体大小等，默认\"10px sans-serif\"');\nvar _textAlign = Symbol('文字对齐,\"start\", \"end\", \"left\", \"right\", \"center\" (默认: \"start\")');\nvar _textBaseline = Symbol('文字纵向对齐，\"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\" (默认: \"alphabetic\")');\n\nvar CanvasDrawingStylesWebgl2D = function () {\n    function CanvasDrawingStylesWebgl2D() {\n        _classCallCheck(this, CanvasDrawingStylesWebgl2D);\n\n        this[_lineWidth] = 1;\n        this[_lineCap] = \"butt\";\n        this[_lineJoin] = \"miter\";\n        this[_miterLimit] = 10;\n        this.font = '10px sans-serif';\n        this.textAlign = 'start';\n        this.textBaseline = 'alphabetic';\n    }\n\n    _createClass(CanvasDrawingStylesWebgl2D, [{\n        key: 'clone',\n        value: function clone() {\n            var c = new CanvasDrawingStylesWebgl2D();\n            c.textBaseline = this.textBaseline;\n            c.textAlign = this.textAlign;\n            c.font = this.font;\n            c.lineCap = this.lineCap;\n            c.lineJoin = this.lineJoin;\n            c.lineWidth = this.lineWidth;\n            return c;\n        }\n    }, {\n        key: 'lineCap',\n        get: function get() {\n            return this[_lineCap];\n        },\n        set: function set(lineCap) {\n            this[_lineCap] = lineCap;\n        }\n\n        // line caps/joins\n\n    }, {\n        key: 'lineWidth',\n        get: function get() {\n            return this[_lineWidth];\n        },\n        set: function set(lineWidth) {\n            this[_lineWidth] = lineWidth;\n        }\n    }, {\n        key: 'lineJoin',\n        get: function get() {\n            return this[_lineJoin];\n        },\n        set: function set(lineJoin) {\n            this[_lineJoin] = lineJoin;\n        }\n    }, {\n        key: 'miterLimit',\n        get: function get() {\n            return this[_miterLimit];\n        },\n        set: function set(miterLimit) {\n            this[_miterLimit] = miterLimit;\n        }\n\n        // 没有实现的：\n        // dashed lines\n        // void setLineDash(sequence<unrestricted double> segments); // (default: empty)\n        // sequence<unrestricted double> getLineDash();\n        // attribute unrestricted double lineDashOffset;\n\n\n        // text\n\n    }, {\n        key: 'font',\n        get: function get() {\n            return this[_font];\n        },\n        set: function set(font) {\n            this[_font] = font;\n        }\n    }, {\n        key: 'textAlign',\n        get: function get() {\n            return this[_textAlign];\n        },\n        set: function set(textAlign) {\n            this[_textAlign] = textAlign;\n        }\n    }, {\n        key: 'textBaseline',\n        get: function get() {\n            return this[_textBaseline];\n        },\n        set: function set(textBaseline) {\n            this[_textBaseline] = textBaseline;\n        }\n    }]);\n\n    return CanvasDrawingStylesWebgl2D;\n}();\n\nexports.default = CanvasDrawingStylesWebgl2D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/CanvasDrawingStylesWebgl2D.js?");

/***/ }),

/***/ "./github/src/webgl/CanvasRenderingContextWebgl2D.js":
/*!***********************************************************!*\
  !*** ./github/src/webgl/CanvasRenderingContextWebgl2D.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ContextState = __webpack_require__(/*! ./ContextState.js */ \"./github/src/webgl/ContextState.js\");\n\nvar _ContextState2 = _interopRequireDefault(_ContextState);\n\nvar _CanvasDrawingStylesWebgl2D = __webpack_require__(/*! ./CanvasDrawingStylesWebgl2D.js */ \"./github/src/webgl/CanvasDrawingStylesWebgl2D.js\");\n\nvar _CanvasDrawingStylesWebgl2D2 = _interopRequireDefault(_CanvasDrawingStylesWebgl2D);\n\nvar _Path3D = __webpack_require__(/*! ./Path3D.js */ \"./github/src/webgl/Path3D.js\");\n\nvar _Path3D2 = _interopRequireDefault(_Path3D);\n\nvar _SubPath3D = __webpack_require__(/*! ./SubPath3D.js */ \"./github/src/webgl/SubPath3D.js\");\n\nvar _SubPath3D2 = _interopRequireDefault(_SubPath3D);\n\nvar _Color = __webpack_require__(/*! ../utils/Color.js */ \"./github/src/utils/Color.js\");\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _RenderAction = __webpack_require__(/*! ./RenderAction.js */ \"./github/src/webgl/RenderAction.js\");\n\nvar _RenderAction2 = _interopRequireDefault(_RenderAction);\n\nvar _WebGLRender = __webpack_require__(/*! ./WebGLRender.js */ \"./github/src/webgl/WebGLRender.js\");\n\nvar _WebGLRender2 = _interopRequireDefault(_WebGLRender);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./github/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _VerticesData = __webpack_require__(/*! ./VerticesData.js */ \"./github/src/webgl/VerticesData.js\");\n\nvar _VerticesData2 = _interopRequireDefault(_VerticesData);\n\nvar _FragmentData = __webpack_require__(/*! ./FragmentData.js */ \"./github/src/webgl/FragmentData.js\");\n\nvar _FragmentData2 = _interopRequireDefault(_FragmentData);\n\nvar _TransformMatrixData = __webpack_require__(/*! ./TransformMatrixData.js */ \"./github/src/webgl/TransformMatrixData.js\");\n\nvar _TransformMatrixData2 = _interopRequireDefault(_TransformMatrixData);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _canvas = Symbol('对应的Canvas');\nvar _stateStack = Symbol('状态栈');\nvar _stateArray = Symbol('状态数组，记录全部状态');\nvar _pathList = Symbol('路径列表');\nvar _renderActionList = Symbol('绘制动作List');\nvar _subpathCatch = Symbol('子Path缓存');\n\nvar FACE_NORMAL4 = [0, 0, 1, 0];\n\nvar CanvasRenderingContextWebgl2D = function () {\n    function CanvasRenderingContextWebgl2D(canvas, properties) {\n        _classCallCheck(this, CanvasRenderingContextWebgl2D);\n\n        if (properties == null || properties == undefined) properties = [];\n        this[_canvas] = canvas;\n        if (canvas == null || canvas == undefined) throw new Error('canvas can not be undefined or null');\n        this.gl = canvas.getContext('webgl');\n        if (this.gl == undefined) throw new Error('Current canvas doesnt support WebGL');\n        // this.defaultDepth = -canvas.height * 2;\n        var FOV = properties['FOV'] || 20;\n        var t = Math.tan(FOV * Math.PI / 180);\n        this.defaultDepth = -canvas.height / (2 * t);\n        this.maxBufferByteLength = properties['maxMemorySize'] || 1024 * 1024;\n        this[_stateStack] = [];\n        this[_stateArray] = [];\n        this[_pathList] = [];\n        this[_renderActionList] = [];\n        this[_subpathCatch] = [];\n        this.webglRender = new _WebGLRender2.default(this.gl, properties['maxTransformNum'], properties['maxTextureSize'], properties['projectionType'], this.defaultDepth);\n        var maxVertexNumber = this.maxBufferByteLength / 32;\n        this.verticesData = new _VerticesData2.default(maxVertexNumber);\n        // DEBUG :\n        // console.log(maxVertexNumber,this.verticesData.totalByteLength);\n        this.fragmetData = new _FragmentData2.default(maxVertexNumber);\n        this.transformMatrixData = new _TransformMatrixData2.default(maxVertexNumber);\n        this.webglRender.verticesData = this.verticesData;\n        this.webglRender.fragmentData = this.fragmetData;\n        this.webglRender.transformMatrixData = this.transformMatrixData;\n        this.translate(0, 0, this.defaultDepth);\n    }\n\n    _createClass(CanvasRenderingContextWebgl2D, [{\n        key: \"clean\",\n        value: function clean() {\n            this[_pathList].length = 0;\n            this.webglRender.clean();\n        }\n\n        /**\r\n         * 没有实现,只能全部清空\r\n         * @param left\r\n         * @param top\r\n         * @param width\r\n         * @param height\r\n         */\n\n    }, {\n        key: \"clearRect\",\n        value: function clearRect(left, top, width, height) {\n            this.clean();\n        }\n\n        /************** CanvasPathMethods ************************/\n\n        // 没有实现的有这些：\n        // arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n        // arcTo(x1: number, y1: number, x2: number, y2: number, radiusX: number, radiusY: number, rotation: number): void;\n        // bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n        // quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n\n    }, {\n        key: \"beginPath\",\n        value: function beginPath() {\n            this.currentPath.clean();\n        }\n\n        /**\r\n         * 关闭当前Path，下面是规范说明\r\n         * The closePath() method must do nothing if the object's path has no subpaths.\r\n         * Otherwise, it must mark the last subpath as closed,\r\n         * create a new subpath whose first point is the same as the previous subpath's first point,\r\n         * and finally add this new subpath to the path.\r\n         */\n\n    }, {\n        key: \"closePath\",\n        value: function closePath() {\n            // let path = this.currentPath;\n            // if (path.subPathNumber == 0) return;\n            // let lastSubPath = path.lastSubPath;\n            // lastSubPath.close();\n            // let firstPoint = lastSubPath.getPoint(0);\n            // let newSubPath = new SubPath3D(firstPoint);\n            // path.addSubPath(newSubPath);\n\n            var path = this.currentPath;\n            if (path.subPathNumber == 0) return;\n            var lastSubPath = path.lastSubPath;\n            lastSubPath.close();\n            var x = lastSubPath.getPointX(0);\n            var y = lastSubPath.getPointX(0);\n            var z = lastSubPath.getPointX(0);\n            var sid = lastSubPath.getPointStateId(0);\n            var mid = lastSubPath.getPointMatrixId(0);\n            // let firstPoint = lastSubPath.getPoint(0);\n            var newSubPath = new _SubPath3D2.default();\n            newSubPath.addPoint(x, y, z, sid, mid);\n            path.addSubPath(newSubPath);\n        }\n\n        /**\r\n         * 连接某个点x，y，下面是规范说明\r\n         * The lineTo(x, y) method must ensure there is a subpath for (x, y) if the object's path has no subpaths.\r\n         * Otherwise, it must connect the last point in the subpath to the given point (x, y) using a straight line,\r\n         * and must then add the given point (x, y) to the subpath.\r\n         * @param x\r\n         * @param y\r\n         * @param z\r\n         */\n\n    }, {\n        key: \"lineTo\",\n        value: function lineTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n            var currentSubPath = this.currentPath;\n            var lastSubPath = currentSubPath.lastSubPath;\n            var m = currentState.transformMatrix.matrix;\n            var temp = _Mat2.default.multiplyWithVertex(m, [x, y, z, 1]);\n            lastSubPath.addPoint(temp[0], temp[1], temp[2], currentState.id, currentState.transformMatrixId);\n            currentState.fireDirty();\n        }\n\n        /**\r\n         * 规范说明\r\n         * The moveTo(x, y) method must create a new subpath with the specified point as its first (and only) point.\r\n         * When the user agent is to ensure there is a subpath for a coordinate (x, y) on a path,\r\n         * the user agent must check to see if the path has any subpaths,\r\n         * and if it does not, then the user agent must create a new subpath with the point (x, y) as its first\r\n         * (and only) point, as if the moveTo() method had been called.\r\n         * @param x\r\n         * @param y\r\n         * @param z\r\n         */\n\n    }, {\n        key: \"moveTo\",\n        value: function moveTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n            var currentSubPath = this.currentPath;\n            var lastSubPath = currentSubPath.lastSubPath;\n            if (lastSubPath != undefined && lastSubPath.pointsNumber < 2) {\n                //这个subpath只要一个点，就用它作为新的subpath\n                var m = currentState.transformMatrix.matrix;\n                var temp = _Mat2.default.multiplyWithVertex(m, [x, y, z, 1]);\n                lastSubPath.setPoint(0, temp[0], temp[1], temp[2], currentState.id, currentState.transformMatrixId);\n            } else {\n                var subPath = new _SubPath3D2.default();\n                currentSubPath.addSubPath(subPath);\n                this.lineTo(x, y, z);\n            }\n        }\n\n        /**\r\n         * The rect(x, y, w, h) method must create a new subpath containing just the four points\r\n         * (x, y), (x+w, y), (x+w, y+h), (x, y+h), with those four points connected by straight lines,\r\n         * and must then mark the subpath as closed.\r\n         * It must then create a new subpath with the point (x, y) as the only point in the subpath.\r\n         * @param x\r\n         * @param y\r\n         * @param w\r\n         * @param h\r\n         * @param depth 这个参数可选，不给的话就是0\r\n         */\n\n    }, {\n        key: \"rect\",\n        value: function rect(x, y, w, h, depth) {\n            if (depth == undefined) depth = 0;\n            this.moveTo(x, y, depth);\n            this.lineTo(x + w, y, depth);\n            this.lineTo(x + w, y + h, depth);\n            this.lineTo(x, y + h, depth);\n            this.closePath();\n        }\n    }, {\n        key: \"ellipse\",\n        value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n            if (radiusX < 0 || radiusY < 0) throw new Error('半径必须不小于0. Radius should not be smaller than zero. BanJing BiXu BuXiaoYu Ling');\n            if (radiusX == 0 || radiusY == 0) return;\n            if (anticlockwise == undefined) anticlockwise = false;\n\n            var subpath = this.currentPath.lastSubPath;\n            if (subpath == undefined) {\n                subpath = new _SubPath3D2.default();\n                this.currentPath.addSubPath(subpath);\n            }\n\n            startAngle = adjustAngle(startAngle);\n            endAngle = adjustAngle(endAngle);\n\n            if (startAngle > endAngle && !anticlockwise || startAngle < endAngle && anticlockwise) {\n                if (startAngle < 0 || endAngle < 0) {\n                    endAngle -= 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle -= 2 * Math.PI;\n                }\n                if (startAngle > 0 || endAngle > 0) {\n                    endAngle += 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle += 2 * Math.PI;\n                }\n            }\n\n            var realRadius = Math.max(radiusX, radiusY); // 这个值要根据当前缩放算一下\n            var plusAngle = Math.asin(1 / realRadius) * 2;\n            var count = 0;\n            if (anticlockwise) {\n                plusAngle *= -1;\n            }\n\n            for (var radian = startAngle; Math.abs(radian) < Math.abs(endAngle); radian += plusAngle, count++) {\n                var _nextPoint = getPoint(x, y, radiusX, radiusY, radian);\n                this.lineTo(_nextPoint.x, _nextPoint.y);\n            }\n\n            // 连接上最后一个点：\n            var nextPoint = getPoint(x, y, radiusX, radiusY, endAngle);\n            this.lineTo(nextPoint.x, nextPoint.y);\n\n            function adjustAngle(angle) {\n                var PI2 = 2 * Math.PI;\n                var beishu = Math.floor(Math.abs(angle / PI2)) + 1;\n                if (Math.abs(angle) > PI2) beishu++;\n                if (angle < 0 && !anticlockwise) {\n                    angle += beishu * PI2;\n                }\n                if (angle > 0 && anticlockwise) {\n                    angle -= beishu * PI2;\n                }\n                return angle;\n            }\n\n            function getPoint(x, y, radiusX, radiusY, radian) {\n                var cos = Math.cos(radian);\n                var sin = Math.sin(radian);\n                var tan = sin / cos;\n                var x1 = Math.sqrt(radiusY * radiusY * radiusX * radiusX / (radiusY * radiusY + radiusX * radiusX * tan * tan));\n                var y1 = tan * x1;\n                if (cos * x1 < 0) x1 *= -1;\n                if (sin * y1 < 0) y1 *= -1;\n                x1 += x;\n                y1 += y;\n                if (rotation != 0) {\n                    var nx = (x1 - x) * Math.cos(rotation) - (y1 - y) * Math.sin(rotation) + x;\n                    var ny = (y1 - y) * Math.cos(rotation) + (x1 - x) * Math.sin(rotation) + y;\n                    x1 = nx;\n                    y1 = ny;\n                }\n                return { x: x1, y: y1 };\n            }\n        }\n\n        /**\r\n         * 该方法已经在canvas2d下模拟测试通过\r\n         * 规范说明\r\n         * The arc(x, y, radius, startAngle, endAngle, counterclockwise) method draws an arc.\r\n         * If the context has any subpaths, then the method must add a straight line from the last point in\r\n         * the subpath to the start point of the arc. In any case, it must draw the arc between the start point of\r\n         * the arc and the end point of the arc, and add the start and end points of the arc to the subpath.\r\n         * The arc and its start and end points are defined as follows:\r\n         * Consider a circle that has its origin at (x, y), and that has radius radius.\r\n         * The points at startAngle and endAngle this circle's circumference, measured in radians clockwise\r\n         * from the positive x-axis, are the start and end points respectively.\r\n         * If the counterclockwise argument false and endAngle-startAngle is equal to or greater than 2π,\r\n         * or if the counterclockwise argument is true and startAngle-endAngle is equal to or greater than 2π,\r\n         * then the arc is the whole circumference of this circle.\r\n         * Otherwise, the arc is the path along the circumference of this circle from the start point to the end point,\r\n         * going anti-clockwise if the counterclockwise argument is true, and clockwise otherwise.\r\n         * Since the points are on the circle, as opposed to being simply angles from zero,\r\n         * the arc can never cover an angle greater than 2π radians.\r\n         * If the two points are the same, or if the radius is zero, then the arc is defined as being of zero length in both directions.\r\n         * Negative values for radius must cause the implementation to throw an IndexSizeError exception.\r\n         * @param x\r\n         * @param y\r\n         * @param radius\r\n         * @param startAngle\r\n         * @param endAngle\r\n         * @param anticlockwise\r\n         */\n\n    }, {\n        key: \"arc\",\n        value: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n            this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);\n        }\n\n        /*************************** sate **************************/\n\n        /**\r\n         * push state on state stack\r\n         * 将当前状态放入状态栈中\r\n         */\n\n    }, {\n        key: \"save\",\n        value: function save() {\n            // 取出最后一个状态，克隆一个新状态，然后把新状态加入到栈内\n            var currentState = this.currentContextState;\n            var stateClone = currentState.clone();\n            this[_stateStack].push(stateClone);\n            this[_stateArray].push(stateClone);\n            stateClone.id = this[_stateArray].length - 1;\n        }\n\n        /**\r\n         * pop state stack and restore state\r\n         * 将当前状态弹出栈，即恢复之前的状态\r\n         */\n\n    }, {\n        key: \"restore\",\n        value: function restore() {\n            // 弹出栈底状态\n            if (this[_stateStack].length != 0) {\n                this[_stateStack].pop();\n            }\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            this.currentContextState.translate(x, y, z);\n        }\n\n        /**\r\n         * 默认2D是按照Z轴旋转\r\n         * @param radian\r\n         */\n\n    }, {\n        key: \"rotate\",\n        value: function rotate(radian) {\n            this.currentContextState.rotateZ(radian);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            this.currentContextState.rotateX(radian);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            this.currentContextState.rotateY(radian);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            this.currentContextState.scale(scaleX, scaleY, scaleZ);\n        }\n\n        /*********************** 绘制 */ //////////////\n\n    }, {\n        key: \"drawImage\",\n        value: function drawImage(image, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, depth) {\n            depth = depth || 0;\n            var texture = this.webglRender.textureManager.getTexture(image, this.gl, true);\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.textureIndex = texture.index;\n            var left = void 0,\n                top = void 0,\n                right = void 0,\n                bottom = void 0; // 图形对应矩形的四个点\n            var tx = void 0,\n                ty = void 0,\n                tr = void 0,\n                tb = void 0; // 贴图对应的四个点\n            // 只有x,y传入的调用\n            if (arguments.length == 3) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            if (arguments.length == 4) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = srcWidth;\n            }\n            // 有x,y,width,height传入的调用\n            if (arguments.length == 5) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            if (arguments.length == 6) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = dstX;\n            }\n            // 有9个参数传入的调用，即要调整贴图做镖\n            if (arguments.length == 9) {\n                left = dstX;\n                top = dstY;\n                right = dstX + dstWidth;\n                bottom = dstY + dstHeight;\n                tx = texture.x + srcX;\n                tr = texture.x + srcX + srcWidth;\n                ty = texture.y + srcY;\n                tb = texture.y + srcY + srcHeight;\n            }\n            this.beginPath();\n            this.rect(left, top, right - left, bottom - top, depth);\n\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            this[_renderActionList].push(action);\n            var texCoordArray = new Array(4);\n            texCoordArray[0] = [tx, ty]; // 左上角\n            texCoordArray[1] = [tr, ty]; // 右上角\n            texCoordArray[2] = [tr, tb]; // 右下角\n            texCoordArray[3] = [tx, tb]; // 左下角\n            var color = [255, 255, 255]; //白色，在glsl里会成为一个1,1,1的向量，这样就不会改变贴图数据了\n            action.verticesData = this.verticesData;\n            action.fragmentData = this.fragmetData;\n            action.collectVertexDataForFill(pathList, color, opacity, texCoordArray, this.currentFaceVector);\n        }\n    }, {\n        key: \"fill\",\n        value: function fill() {\n            var fillColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.verticesData = this.verticesData;\n            action.fragmentData = this.fragmetData;\n            this[_renderActionList].push(action);\n            action.collectVertexDataForFill(pathList, fillColor, opacity * fillColor[3], [0, 0], this.currentFaceVector);\n        }\n    }, {\n        key: \"fillRect\",\n        value: function fillRect(x, y, w, h) {\n            this.beginPath();\n            this.rect(x, y, w, h);\n            this.fill();\n        }\n\n        /**\r\n         * @deprecated\r\n         */\n\n    }, {\n        key: \"stroke2\",\n        value: function stroke2() {\n            var strokeColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.strokeStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_STROKE);\n            this[_renderActionList].push(action);\n            action.collectVertexData(pathList, strokeColor, opacity * strokeColor[3], [0, 0]);\n        }\n    }, {\n        key: \"stroke\",\n        value: function stroke() {\n            var strokeColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.strokeStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var lineWidth = this.currentContextState.lineWidth;\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.verticesData = this.verticesData;\n            action.fragmentData = this.fragmetData;\n            this[_renderActionList].push(action);\n            action.collectVertexDataForStroke(pathList, strokeColor, opacity * strokeColor[3], [0, 0], lineWidth, this.currentFaceVector);\n        }\n\n        //******************** 扩展接口 *****************************//\n\n    }, {\n        key: \"turnOnLight\",\n        value: function turnOnLight() {\n            this.webglRender.enableLight(true);\n        }\n    }, {\n        key: \"turnOffLight\",\n        value: function turnOffLight() {\n            this.webglRender.enableLight(false);\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(x, y, z) {\n            this.webglRender.setLightPosition(x, y, z);\n        }\n    }, {\n        key: \"fillOrStroke\",\n        value: function fillOrStroke(fillColor, strokeColor) {\n            if (fillColor != undefined) {\n                this.fillStyle = fillColor;\n                this.fill();\n            }\n            if (strokeColor != undefined) {\n                this.strokeStyle = strokeColor;\n                this.stroke();\n            }\n        }\n    }, {\n        key: \"drawRectangle\",\n        value: function drawRectangle(x, y, w, h, fillColor, strokeColor) {\n            this.save();\n            this.beginPath();\n            this.rect(x, y, w, h);\n            this.fillOrStroke(fillColor, strokeColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawEllipse\",\n        value: function drawEllipse(x, y, r1, r2, fillColor, strokeColor, rotation) {\n            this.save();\n            this.beginPath();\n            this.ellipse(x, y, r1, r2, rotation, 0, _Tools2.default.PI2, false);\n            this.closePath();\n            this.fillOrStroke(fillColor, strokeColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawCircle\",\n        value: function drawCircle(x, y, r, fillColor, strokeColor) {\n            this.drawEllipse(x, y, r, r, fillColor, strokeColor, 0);\n        }\n    }, {\n        key: \"draw\",\n        value: function draw() {\n            this.webglRender.initRending();\n            this.webglRender.executeRenderAction2(this[_renderActionList], this[_stateArray]);\n            this[_renderActionList] = [];\n            this[_stateArray] = [];\n            this.verticesData.init();\n            this.fragmetData.init();\n            this.transformMatrixData.init();\n            // debug:\n            // console.log(\"绘制调用次数：\", this.webglRender.DEBUG_DRAW_COUNT);\n        }\n    }, {\n        key: \"currentContextState\",\n        get: function get() {\n            if (this[_stateStack].length == 0) {\n                // 状态栈永远不为空\n                var state = new _ContextState2.default(new _CanvasDrawingStylesWebgl2D2.default());\n                this[_stateStack].push(state);\n                this[_stateArray].push(state);\n                state.id = this[_stateArray].length - 1;\n            }\n            return this[_stateStack][this[_stateStack].length - 1];\n        }\n    }, {\n        key: \"currentPath\",\n        get: function get() {\n            if (this[_pathList].length == 0) {\n                this[_pathList].push(new _Path3D2.default());\n            }\n            return this[_pathList][this[_pathList].length - 1];\n        }\n\n        /**************** 下面是标准接口实现 *************************/\n\n        /**\r\n         * back-reference to the canvas\r\n         * Canvas的回引用\r\n         * @returns {canvas}\r\n         */\n\n    }, {\n        key: \"canvas\",\n        get: function get() {\n            return this[_canvas];\n        }\n    }, {\n        key: \"strokeStyle\",\n        set: function set(stroke) {\n            this.currentContextState.strokeStyle = stroke;\n        },\n        get: function get() {\n            return this.currentContextState.strokeStyle;\n        }\n    }, {\n        key: \"currentFaceVector\",\n        get: function get() {\n            var m = this.currentContextState.transformMatrix.matrix;\n            var n = _Mat2.default.multiplyWithVertex(m, FACE_NORMAL4);\n            return n;\n        }\n    }, {\n        key: \"fillStyle\",\n        set: function set(fill) {\n            this.currentContextState.fillStyle = fill;\n        },\n        get: function get() {\n            return this.currentContextState.fillStyle;\n        }\n    }, {\n        key: \"globalAlpha\",\n        set: function set(alpha) {\n            this.currentContextState.globalAlpha = alpha;\n        },\n        get: function get() {\n            return this.currentContextState.globalAlpha;\n        }\n    }, {\n        key: \"lineWidth\",\n        set: function set(lineWidth) {\n            this.currentContextState.lineWidth = lineWidth;\n        },\n        get: function get() {\n            return this.currentContextState.lineWidth;\n        }\n    }]);\n\n    return CanvasRenderingContextWebgl2D;\n}();\n\nexports.default = CanvasRenderingContextWebgl2D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ }),

/***/ "./github/src/webgl/ContextState.js":
/*!******************************************!*\
  !*** ./github/src/webgl/ContextState.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./github/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _transformMatrix = Symbol('变换矩阵');\n\nvar ContextState = function () {\n    function ContextState(canvasDrawingStyle) {\n        _classCallCheck(this, ContextState);\n\n        this.canvasDrawingStyle = canvasDrawingStyle;\n        this.matrixIndex = 0;\n        this.fillStyle = '#000000';\n        this.strokeStyle = '#000000';\n        this.globalAlpha = 1;\n        this.id = -1;\n        this.matrixArray = [];\n        this.matrixArray.push(_Mat2.default.identity());\n        this.dirty = false;\n    }\n\n    _createClass(ContextState, [{\n        key: \"fireDirty\",\n        value: function fireDirty() {\n            this.dirty = true;\n        }\n    }, {\n        key: \"setTransformMatrix\",\n        value: function setTransformMatrix(value) {\n            var current = this.transformMatrix.matrix;\n            _Mat2.default.copy(value, current);\n        }\n    }, {\n        key: \"checkDirty\",\n        value: function checkDirty() {\n            // 如果当前的矩阵会被应用到某些节点上，则说明这个矩阵脏了，\n            // 一旦变换矩阵就要保存一下，并把这个矩阵的克隆放入数组底\n            if (this.dirty) {\n                var m1 = _Mat2.default.identity();\n                var lastMatrix = this.transformMatrix.matrix;\n                _Mat2.default.copy(lastMatrix, m1);\n                this.matrixArray.push(m1);\n                this.dirty = false;\n            }\n        }\n    }, {\n        key: \"applyTransform\",\n        value: function applyTransform(currentTransformMatrix) {\n            this.checkDirty();\n            var lastMatrix = this.transformMatrix.matrix;\n            _Mat2.default.multiply(lastMatrix, lastMatrix, currentTransformMatrix);\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            if (z === undefined) z = 0;\n            if (_Tools2.default.equals(x, 0) && _Tools2.default.equals(y, 0) && _Tools2.default.equals(z, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.translationMatrix(m, x, y, z);\n            this.applyTransform(m);\n        }\n\n        // 默然是按照z轴旋转\n\n    }, {\n        key: \"rotateZ\",\n        value: function rotateZ(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationZMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationXMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationYMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            if (scaleZ === undefined) scaleZ = 1;\n            if (_Tools2.default.equals(scaleX, 1) && _Tools2.default.equals(scaleY, 1) && _Tools2.default.equals(scaleZ, 1)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.scalingMatrix(m, scaleX, scaleY, scaleZ);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"clone\",\n        value: function clone() {\n            var newState = new ContextState(this.canvasDrawingStyle.clone());\n            newState.fillStyle = this.fillStyle;\n            newState.strokeStyle = this.strokeStyle;\n            newState.globalAlpha = this.globalAlpha;\n            newState.matrixIndex = this.matrixIndex;\n            // 把当前的矩阵作为新矩阵的最后一个\n            newState.setTransformMatrix(this.transformMatrix.matrix);\n            return newState;\n        }\n    }, {\n        key: \"transformMatrixId\",\n        get: function get() {\n            return this.matrixArray.length - 1;\n        }\n    }, {\n        key: \"transformMatrix\",\n        get: function get() {\n            var index = this.matrixArray.length - 1;\n            var m = this.matrixArray[index];\n            return { matrix: m, id: index };\n        }\n    }]);\n\n    return ContextState;\n}();\n\nexports.default = ContextState;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/ContextState.js?");

/***/ }),

/***/ "./github/src/webgl/FragmentData.js":
/*!******************************************!*\
  !*** ./github/src/webgl/FragmentData.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BaseBufferData = __webpack_require__(/*! ./BaseBufferData.js */ \"./github/src/webgl/BaseBufferData.js\");\n\nvar _BaseBufferData2 = _interopRequireDefault(_BaseBufferData);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./github/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SINGLE_DATA_BYTE_LENGTH = 16;\n/**\r\n * 0-2 分别是3位uint8类型的颜色数据\r\n * 3-6: 1位float32的alpha值\r\n * 7-14：两位float32的贴图坐标值\r\n * 15：int8类型的贴图索引值\r\n */\n\nvar FragmentData = function () {\n    function FragmentData(verticesNum) {\n        _classCallCheck(this, FragmentData);\n\n        this.buffer = new ArrayBuffer(verticesNum * SINGLE_DATA_BYTE_LENGTH);\n        this.dv = new DataView(this.buffer);\n        this.currentIndex = 0;\n        this.isLittleEndian = _Tools2.default.littleEndian;\n    }\n\n    _createClass(FragmentData, [{\n        key: \"setFragmentData\",\n        value: function setFragmentData(r, g, b, alpha, u, v, textureIndex, index) {\n            index = index * this.singleDataByteLength;\n            this.dv.setUint8(index, r);\n            this.dv.setUint8(index + 1, g);\n            this.dv.setUint8(index + 2, b);\n            index += 4;\n\n            this.dv.setFloat32(index, alpha, this.isLittleEndian);\n            this.dv.setFloat32(index + 4, u, this.isLittleEndian);\n            this.dv.setFloat32(index + 8, v, this.isLittleEndian);\n            // this.setData(r, index, BaseBufferData.TYPE_UINT8);\n            // this.setData(g, index, BaseBufferData.TYPE_UINT8, 1);\n            // this.setData(b, index, BaseBufferData.TYPE_UINT8, 2);\n            // this.setData(textureIndex, index, BaseBufferData.TYPE_INT8, 3);\n            //\n            // this.setData(alpha, index, BaseBufferData.TYPE_FLOAT32, 4);\n            // this.setData(u, index, BaseBufferData.TYPE_FLOAT32, 8);\n            // this.setData(v, index, BaseBufferData.TYPE_FLOAT32, 12);\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            this.currentIndex = 0;\n        }\n    }, {\n        key: \"resize\",\n        value: function resize(length) {\n            if (length < this.totalByteLength) throw Error('new length should not less than old length');\n            var oldBuffer = this.buffer;\n            this.buffer = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this.buffer);\n            ndv.set(dv1, 0);\n            this.dv = new DataView(this.buffer);\n        }\n    }, {\n        key: \"addFragmentData\",\n        value: function addFragmentData(r, g, b, alpha, u, v, textureIndex) {\n            var index = this.currentIndex;\n            if (index * this.singleDataByteLength >= this.totalByteLength) {\n                this.resize(this.totalByteLength * 2);\n            }\n            this.setFragmentData(r, g, b, alpha, u, v, textureIndex, index);\n            this.currentIndex++;\n        }\n\n        // getTextureIndex(index) {\n        //     let offset = 3;\n        //     return this.getData(index, BaseBufferData.TYPE_INT8, offset);\n        // }\n        //\n        // getColorData(index) {\n        //     let r = this.getData(index, BaseBufferData.TYPE_UINT8);\n        //     let g = this.getData(index, BaseBufferData.TYPE_UINT8, 1);\n        //     let b = this.getData(index, BaseBufferData.TYPE_UINT8, 2);\n        //     return [r, g, b];\n        // }\n        //\n        // getTextureUV(index) {\n        //     let offset = 8;\n        //     let u = this.getData(index, BaseBufferData.TYPE_FLOAT32, offset);\n        //     let v = this.getData(index, BaseBufferData.TYPE_FLOAT32, offset + 4);\n        //     return [u, v];\n        // }\n        //\n        // getAlpha(index) {\n        //     let offset = 4;\n        //     return this.getData(index, BaseBufferData.TYPE_FLOAT32, offset);\n        // }\n\n    }, {\n        key: \"totalByteLength\",\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }, {\n        key: \"singleDataByteLength\",\n        get: function get() {\n            return SINGLE_DATA_BYTE_LENGTH;\n        }\n    }]);\n\n    return FragmentData;\n}();\n\nexports.default = FragmentData;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/FragmentData.js?");

/***/ }),

/***/ "./github/src/webgl/Path3D.js":
/*!************************************!*\
  !*** ./github/src/webgl/Path3D.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Path3D = function () {\n    function Path3D() {\n        _classCallCheck(this, Path3D);\n\n        this.subPathArray = [];\n    }\n\n    _createClass(Path3D, [{\n        key: \"addSubPath\",\n        value: function addSubPath(subPath) {\n            this.subPathArray.push(subPath);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.subPathArray = [];\n        }\n    }, {\n        key: \"subPathNumber\",\n        get: function get() {\n            return this.subPathArray.length;\n        }\n    }, {\n        key: \"lastSubPath\",\n        get: function get() {\n            if (this.subPathNumber != 0) {\n                return this.subPathArray[this.subPathNumber - 1];\n            }\n        }\n    }]);\n\n    return Path3D;\n}();\n\nexports.default = Path3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/Path3D.js?");

/***/ }),

/***/ "./github/src/webgl/RenderAction.js":
/*!******************************************!*\
  !*** ./github/src/webgl/RenderAction.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EarClipping = __webpack_require__(/*! ../geometry/EarClipping.js */ \"./github/src/geometry/EarClipping.js\");\n\nvar _EarClipping2 = _interopRequireDefault(_EarClipping);\n\nvar _LineToRectangle = __webpack_require__(/*! ../geometry/LineToRectangle.js */ \"./github/src/geometry/LineToRectangle.js\");\n\nvar _LineToRectangle2 = _interopRequireDefault(_LineToRectangle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ACTION_STROKE = 0; // stroke动作\nvar ACTION_FILL = 1; // fill动作\n\nvar RenderAction = function () {\n    function RenderAction(type) {\n        _classCallCheck(this, RenderAction);\n\n        this.type = type;\n        this.textureIndex = -1;\n        this.verticesData = null;\n        this.fragmentData = null;\n        this.transformData = null;\n        this.renderPointNumber = 0;\n    }\n\n    _createClass(RenderAction, [{\n        key: \"collectVertexDataForStroke\",\n        value: function collectVertexDataForStroke(pathList, color, opacity, textureCoord, lineWidth, faceDirection) {\n\n            var totalPointsCount = 0;\n            var linesRects = [];\n            var lineToRect = new _LineToRectangle2.default(lineWidth);\n            if (faceDirection != undefined) {\n                lineToRect.faceDirection.x = faceDirection[0];\n                lineToRect.faceDirection.y = faceDirection[1];\n                lineToRect.faceDirection.z = faceDirection[2];\n            }\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    var vertexCount = subPath.pointsNumber;\n                    if (vertexCount < 2) continue;\n                    lineToRect.points = subPath.pointsCoordinateArray;\n                    lineToRect.isClosed = subPath.isClosed;\n                    var result = lineToRect.generatePoints();\n                    totalPointsCount += result.length / 3;\n                    linesRects.push(result);\n                }\n            }\n            this.renderPointNumber += totalPointsCount;\n            if (totalPointsCount == 0) return;\n            // let vertexData = this.getVertexData(totalPointsCount);\n            var testData = this.verticesData;\n            for (var _i = 0; _i < linesRects.length; _i++) {\n                var rects = linesRects[_i];\n                for (var _j = 0; _j < rects.length / 3; _j++) {\n                    var index = _j * 3;\n                    // vertexData.addVertexData2(rects[index], rects[index + 1], rects[index + 2],\n                    //     color, opacity, textureCoord);\n                    if (testData != null) {\n                        testData.addVerticesData(rects[index], rects[index + 1], rects[index + 2], faceDirection[0], faceDirection[1], faceDirection[2]);\n                    }\n                    if (this.fragmentData != null) {\n                        this.fragmentData.addFragmentData(color[0], color[1], color[2], opacity, textureCoord[0], textureCoord[1], -1);\n                    }\n                    if (this.transformData != null) {\n                        // 记录转换矩阵数据\n                        this.transformData.addMatrixIndex(0);\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"collectVertexDataForFill\",\n        value: function collectVertexDataForFill(pathList, color, opacity, textureCoord, faceDirection) {\n            var totalNum = 0;\n            var orgedVertexed = [];\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                if (path.subPathNumber == 0) {\n                    continue;\n                }\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    if (subPath.pointsNumber < 3) continue; // 小于三个无法填充成一个面\n                    var vertexOrg = void 0;\n                    var pointArray = subPath.pointsCoordinateArray;\n                    var pointsNumber = subPath.pointsNumber;\n                    if (pointsNumber == 3) {\n                        vertexOrg = [0, 1, 2];\n                    } else {\n                        if (pointsNumber * 3 == pointArray.length) {\n                            vertexOrg = _EarClipping2.default.earcut(pointArray, null, 3);\n                        } else {\n                            var temp = pointArray.slice(0, pointsNumber * 3);\n                            vertexOrg = _EarClipping2.default.earcut(temp, null, 3);\n                        }\n                    }\n                    totalNum += vertexOrg.length;\n                    orgedVertexed.push(vertexOrg);\n                    // this.organizeVertexForFill(subPath, color, opacity, textureCoord)\n                }\n            }\n            this.renderPointNumber += totalNum;\n            // let vertexData = this.getVertexData(totalNum);\n            if (totalNum == 0) {\n                return;\n            }\n            var index = 0;\n            var testVertiesData = this.verticesData;\n            for (var _i2 = 0; _i2 < pathList.length; _i2++) {\n                var _path = pathList[_i2];\n                if (_path.subPathNumber == 0) {\n                    continue;\n                }\n                for (var _j2 = 0; _j2 < _path.subPathNumber; _j2++, index++) {\n                    var _subPath = _path.subPathArray[_j2];\n                    if (_subPath.pointsNumber < 3) continue; // 小于三个无法填充成一个面\n                    var _vertexOrg = orgedVertexed[index];\n                    for (var k = 0; k < _vertexOrg.length; k++) {\n                        var vertexIndex = _vertexOrg[k];\n                        if (testVertiesData != null) {\n                            testVertiesData.addVerticesData(_subPath.getPointX(vertexIndex), _subPath.getPointY(vertexIndex), _subPath.getPointZ(vertexIndex), faceDirection[0], faceDirection[1], faceDirection[2]);\n                        }\n                        if (this.fragmentData != null) {\n                            var t = undefined;\n                            if (textureCoord[0] instanceof Array) {\n                                t = textureCoord[vertexIndex];\n                            } else {\n                                t = textureCoord;\n                            }\n                            this.fragmentData.addFragmentData(color[0], color[1], color[2], opacity, t[0], t[1], this.textureIndex);\n                        }\n                        if (this.transformData != null) {\n                            // 记录转换矩阵数据\n                            this.transformData.addMatrixIndex(0);\n                        }\n                    }\n                }\n            }\n        }\n    }], [{\n        key: \"ACTION_STROKE\",\n        get: function get() {\n            return ACTION_STROKE;\n        }\n    }, {\n        key: \"ACTION_FILL\",\n        get: function get() {\n            return ACTION_FILL;\n        }\n    }]);\n\n    return RenderAction;\n}();\n\nexports.default = RenderAction;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/RenderAction.js?");

/***/ }),

/***/ "./github/src/webgl/SubPath3D.js":
/*!***************************************!*\
  !*** ./github/src/webgl/SubPath3D.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _currentIndex = Symbol('当前的点所在的索引位置');\nvar _pointsCoordinateArray = Symbol('点的坐标值数组,每三个为一组，分别是x,y,z');\nvar _pointsTransformMatrixArray = Symbol('点的坐标值数组，每两个为一组，分别是stateId,matrixId');\n\nvar SubPath3D = function () {\n    function SubPath3D(startPoint) {\n        _classCallCheck(this, SubPath3D);\n\n        this.pointsArray = [];\n        this[_currentIndex] = 0;\n        this[_pointsCoordinateArray] = [];\n        this[_pointsTransformMatrixArray] = [];\n        if (startPoint != undefined && startPoint != null) {\n            this.pushPoint(startPoint);\n        }\n        this.isClosed = false;\n    }\n\n    _createClass(SubPath3D, [{\n        key: 'init',\n        value: function init() {\n            this.isClosed = false;\n            this[_currentIndex] = 0;\n        }\n    }, {\n        key: 'getPointX',\n        value: function getPointX(index) {\n            index = index * 3;\n            return this[_pointsCoordinateArray][index];\n        }\n    }, {\n        key: 'getPointY',\n        value: function getPointY(index) {\n            index = index * 3;\n            return this[_pointsCoordinateArray][index + 1];\n        }\n    }, {\n        key: 'getPointZ',\n        value: function getPointZ(index) {\n            index = index * 3;\n            return this[_pointsCoordinateArray][index + 2];\n        }\n    }, {\n        key: 'getPointStateId',\n        value: function getPointStateId(index) {\n            index = index * 2;\n            return this[_pointsTransformMatrixArray][index];\n        }\n    }, {\n        key: 'getPointMatrixId',\n        value: function getPointMatrixId(index) {\n            index = index * 2;\n            return this[_pointsTransformMatrixArray][index + 1];\n        }\n    }, {\n        key: 'getPointMatrixData',\n        value: function getPointMatrixData(index) {\n            return [this.getPointStateId(index), this.getPointMatrixId(index)];\n        }\n    }, {\n        key: 'setPoint',\n        value: function setPoint(index, x, y, z, stateId, matrixId) {\n            stateId = stateId || 0;\n            matrixId = matrixId || 0;\n            var sIndex = index * 2;\n            index = index * 3;\n            this[_pointsCoordinateArray][index] = x;\n            this[_pointsCoordinateArray][index + 1] = y;\n            this[_pointsCoordinateArray][index + 2] = z;\n            this[_pointsTransformMatrixArray][sIndex] = stateId;\n            this[_pointsTransformMatrixArray][sIndex + 1] = matrixId;\n        }\n    }, {\n        key: 'addPoint',\n        value: function addPoint(x, y, z, stateId, matrixId) {\n            stateId = stateId || 0;\n            matrixId = matrixId || 0;\n            var index = this[_currentIndex];\n            if (index * 3 >= this[_pointsCoordinateArray].length) {\n                this[_pointsCoordinateArray].push(x);\n                this[_pointsCoordinateArray].push(y);\n                this[_pointsCoordinateArray].push(z);\n            } else {\n                this[_pointsCoordinateArray][index] = x;\n                this[_pointsCoordinateArray][index + 1] = y;\n                this[_pointsCoordinateArray][index + 2] = z;\n            }\n            if (index * 2 >= this[_pointsTransformMatrixArray].length) {\n                this[_pointsTransformMatrixArray].push(stateId);\n                this[_pointsTransformMatrixArray].push(matrixId);\n            } else {\n                this[_pointsTransformMatrixArray][index] = stateId;\n                this[_pointsTransformMatrixArray][index + 1] = matrixId;\n            }\n            this[_currentIndex]++;\n        }\n    }, {\n        key: 'close',\n        value: function close() {\n            this.isClosed = true;\n        }\n\n        /**\r\n         * @deprecated\r\n         * @param index\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: 'getPoint',\n        value: function getPoint(index) {\n            return this.pointsArray[index];\n        }\n    }, {\n        key: 'clean',\n        value: function clean() {\n            this.pointsArray = []; // 这样比length = 0 效率高?\n            this.isClosed = false;\n        }\n\n        /**\r\n         * @deprecated\r\n         * @param point\r\n         */\n\n    }, {\n        key: 'pushPoint',\n        value: function pushPoint(point) {\n            this.pointsArray.push(point);\n        }\n    }, {\n        key: 'pointsCoordinateArray',\n        get: function get() {\n            return this[_pointsCoordinateArray];\n        }\n    }, {\n        key: 'pointsNumber',\n        get: function get() {\n            return this[_currentIndex];\n            // return this.pointsArray.length;\n        }\n    }]);\n\n    return SubPath3D;\n}();\n\nexports.default = SubPath3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/SubPath3D.js?");

/***/ }),

/***/ "./github/src/webgl/TempCanvas.js":
/*!****************************************!*\
  !*** ./github/src/webgl/TempCanvas.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TempCanvas = function TempCanvas() {\n    _classCallCheck(this, TempCanvas);\n\n    return document.createElement('canvas');\n};\n\nexports.default = TempCanvas;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/TempCanvas.js?");

/***/ }),

/***/ "./github/src/webgl/TextureManager.js":
/*!********************************************!*\
  !*** ./github/src/webgl/TextureManager.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TempCanvas = __webpack_require__(/*! ./TempCanvas.js */ \"./github/src/webgl/TempCanvas.js\");\n\nvar _TempCanvas2 = _interopRequireDefault(_TempCanvas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _imageCatch = Symbol('图片缓存');\nvar _textCatch = Symbol('texture缓存');\n\nvar TextureManager = function () {\n    function TextureManager(maxWidth, maxHeight, maxTextureNum, space) {\n        _classCallCheck(this, TextureManager);\n\n        this.maxWidth = maxWidth || 1;\n        this.maxHeight = maxHeight || 1;\n        this.maxTextureNum = maxTextureNum || 1;\n        this[_imageCatch] = [];\n        this[_textCatch] = [];\n        this.imageDataArray = new Array(this.maxTextureNum);\n        this.textureArray = new Array(this.maxTextureNum);\n        this.singleTexture = undefined;\n        this.lastImageData = undefined;\n        this.space = space || 3;\n    }\n\n    _createClass(TextureManager, [{\n        key: 'getTexture',\n        value: function getTexture(image, gl, autoGenerateTexture) {\n            var index = this.imageCatch.indexOf(image);\n            if (index == -1) {\n                return this.registerImageData(image, gl, autoGenerateTexture);\n            } else {\n                return this[_textCatch][index];\n            }\n        }\n    }, {\n        key: 'registerImageData',\n        value: function registerImageData(image, gl, autoGenerateTexture) {\n            if (image == undefined || image == null) {\n                console.error('Image can not be null');\n                return;\n            }\n            if (autoGenerateTexture == undefined) autoGenerateTexture = false;\n            var x = 0;\n            var y = 0;\n            var imgW = image.width;\n            var imgH = image.height;\n            if (imgW > this.maxWidth || imgH > this.maxHeight) {\n                throw new Error('图片大小超过了最大限制：' + this.maxWidth + \" x \" + this.maxHeight);\n                return;\n            }\n            if (this.imageCatch.indexOf(image) == -1) {\n                var canvas = new _TempCanvas2.default(); // 这个地方用个类是为了便于微信小程序的适配\n                var ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                /**\r\n                 * 利用一个离屏canvas的2d context重新绘制一个套image并生成texture\r\n                 * 这个离屏canvas的0,0点是一个黑色的像素点，所以绘制其他image从[0,1]开始\r\n                 */\n                var currentTextureIndex = -1;\n                for (var i = 0; i < this.imageDataArray.length; i++) {\n                    var imageData = this.imageDataArray[i];\n                    if (imageData == undefined) {\n                        imageData = { imageData: undefined, startX: 0, startY: 0, width: 0, height: 0 };\n                        this.imageDataArray[i] = imageData;\n                        canvas.width = image.width;\n                        canvas.height = image.height + 1;\n                        x = 0;\n                        y = 1;\n                        ctx.fillStyle = \"#ffffff\";\n                        ctx.fillRect(0, 0, 1, 1); // 这个像素点是给一般fill用的texture颜色\n                        ctx.drawImage(image, 0, 1);\n                        // 保存当前绘制出来的图像数据\n                        imageData.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        imageData.startX = canvas.width + this.space;\n                        imageData.startY = 1;\n                        imageData.width = canvas.width;\n                        imageData.height = canvas.height;\n                    } else {\n                        var width = image.width;\n                        var height = image.height;\n                        x = imageData.startX;\n                        y = imageData.startY;\n                        if (x + width > this.maxWidth) {\n                            x = 0; // 从下一行开始画\n                            y = imageData.height + this.space;\n                            canvas.width = Math.max(imageData.width, width);\n                            canvas.height = y + height;\n                            console.log('换行');\n                        } else {\n                            canvas.width = Math.max(imageData.width, x + width);\n                            canvas.height = Math.max(imageData.height, y + height);\n                            console.log('不换行');\n                        }\n                        if (y + height > this.maxHeight) {\n                            // 图片已经超过最大可以绘制的空间，换另外一个texture\n                            console.log('图片超过贴图内存最大尺寸');\n                            continue;\n                        }\n                        // 将之前的像素数据放入新的canvas中\n                        ctx.putImageData(imageData.imageData, 0, 0);\n                        ctx.drawImage(image, x, y);\n                        imageData.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        imageData.startX = x + width + this.space;\n                        imageData.startY = y;\n                        imageData.width = canvas.width;\n                        imageData.height = canvas.height;\n                    }\n                    currentTextureIndex = i;\n                    break;\n                }\n\n                if (currentTextureIndex != -1) {\n                    this.imageCatch.push(image);\n                    var textureInfo = { x: x, y: y, width: imgW, height: imgH, index: currentTextureIndex };\n                    if (autoGenerateTexture) {\n                        this.createTexture(gl, currentTextureIndex, canvas);\n                    }\n                    this[_textCatch].push(textureInfo);\n                    return textureInfo;\n                }\n            }\n        }\n    }, {\n        key: 'createAllTexture',\n        value: function createAllTexture(gl) {\n            if (gl == undefined) return;\n            var canvas = new _TempCanvas2.default();\n            var ctx = canvas.getContext('2d');\n            for (var i = 0; i < this.textureArray.length; i++) {\n                this.createTexture(gl, i, canvas);\n            }\n        }\n    }, {\n        key: 'createTexture',\n        value: function createTexture(gl, index, canvas) {\n            if (gl == undefined || index == undefined || index == -1) return;\n            if (canvas == undefined) {\n                canvas = new _TempCanvas2.default();\n            }\n            var ctx = canvas.getContext('2d');\n            var texture = this.textureArray[index];\n            var imgData = this.imageDataArray[index];\n            if (imgData != undefined) {\n                canvas.width = imgData.width;\n                canvas.height = imgData.height;\n                ctx.putImageData(imgData.imageData, 0, 0);\n                if (texture == undefined) {\n                    texture = gl.createTexture();\n                    this.textureArray[index] = texture;\n                }\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                if (TextureManager.isPOT(canvas.width) && TextureManager.isPOT(canvas.height)) {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                } else {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            }\n        }\n    }, {\n        key: 'imageCatch',\n        get: function get() {\n            return this[_imageCatch];\n        }\n    }], [{\n        key: 'isPOT',\n        value: function isPOT(value) {\n            return value > 0 && (value - 1 & value) === 0;\n        }\n    }]);\n\n    return TextureManager;\n}();\n\nexports.default = TextureManager;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/TextureManager.js?");

/***/ }),

/***/ "./github/src/webgl/TransformMatrixData.js":
/*!*************************************************!*\
  !*** ./github/src/webgl/TransformMatrixData.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BaseBufferData2 = __webpack_require__(/*! ./BaseBufferData.js */ \"./github/src/webgl/BaseBufferData.js\");\n\nvar _BaseBufferData3 = _interopRequireDefault(_BaseBufferData2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SINGLE_DATA_BYTE_LENGTH = 4;\n\nvar TransformMatrixData = function (_BaseBufferData) {\n    _inherits(TransformMatrixData, _BaseBufferData);\n\n    function TransformMatrixData(verticesNum) {\n        _classCallCheck(this, TransformMatrixData);\n\n        // 1位是float32类型，矩阵索引\n        return _possibleConstructorReturn(this, (TransformMatrixData.__proto__ || Object.getPrototypeOf(TransformMatrixData)).call(this, verticesNum, SINGLE_DATA_BYTE_LENGTH));\n    }\n\n    _createClass(TransformMatrixData, [{\n        key: \"setMatrixIndex\",\n        value: function setMatrixIndex(mIndex, index) {\n            this.setData(mIndex, index);\n        }\n    }, {\n        key: \"addMatrixIndex\",\n        value: function addMatrixIndex(mIndex) {\n            var index = this.currentIndex;\n            if (index * this.singleDataByteLength >= this.totalByteLength) {\n                this.resize(this.totalByteLength * 2);\n            }\n            this.setMatrixIndex(mIndex, index);\n            this.currentIndex++;\n        }\n    }, {\n        key: \"getMatrixIndex\",\n        value: function getMatrixIndex(index) {\n            return this.getData(index);\n        }\n    }]);\n\n    return TransformMatrixData;\n}(_BaseBufferData3.default);\n\nexports.default = TransformMatrixData;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/TransformMatrixData.js?");

/***/ }),

/***/ "./github/src/webgl/VerticesData.js":
/*!******************************************!*\
  !*** ./github/src/webgl/VerticesData.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _currentIndex = Symbol('当前顶点游标位置');\nvar _dataArray = Symbol('Float32的typed数组');\nvar _arrayBuffer = Symbol('存储顶点数组的buffer');\nvar SINGLE_DATA_BYTE_LENGTH = 32;\n\nvar VerticesData = function () {\n    function VerticesData(verticesNum) {\n        _classCallCheck(this, VerticesData);\n\n        this[_arrayBuffer] = new ArrayBuffer(verticesNum * 4 * 2 * 4);\n        this[_dataArray] = new Float32Array(this[_arrayBuffer]);\n        this[_currentIndex] = 0;\n    }\n\n    _createClass(VerticesData, [{\n        key: 'init',\n        value: function init() {\n            this[_currentIndex] = 0;\n        }\n    }, {\n        key: 'setVerticesData',\n        value: function setVerticesData(x, y, z, nx, ny, nz, index) {\n            index = index * 8;\n            if (index * 4 >= this.totalByteLength) {\n                this.resize(this.totalByteLength * 2);\n            }\n            this[_dataArray][index] = x;\n            this[_dataArray][index + 1] = y;\n            this[_dataArray][index + 2] = z;\n\n            this[_dataArray][index + 4] = nx;\n            this[_dataArray][index + 5] = ny;\n            this[_dataArray][index + 6] = nz;\n        }\n    }, {\n        key: 'getVerticesData',\n        value: function getVerticesData(index) {\n            index = index * 8;\n            var x = this[_dataArray][index];\n            var y = this[_dataArray][index + 1];\n            var z = this[_dataArray][index + 2];\n\n            var nx = this[_dataArray][index + 4];\n            var ny = this[_dataArray][index + 5];\n            var nz = this[_dataArray][index + 6];\n\n            return [x, y, z, nx, ny, nz];\n        }\n    }, {\n        key: 'getVerticesPositionData',\n        value: function getVerticesPositionData(index) {\n            index = index * 8;\n            var x = this[_dataArray][index];\n            var y = this[_dataArray][index + 1];\n            var z = this[_dataArray][index + 2];\n            return [x, y, z];\n        }\n    }, {\n        key: 'getVerticesNormalData',\n        value: function getVerticesNormalData(index) {\n            index = index * 8;\n            var nx = this[_dataArray][index + 4];\n            var ny = this[_dataArray][index + 5];\n            var nz = this[_dataArray][index + 6];\n            return [nx, ny, nz];\n        }\n    }, {\n        key: 'addVerticesData',\n        value: function addVerticesData(x, y, z, nx, ny, nz) {\n            var index = this[_currentIndex];\n            this.setVerticesData(x, y, z, nx, ny, nz, index);\n            this[_currentIndex]++;\n        }\n    }, {\n        key: 'resize',\n        value: function resize(length) {\n            if (length < this.totalByteLength) throw Error('new length should not less than old length');\n            var oldBuffer = this[_arrayBuffer];\n            this[_arrayBuffer] = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            ndv.set(dv1, 0);\n            this[_dataArray] = new Float32Array(this[_arrayBuffer]);\n        }\n    }, {\n        key: 'singleDataByteLength',\n        get: function get() {\n            return SINGLE_DATA_BYTE_LENGTH;\n        }\n    }, {\n        key: 'totalByteLength',\n        get: function get() {\n            return this[_arrayBuffer].byteLength;\n        }\n    }, {\n        key: 'buffer',\n        get: function get() {\n            return this[_arrayBuffer];\n        }\n    }, {\n        key: 'currentIndex',\n        get: function get() {\n            return this[_currentIndex];\n        }\n    }]);\n\n    return VerticesData;\n}();\n\nexports.default = VerticesData;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/VerticesData.js?");

/***/ }),

/***/ "./github/src/webgl/WebGLRender.js":
/*!*****************************************!*\
  !*** ./github/src/webgl/WebGLRender.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TextureManager = __webpack_require__(/*! ./TextureManager.js */ \"./github/src/webgl/TextureManager.js\");\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./github/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar fsSource = \"\\n  precision mediump float;\\n  varying vec4 currentColor;\\n  varying vec2 v_texcoord;\\n  varying vec3 normal;\\n  varying vec3 v_position;\\n  uniform vec2 singleCanvas;\\n  uniform vec3 u_lightPosition;\\n  uniform float enableLight;\\n  uniform sampler2D u_texture;\\n  void main() {\\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\\n        vec4 color = currentColor;\\n        vec3 r_normal = normalize(normal);    \\n        vec3 forward = u_lightPosition - v_position;\\n        vec3 lightLocation = normalize(forward);    \\n        gl_FragColor = color * texture2D(u_texture,coord);\\n        if(enableLight == 1.0){\\n            gl_FragColor.rgb *= abs(dot(r_normal,lightLocation));\\n        }\\n  }\\n  \";\n/**\r\n precision mediump float;\r\n varying vec4 currentColor;\r\n varying vec2 v_texcoord;\r\n uniform vec2 singleCanvas;\r\n uniform sampler2D u_texture;\r\n void main() {\r\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\r\n        vec4 color = currentColor;\r\n        gl_FragColor = color * texture2D(u_texture,coord);\r\n  }\r\n */\n\nvar _program = Symbol('WebGL的program');\nvar _maxTransformMatrixNum = Symbol('转换矩阵变量可用的最大数量');\n\nvar WebGLRender = function () {\n    function WebGLRender(gl, maxTransformNum, textureMaxSize, projectionType, defaultDepth, enableLight) {\n        _classCallCheck(this, WebGLRender);\n\n        this.gl = gl;\n        this.DEBUG_DRAW_COUNT = 0;\n        projectionType = projectionType || 0;\n        textureMaxSize = textureMaxSize || gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n        var maxVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        // 顶点作色器里已经用了一个mat4了，就是4个vector,减去这4个然后除以4就得到可以定义的最大mat4数组\n        maxTransformNum = maxTransformNum || Math.floor((maxVectors - 4) / 4);\n        maxTransformNum = 2;\n        this[_maxTransformMatrixNum] = maxTransformNum;\n        // this[_maxTransformMatrixNum] = 10; // 测试设置\n        this.textureManager = null;\n        this.verticesData = null;\n        this.fragmentData = null;\n        this.transformMatrixData = null;\n        this.lightPosition = new Float32Array(3);\n        this.lightPosition[0] = gl.canvas.clientWidth / 2;\n        this.lightPosition[1] = gl.canvas.clientHeight / 2;\n        this.lightPosition[2] = 0;\n        this.init(projectionType, defaultDepth);\n        this.textureManager.maxHeight = textureMaxSize;\n        this.textureManager.maxWidth = this.textureManager.maxHeight;\n        enableLight = enableLight || false;\n        this.enableLight(enableLight);\n    }\n\n    _createClass(WebGLRender, [{\n        key: \"enableLight\",\n        value: function enableLight(flag) {\n            var value = 0;\n            if (flag) value = 1.0;else value = 0;\n            this.gl.uniform1f(this.shaderInformation.enableLight, value);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.DEBUG_DRAW_COUNT = 0;\n            this.gl.clearColor(0, 0, 0, 0);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n        }\n    }, {\n        key: \"initRending\",\n        value: function initRending() {\n            var gl = this.gl;\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        }\n    }, {\n        key: \"setUniformTransformMatrix\",\n        value: function setUniformTransformMatrix(matrix, id) {\n            var gl = this.gl;\n            gl.uniformMatrix4fv(this.shaderInformation.transformMatrixArray[id], false, matrix);\n        }\n    }, {\n        key: \"prepareWebGLBuffer\",\n        value: function prepareWebGLBuffer() {\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.enableVertexAttribArray(shaderInfo.vertexAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.verticesBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this.verticesData.buffer, gl.DYNAMIC_DRAW);\n\n            var size = 3;\n            var type = gl.FLOAT;\n            var normalize = false;\n            var stride = 32;\n            var offset = 0;\n            gl.vertexAttribPointer(shaderInfo.vertexAttribute, size, type, normalize, stride, offset);\n            //法向量数据：\n            type = gl.FLOAT;\n            size = 3;\n            offset = 16; // 4 * 4;//因为有一个空的float32，所以要多移动4个字节\n            normalize = true; //单位划该向量\n            gl.vertexAttribPointer(shaderInfo.normalAttribute, size, type, normalize, stride, offset);\n\n            gl.enableVertexAttribArray(shaderInfo.colorAttribute);\n            gl.enableVertexAttribArray(shaderInfo.textureCoordAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.fragmentBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this.fragmentData.buffer, gl.DYNAMIC_DRAW);\n\n            type = gl.UNSIGNED_BYTE;\n            stride = this.fragmentData.singleDataByteLength;\n            size = 3;\n            offset = 0;\n            normalize = false;\n            gl.vertexAttribPointer(shaderInfo.colorAttribute, size, type, normalize, stride, offset);\n\n            type = gl.FLOAT;\n            size = 1;\n            offset = 4;\n            gl.vertexAttribPointer(shaderInfo.alphaAttribute, size, type, normalize, stride, offset);\n\n            type = gl.FLOAT;\n            size = 2;\n            offset = 8;\n            gl.vertexAttribPointer(shaderInfo.textureCoordAttribute, size, type, normalize, stride, offset);\n\n            gl.enableVertexAttribArray(shaderInfo.transformMatrixIndex);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.matrixIndexBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this.transformMatrixData.buffer, gl.DYNAMIC_DRAW);\n            type = gl.FLOAT;\n            size = 1;\n            offset = 0;\n            stride = 4;\n            gl.vertexAttribPointer(shaderInfo.transformMatrixIndex, size, type, normalize, stride, offset);\n        }\n    }, {\n        key: \"executeRenderAction2\",\n        value: function executeRenderAction2(actionList, stateArray) {\n            this.prepareWebGLBuffer();\n            var matrixIndex = 1; // 每次绘制都要重新设置矩阵的索引\n            var lastAction = undefined;\n            var startIndex = 0;\n            var rendNumber = 0;\n            for (var i = 0; i < actionList.length; i++) {\n                var currentAction = actionList[i];\n                if (lastAction == undefined) lastAction = currentAction;\n                // 先收集顶点数据，顶点的矩阵在下一步再设置\n                if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                    this.renderVertices(startIndex, rendNumber, lastAction.textureIndex);\n                    lastAction = currentAction;\n                    startIndex = rendNumber;\n                    rendNumber = 0;\n                }\n                if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n                    lastAction = currentAction;\n                }\n                rendNumber += currentAction.renderPointNumber;\n            }\n\n            if (lastAction != undefined) {\n                this.renderVertices(startIndex, rendNumber, lastAction.textureIndex);\n            }\n        }\n    }, {\n        key: \"renderVertices\",\n        value: function renderVertices(startIndex, renderPointNumber, textureIndex) {\n            if (renderPointNumber == 0) {\n                return;\n            }\n            var gl = this.gl;\n            this.gl.uniform3f(this.shaderInformation.lightPosition, this.lightPosition[0], this.lightPosition[1], this.lightPosition[2]);\n            this.configTexture(textureIndex);\n            gl.drawArrays(gl.TRIANGLES, startIndex, renderPointNumber);\n            this.DEBUG_DRAW_COUNT++;\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(x, y, z) {\n            this.lightPosition[0] = x;\n            this.lightPosition[1] = y;\n            this.lightPosition[2] = z;\n        }\n    }, {\n        key: \"configTexture\",\n        value: function configTexture(textureIndex) {\n            if (textureIndex == undefined) textureIndex = -1;\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.uniform1i(shaderInfo.textureLocation, 0);\n            var texture = void 0;\n            var c = void 0;\n            if (textureIndex == -1) {\n                texture = shaderInfo.blackTexture;\n                c = { width: 1, height: 1 };\n            } else {\n                texture = this.textureManager.textureArray[textureIndex];\n                c = this.textureManager.imageDataArray[textureIndex];\n            }\n            gl.uniform2f(shaderInfo.singleCanvas, c.width, c.height);\n            gl.activeTexture(gl.TEXTURE0 + 0);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n        }\n    }, {\n        key: \"createShaderProgram\",\n        value: function createShaderProgram() {\n            var gl = this.gl;\n            var vertexShader = this.loadShader(gl.VERTEX_SHADER, this.getVertexShaderSource(this.maxTransformMatrixNum));\n            var fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);\n\n            // 创建Shader程序，一个是顶点shader一个是片段shader\n            var shaderProgram = gl.createProgram();\n            gl.attachShader(shaderProgram, vertexShader);\n            gl.attachShader(shaderProgram, fragmentShader);\n            gl.linkProgram(shaderProgram);\n\n            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n                console.error('无法初始化Program: ' + gl.getProgramInfoLog(shaderProgram));\n                gl.deleteProgram(shaderProgram);\n                return null;\n            }\n            gl.useProgram(shaderProgram);\n            return shaderProgram;\n        }\n    }, {\n        key: \"init\",\n        value: function init(projectionType, defaultDepth) {\n            var gl = this.gl;\n            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n            this.gl.enable(this.gl.BLEND);\n            this.gl.disable(this.gl.DEPTH_TEST);\n            this[_program] = this.createShaderProgram();\n            var program = this[_program];\n            this.shaderInformation = this.initShaderInformation(program);\n            this.textureManager = new _TextureManager2.default(801, 801, 10, 4);\n            // 设置透视矩阵\n            var m1 = void 0;\n            var near = 1;\n            if (projectionType == 0) {\n                m1 = _Mat2.default.orthoProjection(0, 0, gl.canvas.width, gl.canvas.height, near, Math.abs(defaultDepth * 2));\n            } else {\n                var theta = Math.atan2(gl.canvas.clientHeight / 2, Math.abs(defaultDepth));\n                m1 = _Mat2.default.perspective3(theta * 2, gl.canvas.clientWidth, gl.canvas.clientHeight, near, Math.abs(defaultDepth * 2));\n            }\n            gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m1);\n        }\n    }, {\n        key: \"setPerspective\",\n        value: function setPerspective(viewAngel, near, far) {\n            var aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight;\n            var m = _Mat2.default.perspective2(0, 0, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight, near, far);\n            m = _Mat2.default.perspective(viewAngel, aspect, near, far);\n            m = _Mat2.default.perspective3(viewAngel, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight, near, far);\n            this.gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m);\n        }\n    }, {\n        key: \"initShaderInformation\",\n        value: function initShaderInformation(program) {\n            var gl = this.gl;\n\n            var textureCoordAttribute = gl.getAttribLocation(program, \"u_texCoord\");\n            gl.enableVertexAttribArray(textureCoordAttribute);\n\n            var vertexAttribute = gl.getAttribLocation(program, \"a_position\");\n            gl.enableVertexAttribArray(vertexAttribute);\n\n            var normalAttribute = gl.getAttribLocation(program, \"a_normal\");\n            gl.enableVertexAttribArray(normalAttribute);\n\n            var transformMatrixIndex = gl.getAttribLocation(program, \"transform_matrix_index\");\n            gl.enableVertexAttribArray(transformMatrixIndex);\n\n            var colorAttribute = gl.getAttribLocation(program, 'color');\n            gl.enableVertexAttribArray(colorAttribute);\n\n            var alphaAttribute = gl.getAttribLocation(program, 'alpha');\n            gl.enableVertexAttribArray(alphaAttribute);\n\n            // 转化矩阵全局变量\n            var perspectiveMatrix = gl.getUniformLocation(program, \"perspective_matrix\");\n            var transformMatrixArray = new Array(this.maxTransformMatrixNum);\n            for (var i = 0; i < transformMatrixArray.length; i++) {\n                transformMatrixArray[i] = gl.getUniformLocation(program, \"transform_matrix_array[\" + i + \"]\");\n            }\n            var rawMatrix = _Mat2.default.identity();\n            // 为了配合预设的深度\n            // Mat4.translationMatrix(rawMatrix, 0, 0, -Math.max(gl.canvas.clientWidth, gl.canvas.clientHeight));\n            gl.uniformMatrix4fv(transformMatrixArray[0], false, rawMatrix);\n            var singleCanvas = gl.getUniformLocation(program, \"singleCanvas\");\n            var lightPosition = gl.getUniformLocation(program, \"u_lightPosition\");\n            var enableLight = gl.getUniformLocation(program, \"enableLight\");\n            var textureLocation = gl.getUniformLocation(program, \"u_texture\");\n            // 创建数据缓存\n            var verticesBuffer = gl.createBuffer();\n            var matrixIndexBuffer = gl.createBuffer();\n            var fragmentBuffer = gl.createBuffer();\n\n            var blackTexture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, blackTexture);\n            var blackPixel = new Uint8Array([255, 255, 255, 255]);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, blackPixel);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            return {\n                vertexAttribute: vertexAttribute,\n                normalAttribute: normalAttribute,\n                colorAttribute: colorAttribute,\n                alphaAttribute: alphaAttribute,\n                textureCoordAttribute: textureCoordAttribute,\n                verticesBuffer: verticesBuffer,\n                fragmentBuffer: fragmentBuffer,\n                matrixIndexBuffer: matrixIndexBuffer,\n                perspectiveMatrix: perspectiveMatrix,\n                transformMatrixArray: transformMatrixArray,\n                transformMatrixIndex: transformMatrixIndex,\n                singleCanvas: singleCanvas,\n                textureLocation: textureLocation,\n                blackTexture: blackTexture,\n                lightPosition: lightPosition,\n                enableLight: enableLight,\n                webgl: gl\n            };\n        }\n\n        /**\r\n         * 创建作色器\r\n         * @param type 着色器类型\r\n         * @param source 代码源\r\n         * @returns {*} Shader对象\r\n         */\n\n    }, {\n        key: \"loadShader\",\n        value: function loadShader(type, source) {\n            var gl = this.gl;\n            var shader = gl.createShader(type);\n            // 把GLSL代码给shader\n            gl.shaderSource(shader, source);\n            // 编译着色器程序\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error('着色器编译错误: ' + gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        /**\r\n           这样我看得更清楚些\r\n           attribute vec4 color;\r\n         attribute vec4 a_position;\r\n         attribute vec2 u_texCoord;\r\n         attribute vec2 transform_matrix_index;\r\n         varying vec2 v_texcoord;\r\n         varying vec4 currentColor;\r\n         uniform mat4 texture_matrix;\r\n         uniform mat4 perspective_matrix;\r\n         uniform mat4 transform_matrix_array[transformMatrixCount];\r\n         void main() {\r\n                // v_texcoord = u_texCoord;\r\n                vec4 new_position = transform_matrix_array[0] * a_position;\r\n                vec4 finalPosition = perspective_matrix* new_position;\r\n                currentColor = vec4 (color.xyz/255.0,color.w/100.0);\r\n                gl_Position = finalPosition;\r\n        };\r\n           * @param transformMatrixCount\r\n         * @returns {string}\r\n         */\n\n    }, {\n        key: \"getVertexShaderSource\",\n        value: function getVertexShaderSource(transformMatrixCount) {\n            var vsSource = ' attribute vec3 color;\\n' + '     attribute vec4 a_position;\\n' + '     attribute vec3 a_normal;\\n' + '     attribute float alpha;\\n' + '     attribute vec2 u_texCoord;\\n' + '     varying vec3 v_position;\\n' + '     attribute float transform_matrix_index;\\n' + '     varying vec2 v_texcoord;\\n' + '     varying vec4 currentColor;\\n' + '     varying vec3 normal;\\n' + '     uniform mat4 perspective_matrix;\\n' + '     uniform mat4 transform_matrix_array[' + transformMatrixCount + '];\\n' + '     void main() {\\n' + '            normal = a_normal;\\n' + '            vec4 yuandian = vec4(0,0,0,1);\\n' + '            v_texcoord = u_texCoord;\\n' + '            vec4 new_position = transform_matrix_array[int(transform_matrix_index)] * a_position;\\n' + '            v_position = vec3(new_position.xyz);\\n' + '            vec4 finalPosition = perspective_matrix* new_position;\\n' + '            currentColor = vec4 (color.xyz/255.0,alpha);\\n' + '            gl_Position = finalPosition;\\n' + '    }';\n            return vsSource;\n        }\n    }, {\n        key: \"maxTransformMatrixNum\",\n        get: function get() {\n            return this[_maxTransformMatrixNum];\n        }\n    }]);\n\n    return WebGLRender;\n}();\n\nexports.default = WebGLRender;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./github/src/webgl/WebGLRender.js?");

/***/ }),

/***/ 0:
/*!*****************************************************************!*\
  !*** multi ./github/src/webgl/CanvasRenderingContextWebgl2D.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./github/src/webgl/CanvasRenderingContextWebgl2D.js */\"./github/src/webgl/CanvasRenderingContextWebgl2D.js\");\n\n\n//# sourceURL=webpack://tielifa.WebGL2D/multi_./github/src/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ })

/******/ })["default"];
});