(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["WebGL2D"] = factory();
	else
		root["tielifa"] = root["tielifa"] || {}, root["tielifa"]["WebGL2D"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./public/src/geometry/EarClipping.js":
/*!********************************************!*\
  !*** ./public/src/geometry/EarClipping.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Node = __webpack_require__(/*! ./Node.js */ \"./public/src/geometry/Node.js\");\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EarClipping = function () {\n    function EarClipping() {\n        _classCallCheck(this, EarClipping);\n    }\n\n    _createClass(EarClipping, null, [{\n        key: 'earcut',\n        value: function earcut(data, holeIndices, dim) {\n\n            dim = dim || 2;\n\n            var hasHoles = holeIndices && holeIndices.length,\n                outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n                outerNode = this.linkedList(data, 0, outerLen, dim, true),\n                triangles = [];\n\n            if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n            var minX = void 0,\n                minY = void 0,\n                maxX = void 0,\n                maxY = void 0,\n                x = void 0,\n                y = void 0,\n                invSize = void 0;\n\n            if (hasHoles) outerNode = this.eliminateHoles(data, holeIndices, outerNode, dim);\n\n            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n            if (data.length > 80 * dim) {\n                minX = maxX = data[0];\n                minY = maxY = data[1];\n\n                for (var i = dim; i < outerLen; i += dim) {\n                    x = data[i];\n                    y = data[i + 1];\n                    if (x < minX) minX = x;\n                    if (y < minY) minY = y;\n                    if (x > maxX) maxX = x;\n                    if (y > maxY) maxY = y;\n                }\n\n                // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n                invSize = Math.max(maxX - minX, maxY - minY);\n                invSize = invSize !== 0 ? 1 / invSize : 0;\n            }\n\n            this.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n            return triangles;\n        }\n\n        // create a circular doubly linked list from polygon points in the specified winding order\n\n    }, {\n        key: 'linkedList',\n        value: function linkedList(data, start, end, dim, clockwise) {\n            var i, last;\n\n            if (clockwise === EarClipping.signedArea(data, start, end, dim) > 0) {\n                for (i = start; i < end; i += dim) {\n                    last = this.insertNode(i, data[i], data[i + 1], last);\n                }\n            } else {\n                for (i = end - dim; i >= start; i -= dim) {\n                    last = this.insertNode(i, data[i], data[i + 1], last);\n                }\n            }\n\n            if (last && EarClipping.equals(last, last.next)) {\n                this.removeNode(last);\n                last = last.next;\n            }\n\n            return last;\n        }\n\n        // eliminate colinear or duplicate points\n\n    }, {\n        key: 'filterPoints',\n        value: function filterPoints(start, end) {\n            if (!start) return start;\n            if (!end) end = start;\n\n            var p = start,\n                again;\n            do {\n                again = false;\n\n                if (!p.steiner && (EarClipping.equals(p, p.next) || EarClipping.area(p.prev, p, p.next) === 0)) {\n                    this.removeNode(p);\n                    p = end = p.prev;\n                    if (p === p.next) break;\n                    again = true;\n                } else {\n                    p = p.next;\n                }\n            } while (again || p !== end);\n\n            return end;\n        }\n\n        // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n    }, {\n        key: 'earcutLinked',\n        value: function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n            if (!ear) return;\n\n            // interlink polygon nodes in z-order\n            if (!pass && invSize) this.indexCurve(ear, minX, minY, invSize);\n\n            var stop = ear,\n                prev,\n                next;\n\n            // iterate through ears, slicing them one by one\n            while (ear.prev !== ear.next) {\n                prev = ear.prev;\n                next = ear.next;\n\n                if (invSize ? this.isEarHashed(ear, minX, minY, invSize) : this.isEar(ear)) {\n                    // cut off the triangle\n                    triangles.push(prev.i / dim);\n                    triangles.push(ear.i / dim);\n                    triangles.push(next.i / dim);\n\n                    this.removeNode(ear);\n\n                    // skipping the next vertex leads to less sliver triangles\n                    ear = next.next;\n                    stop = next.next;\n\n                    continue;\n                }\n\n                ear = next;\n\n                // if we looped through the whole remaining polygon and can't find any more ears\n                if (ear === stop) {\n                    // try filtering points and slicing again\n                    if (!pass) {\n                        this.earcutLinked(this.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                        // if this didn't work, try curing all small self-intersections locally\n                    } else if (pass === 1) {\n                        ear = this.cureLocalIntersections(ear, triangles, dim);\n                        this.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                        // as a last resort, try splitting the remaining polygon into two\n                    } else if (pass === 2) {\n                        this.splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // check whether a polygon node forms a valid ear with adjacent nodes\n\n    }, {\n        key: 'isEar',\n        value: function isEar(ear) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // now make sure we don't have other points inside the potential ear\n            var p = ear.next.next;\n\n            while (p !== ear.prev) {\n                if (this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.next;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'isEarHashed',\n        value: function isEarHashed(ear, minX, minY, invSize) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // triangle bbox; min & max are calculated like this for speed\n            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n                minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n                maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n                maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n\n            // z-order range for the current triangle bbox;\n            var minZ = this.zOrder(minTX, minTY, minX, minY, invSize),\n                maxZ = this.zOrder(maxTX, maxTY, minX, minY, invSize);\n\n            var p = ear.prevZ,\n                n = ear.nextZ;\n\n            // look for points inside the triangle in both directions\n            while (p && p.z >= minZ && n && n.z <= maxZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            // look for remaining points in decreasing z-order\n            while (p && p.z >= minZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n            }\n\n            // look for remaining points in increasing z-order\n            while (n && n.z <= maxZ) {\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            return true;\n        }\n\n        // go through all polygon nodes and cure small local self-intersections\n\n    }, {\n        key: 'cureLocalIntersections',\n        value: function cureLocalIntersections(start, triangles, dim) {\n            var p = start;\n            do {\n                var a = p.prev,\n                    b = p.next.next;\n\n                if (!EarClipping.equals(a, b) && this.intersects(a, p, p.next, b) && this.locallyInside(a, b) && this.locallyInside(b, a)) {\n\n                    triangles.push(a.i / dim);\n                    triangles.push(p.i / dim);\n                    triangles.push(b.i / dim);\n\n                    // remove two nodes involved\n                    this.removeNode(p);\n                    this.removeNode(p.next);\n\n                    p = start = b;\n                }\n                p = p.next;\n            } while (p !== start);\n\n            return p;\n        }\n\n        // try splitting polygon into two and triangulate them independently\n\n    }, {\n        key: 'splitEarcut',\n        value: function splitEarcut(start, triangles, dim, minX, minY, invSize) {\n            // look for a valid diagonal that divides the polygon into two\n            var a = start;\n            do {\n                var b = a.next.next;\n                while (b !== a.prev) {\n                    if (a.i !== b.i && this.isValidDiagonal(a, b)) {\n                        // split the polygon in two by the diagonal\n                        var c = this.splitPolygon(a, b);\n\n                        // filter colinear points around the cuts\n                        a = this.filterPoints(a, a.next);\n                        c = this.filterPoints(c, c.next);\n\n                        // run earcut on each half\n                        this.earcutLinked(a, triangles, dim, minX, minY, invSize);\n                        this.earcutLinked(c, triangles, dim, minX, minY, invSize);\n                        return;\n                    }\n                    b = b.next;\n                }\n                a = a.next;\n            } while (a !== start);\n        }\n\n        // link every hole into the outer loop, producing a single-ring polygon without holes\n\n    }, {\n        key: 'eliminateHoles',\n        value: function eliminateHoles(data, holeIndices, outerNode, dim) {\n            var queue = [],\n                i,\n                len,\n                start,\n                end,\n                list;\n\n            for (i = 0, len = holeIndices.length; i < len; i++) {\n                start = holeIndices[i] * dim;\n                end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                list = this.linkedList(data, start, end, dim, false);\n                if (list === list.next) list.steiner = true;\n                queue.push(this.getLeftmost(list));\n            }\n\n            queue.sort(this.compareX);\n\n            // process holes from left to right\n            for (i = 0; i < queue.length; i++) {\n                this.eliminateHole(queue[i], outerNode);\n                outerNode = this.filterPoints(outerNode, outerNode.next);\n            }\n\n            return outerNode;\n        }\n    }, {\n        key: 'compareX',\n        value: function compareX(a, b) {\n            return a.x - b.x;\n        }\n\n        // find a bridge between vertices that connects hole with an outer ring and and link it\n\n    }, {\n        key: 'eliminateHole',\n        value: function eliminateHole(hole, outerNode) {\n            outerNode = this.findHoleBridge(hole, outerNode);\n            if (outerNode) {\n                var b = this.splitPolygon(outerNode, hole);\n                this.filterPoints(b, b.next);\n            }\n        }\n\n        // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n    }, {\n        key: 'findHoleBridge',\n        value: function findHoleBridge(hole, outerNode) {\n            var p = outerNode,\n                hx = hole.x,\n                hy = hole.y,\n                qx = -Infinity,\n                m;\n\n            // find a segment intersected by a ray from the hole's leftmost point to the left;\n            // segment's endpoint with lesser x will be potential connection point\n            do {\n                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                    if (x <= hx && x > qx) {\n                        qx = x;\n                        if (x === hx) {\n                            if (hy === p.y) return p;\n                            if (hy === p.next.y) return p.next;\n                        }\n                        m = p.x < p.next.x ? p : p.next;\n                    }\n                }\n                p = p.next;\n            } while (p !== outerNode);\n\n            if (!m) return null;\n\n            if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n            // look for points inside the triangle of hole point, segment intersection and endpoint;\n            // if there are no points found, we have a valid connection;\n            // otherwise choose the point of the minimum angle with the ray as connection point\n\n            var stop = m,\n                mx = m.x,\n                my = m.y,\n                tanMin = Infinity,\n                tan;\n\n            p = m.next;\n\n            while (p !== stop) {\n                if (hx >= p.x && p.x >= mx && hx !== p.x && this.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n                    tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                    if ((tan < tanMin || tan === tanMin && p.x > m.x) && this.locallyInside(p, hole)) {\n                        m = p;\n                        tanMin = tan;\n                    }\n                }\n\n                p = p.next;\n            }\n\n            return m;\n        }\n\n        // interlink polygon nodes in z-order\n\n    }, {\n        key: 'indexCurve',\n        value: function indexCurve(start, minX, minY, invSize) {\n            var p = start;\n            do {\n                if (p.z === null) p.z = this.zOrder(p.x, p.y, minX, minY, invSize);\n                p.prevZ = p.prev;\n                p.nextZ = p.next;\n                p = p.next;\n            } while (p !== start);\n\n            p.prevZ.nextZ = null;\n            p.prevZ = null;\n\n            this.sortLinked(p);\n        }\n\n        // Simon Tatham's linked list merge sort algorithm\n        // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n    }, {\n        key: 'sortLinked',\n        value: function sortLinked(list) {\n            var i,\n                p,\n                q,\n                e,\n                tail,\n                numMerges,\n                pSize,\n                qSize,\n                inSize = 1;\n\n            do {\n                p = list;\n                list = null;\n                tail = null;\n                numMerges = 0;\n\n                while (p) {\n                    numMerges++;\n                    q = p;\n                    pSize = 0;\n                    for (i = 0; i < inSize; i++) {\n                        pSize++;\n                        q = q.nextZ;\n                        if (!q) break;\n                    }\n                    qSize = inSize;\n\n                    while (pSize > 0 || qSize > 0 && q) {\n\n                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                            e = p;\n                            p = p.nextZ;\n                            pSize--;\n                        } else {\n                            e = q;\n                            q = q.nextZ;\n                            qSize--;\n                        }\n\n                        if (tail) tail.nextZ = e;else list = e;\n\n                        e.prevZ = tail;\n                        tail = e;\n                    }\n\n                    p = q;\n                }\n\n                tail.nextZ = null;\n                inSize *= 2;\n            } while (numMerges > 1);\n\n            return list;\n        }\n\n        // z-order of a point given coords and inverse of the longer side of data bbox\n\n    }, {\n        key: 'zOrder',\n        value: function zOrder(x, y, minX, minY, invSize) {\n            // coords are transformed into non-negative 15-bit integer range\n            x = 32767 * (x - minX) * invSize;\n            y = 32767 * (y - minY) * invSize;\n\n            x = (x | x << 8) & 0x00FF00FF;\n            x = (x | x << 4) & 0x0F0F0F0F;\n            x = (x | x << 2) & 0x33333333;\n            x = (x | x << 1) & 0x55555555;\n\n            y = (y | y << 8) & 0x00FF00FF;\n            y = (y | y << 4) & 0x0F0F0F0F;\n            y = (y | y << 2) & 0x33333333;\n            y = (y | y << 1) & 0x55555555;\n\n            return x | y << 1;\n        }\n\n        // find the leftmost node of a polygon ring\n\n    }, {\n        key: 'getLeftmost',\n        value: function getLeftmost(start) {\n            var p = start,\n                leftmost = start;\n            do {\n                if (p.x < leftmost.x) leftmost = p;\n                p = p.next;\n            } while (p !== start);\n\n            return leftmost;\n        }\n\n        // check if a point lies within a convex triangle\n\n    }, {\n        key: 'pointInTriangle',\n        value: function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n        }\n\n        // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n    }, {\n        key: 'isValidDiagonal',\n        value: function isValidDiagonal(a, b) {\n            return a.next.i !== b.i && a.prev.i !== b.i && !this.intersectsPolygon(a, b) && this.locallyInside(a, b) && this.locallyInside(b, a) && this.middleInside(a, b);\n        }\n\n        // signed area of a triangle\n\n    }, {\n        key: 'area',\n        value: function area(p, q, r) {\n            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        }\n\n        // check if two points are equal\n\n    }, {\n        key: 'equals',\n        value: function equals(p1, p2) {\n            return p1.x === p2.x && p1.y === p2.y;\n        }\n\n        // check if two segments intersect\n\n    }, {\n        key: 'intersects',\n        value: function intersects(p1, q1, p2, q2) {\n            if (EarClipping.equals(p1, q1) && EarClipping.equals(p2, q2) || EarClipping.equals(p1, q2) && EarClipping.equals(p2, q1)) return true;\n            return EarClipping.area(p1, q1, p2) > 0 !== EarClipping.area(p1, q1, q2) > 0 && EarClipping.area(p2, q2, p1) > 0 !== EarClipping.area(p2, q2, q1) > 0;\n        }\n\n        // check if a polygon diagonal intersects any polygon segments\n\n    }, {\n        key: 'intersectsPolygon',\n        value: function intersectsPolygon(a, b) {\n            var p = a;\n            do {\n                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && this.intersects(p, p.next, a, b)) return true;\n                p = p.next;\n            } while (p !== a);\n\n            return false;\n        }\n\n        // check if a polygon diagonal is locally inside the polygon\n\n    }, {\n        key: 'locallyInside',\n        value: function locallyInside(a, b) {\n            return area(a.prev, a, a.next) < 0 ? EarClipping.area(a, b, a.next) >= 0 && EarClipping.area(a, a.prev, b) >= 0 : EarClipping.area(a, b, a.prev) < 0 || EarClipping.area(a, a.next, b) < 0;\n        }\n\n        // check if the middle point of a polygon diagonal is inside the polygon\n\n    }, {\n        key: 'middleInside',\n        value: function middleInside(a, b) {\n            var p = a,\n                inside = false,\n                px = (a.x + b.x) / 2,\n                py = (a.y + b.y) / 2;\n            do {\n                if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n                p = p.next;\n            } while (p !== a);\n\n            return inside;\n        }\n\n        // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n        // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n    }, {\n        key: 'splitPolygon',\n        value: function splitPolygon(a, b) {\n            var a2 = new _Node2.default(a.i, a.x, a.y),\n                b2 = new _Node2.default(b.i, b.x, b.y),\n                an = a.next,\n                bp = b.prev;\n\n            a.next = b;\n            b.prev = a;\n\n            a2.next = an;\n            an.prev = a2;\n\n            b2.next = a2;\n            a2.prev = b2;\n\n            bp.next = b2;\n            b2.prev = bp;\n\n            return b2;\n        }\n\n        // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n    }, {\n        key: 'insertNode',\n        value: function insertNode(i, x, y, last) {\n            var p = new _Node2.default(i, x, y);\n\n            if (!last) {\n                p.prev = p;\n                p.next = p;\n            } else {\n                p.next = last.next;\n                p.prev = last;\n                last.next.prev = p;\n                last.next = p;\n            }\n            return p;\n        }\n    }, {\n        key: 'removeNode',\n        value: function removeNode(p) {\n            p.next.prev = p.prev;\n            p.prev.next = p.next;\n\n            if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n            if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n        }\n    }, {\n        key: 'signedArea',\n        value: function signedArea(data, start, end, dim) {\n            var sum = 0;\n            for (var i = start, j = end - dim; i < end; i += dim) {\n                sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n                j = i;\n            }\n            return sum;\n        }\n\n        // return a percentage difference between the polygon area and its triangulation area;\n        // used to verify correctness of triangulation\n\n    }, {\n        key: 'deviation',\n        value: function deviation(data, holeIndices, dim, triangles) {\n            var hasHoles = holeIndices && holeIndices.length;\n            var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n            var polygonArea = Math.abs(this.signedArea(data, 0, outerLen, dim));\n            if (hasHoles) {\n                for (var i = 0, len = holeIndices.length; i < len; i++) {\n                    var start = holeIndices[i] * dim;\n                    var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n                    polygonArea -= Math.abs(this.signedArea(data, start, end, dim));\n                }\n            }\n\n            var trianglesArea = 0;\n            for (i = 0; i < triangles.length; i += 3) {\n                var a = triangles[i] * dim;\n                var b = triangles[i + 1] * dim;\n                var c = triangles[i + 2] * dim;\n                trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n            }\n\n            return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n        }\n    }, {\n        key: 'flatten',\n\n\n        // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form EarClipping accepts\n        value: function flatten(data) {\n            var dim = data[0][0].length,\n                result = { vertices: [], holes: [], dimensions: dim },\n                holeIndex = 0;\n\n            for (var i = 0; i < data.length; i++) {\n                for (var j = 0; j < data[i].length; j++) {\n                    for (var d = 0; d < dim; d++) {\n                        result.vertices.push(data[i][j][d]);\n                    }\n                }\n                if (i > 0) {\n                    holeIndex += data[i - 1].length;\n                    result.holes.push(holeIndex);\n                }\n            }\n            return result;\n        }\n    }]);\n\n    return EarClipping;\n}();\n\nexports.default = EarClipping;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/geometry/EarClipping.js?");

/***/ }),

/***/ "./public/src/geometry/Node.js":
/*!*************************************!*\
  !*** ./public/src/geometry/Node.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function Node(i, x, y) {\n        _classCallCheck(this, Node);\n\n        // vertex index in coordinates array\n        this.i = i;\n\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n\n        // previous and next vertex nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n\n        // z-order curve value\n        this.z = null;\n\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n\n        // indicates whether this is a steiner point\n        this.steiner = false;\n};\n\nexports.default = Node;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/geometry/Node.js?");

/***/ }),

/***/ "./public/src/math/Mat4.js":
/*!*********************************!*\
  !*** ./public/src/math/Mat4.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./public/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp_mat4 = undefined;\n\nvar Mat4 = function () {\n    function Mat4() {\n        _classCallCheck(this, Mat4);\n    }\n\n    _createClass(Mat4, null, [{\n        key: \"perspective\",\n        value: function perspective(fieldOfViewInRadians, aspect, near, far) {\n            var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\n            var rangeInv = 1.0 / (near - far);\n            var m = this.identity();\n            m[0] = f / aspect;\n            m[5] = f;\n            m[10] = (near + far) * rangeInv;\n            m[11] = -1;\n            m[14] = near * far * rangeInv * 2;\n\n            return [f / aspect, 0, 0, 0, 0, f, 0, 0, 0, 0, (near + far) * rangeInv, -1, 0, 0, near * far * rangeInv * 2, 0];\n            // return m;\n        }\n    }, {\n        key: \"orthoProjection\",\n        value: function orthoProjection(left, top, right, bottom, near, far) {\n            return new Float32Array([2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, 2 / (near - far), 0, (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1]);\n        }\n    }, {\n        key: \"copy\",\n        value: function copy(from, to) {\n            to[0] = from[0];\n            to[1] = from[1];\n            to[2] = from[2];\n            to[3] = from[3];\n            to[4] = from[4];\n            to[5] = from[5];\n            to[6] = from[6];\n            to[7] = from[7];\n            to[8] = from[8];\n            to[9] = from[9];\n            to[10] = from[10];\n            to[11] = from[11];\n            to[12] = from[12];\n            to[13] = from[13];\n            to[14] = from[14];\n            to[15] = from[15];\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(a, b) {\n            var a0 = a[0],\n                a1 = a[1],\n                a2 = a[2],\n                a3 = a[3];\n            var a4 = a[4],\n                a5 = a[5],\n                a6 = a[6],\n                a7 = a[7];\n            var a8 = a[8],\n                a9 = a[9],\n                a10 = a[10],\n                a11 = a[11];\n            var a12 = a[12],\n                a13 = a[13],\n                a14 = a[14],\n                a15 = a[15];\n\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            var b4 = b[4],\n                b5 = b[5],\n                b6 = b[6],\n                b7 = b[7];\n            var b8 = b[8],\n                b9 = b[9],\n                b10 = b[10],\n                b11 = b[11];\n            var b12 = b[12],\n                b13 = b[13],\n                b14 = b[14],\n                b15 = b[15];\n\n            return Math.abs(a0 - b0) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _Tools2.default.EPSILON.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n        }\n    }, {\n        key: \"exactEquals\",\n        value: function exactEquals(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n        }\n    }, {\n        key: \"projection\",\n        value: function projection(width, height, depth) {\n            var m = this.identity();\n            m[0] = 2 / width;\n            m[5] = -2 / height;\n            m[10] = 2 / depth;\n            m[12] = -1;\n            m[13] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identity\",\n        value: function identity() {\n            var m = new Float32Array(16);\n            m[0] = 1;\n            m[5] = 1;\n            m[10] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identityMatrix\",\n        value: function identityMatrix(matrix) {\n            var m = matrix;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translationMatrix\",\n        value: function translationMatrix(out, tx, ty, tz) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translation\",\n        value: function translation(tx, ty, tz) {\n            var m = this.identity();\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            return m;\n        }\n    }, {\n        key: \"rotationZMatrix\",\n        value: function rotationZMatrix(out, radian) {\n            var m = out;\n            m[2] = 0;\n            m[3] = 0;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n        }\n    }, {\n        key: \"rotationZ\",\n        value: function rotationZ(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationXMatrix\",\n        value: function rotationXMatrix(out, radian) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationX\",\n        value: function rotationX(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationYMatrix\",\n        value: function rotationYMatrix(out, radian) {\n            var m = out;\n            m[1] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[9] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationY\",\n        value: function rotationY(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"scalingMatrix\",\n        value: function scalingMatrix(out, sx, sy, sz) {\n            var m = out;\n            m[0] = sx;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = sy;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = sz;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"scaling\",\n        value: function scaling(sx, sy, sz) {\n            var m = this.identity();\n            m[0] = sx;\n            m[5] = sy;\n            m[10] = sz;\n            return m;\n        }\n    }, {\n        key: \"multiplyWithVertex\",\n        value: function multiplyWithVertex(matrix, vertex) {\n            var a00 = matrix[0];\n            var a01 = matrix[1];\n            var a02 = matrix[2];\n            var a03 = matrix[3];\n            var a10 = matrix[4];\n            var a11 = matrix[5];\n            var a12 = matrix[6];\n            var a13 = matrix[7];\n            var a20 = matrix[8];\n            var a21 = matrix[9];\n            var a22 = matrix[10];\n            var a23 = matrix[11];\n            var a30 = matrix[12];\n            var a31 = matrix[13];\n            var a32 = matrix[14];\n            var a33 = matrix[15];\n\n            var b00 = vertex[0];\n            var b01 = vertex[1];\n            var b02 = vertex[2];\n            var b03 = vertex[3];\n            if (b02 == undefined) b02 = 0;\n            if (b03 == undefined) b03 = 1;\n\n            return [b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30, b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31, b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32, b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33];\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(out, a, b) {\n            var a00 = a[0],\n                a01 = a[1],\n                a02 = a[2],\n                a03 = a[3];\n            var a10 = a[4],\n                a11 = a[5],\n                a12 = a[6],\n                a13 = a[7];\n            var a20 = a[8],\n                a21 = a[9],\n                a22 = a[10],\n                a23 = a[11];\n            var a30 = a[12],\n                a31 = a[13],\n                a32 = a[14],\n                a33 = a[15];\n\n            // Cache only the current line of the second matrix\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[4];\n            b1 = b[5];\n            b2 = b[6];\n            b3 = b[7];\n            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[8];\n            b1 = b[9];\n            b2 = b[10];\n            b3 = b[11];\n            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[12];\n            b1 = b[13];\n            b2 = b[14];\n            b3 = b[15];\n            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            return out;\n        }\n    }, {\n        key: \"TEMP_MAT4\",\n        get: function get() {\n            if (temp_mat4 == undefined) {\n                temp_mat4 = [Mat4.identity(), Mat4.identity(), Mat4.identity(), Mat4.identity()];\n            }\n            return temp_mat4;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return _Tools2.default.EPSILON;\n        }\n    }]);\n\n    return Mat4;\n}();\n\nexports.default = Mat4;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/math/Mat4.js?");

/***/ }),

/***/ "./public/src/utils/Color.js":
/*!***********************************!*\
  !*** ./public/src/utils/Color.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar colorKeywords = {\n    aliceblue: \"#f0f8ff\",\n    antiquewhite: \"#faebd7\",\n    aqua: \"#00ffff\",\n    aquamarine: \"#7fffd4\",\n    azure: \"#f0ffff\",\n    beige: \"#f5f5dc\",\n    bisque: \"#ffe4c4\",\n    black: \"#000000\",\n    blanchedalmond: \"#ffebcd\",\n    blue: \"#0000ff\",\n    blueviolet: \"#8a2be2\",\n    brown: \"#a52a2a\",\n    burlywood: \"#deb887\",\n    cadetblue: \"#5f9ea0\",\n    chartreuse: \"#7fff00\",\n    chocolate: \"#d2691e\",\n    coral: \"#ff7f50\",\n    cornflowerblue: \"#6495ed\",\n    cornsilk: \"#fff8dc\",\n    crimson: \"#dc143c\",\n    cyan: \"#00ffff\",\n    darkblue: \"#00008b\",\n    darkcyan: \"#008b8b\",\n    darkgoldenrod: \"#b8860b\",\n    darkgray: \"#a9a9a9\",\n    darkgreen: \"#006400\",\n    darkkhaki: \"#bdb76b\",\n    darkmagenta: \"#8b008b\",\n    darkolivegreen: \"#556b2f\",\n    darkorange: \"#ff8c00\",\n    darkorchid: \"#9932cc\",\n    darkred: \"#8b0000\",\n    darksalmon: \"#e9967a\",\n    darkseagreen: \"#8fbc8f\",\n    darkslateblue: \"#483d8b\",\n    darkslategray: \"#2f4f4f\",\n    darkturquoise: \"#00ced1\",\n    darkviolet: \"#9400d3\",\n    deeppink: \"#ff1493\",\n    deepskyblue: \"#00bfff\",\n    dimgray: \"#696969\",\n    dodgerblue: \"#1e90ff\",\n    firebrick: \"#b22222\",\n    floralwhite: \"#fffaf0\",\n    forestgreen: \"#228b22\",\n    fuchsia: \"#ff00ff\",\n    gainsboro: \"#dcdcdc\",\n    ghostwhite: \"#f8f8ff\",\n    gold: \"#ffd700\",\n    goldenrod: \"#daa520\",\n    gray: \"#808080\",\n    green: \"#008000\",\n    greenyellow: \"#adff2f\",\n    grey: \"#808080\",\n    honeydew: \"#f0fff0\",\n    hotpink: \"#ff69b4\",\n    indianred: \"#cd5c5c\",\n    indigo: \"#4b0082\",\n    ivory: \"#fffff0\",\n    khaki: \"#f0e68c\",\n    lavender: \"#e6e6fa\",\n    lavenderblush: \"#fff0f5\",\n    lawngreen: \"#7cfc00\",\n    lemonchiffon: \"#fffacd\",\n    lightblue: \"#add8e6\",\n    lightcoral: \"#f08080\",\n    lightcyan: \"#e0ffff\",\n    lightgoldenrodyellow: \"#fafad2\",\n    lightgrey: \"#d3d3d3\",\n    lightgreen: \"#90ee90\",\n    lightpink: \"#ffb6c1\",\n    lightsalmon: \"#ffa07a\",\n    lightseagreen: \"#20b2aa\",\n    lightskyblue: \"#87cefa\",\n    lightslategray: \"#778899\",\n    lightsteelblue: \"#b0c4de\",\n    lightyellow: \"#ffffe0\",\n    lime: \"#00ff00\",\n    limegreen: \"#32cd32\",\n    linen: \"#faf0e6\",\n    magenta: \"#ff00ff\",\n    maroon: \"#800000\",\n    mediumaquamarine: \"#66cdaa\",\n    mediumblue: \"#0000cd\",\n    mediumorchid: \"#ba55d3\",\n    mediumpurple: \"#9370d8\",\n    mediumseagreen: \"#3cb371\",\n    mediumslateblue: \"#7b68ee\",\n    mediumspringgreen: \"#00fa9a\",\n    mediumturquoise: \"#48d1cc\",\n    mediumvioletred: \"#c71585\",\n    midnightblue: \"#191970\",\n    mintcream: \"#f5fffa\",\n    mistyrose: \"#ffe4e1\",\n    moccasin: \"#ffe4b5\",\n    navajowhite: \"#ffdead\",\n    navy: \"#000080\",\n    oldlace: \"#fdf5e6\",\n    olive: \"#808000\",\n    olivedrab: \"#6b8e23\",\n    orange: \"#ffa500\",\n    orangered: \"#ff4500\",\n    orchid: \"#da70d6\",\n    palegoldenrod: \"#eee8aa\",\n    palegreen: \"#98fb98\",\n    paleturquoise: \"#afeeee\",\n    palevioletred: \"#d87093\",\n    papayawhip: \"#ffefd5\",\n    peachpuff: \"#ffdab9\",\n    peru: \"#cd853f\",\n    pink: \"#ffc0cb\",\n    plum: \"#dda0dd\",\n    powderblue: \"#b0e0e6\",\n    purple: \"#800080\",\n    red: \"#ff0000\",\n    rosybrown: \"#bc8f8f\",\n    royalblue: \"#4169e1\",\n    saddlebrown: \"#8b4513\",\n    salmon: \"#fa8072\",\n    sandybrown: \"#f4a460\",\n    seagreen: \"#2e8b57\",\n    seashell: \"#fff5ee\",\n    sienna: \"#a0522d\",\n    silver: \"#c0c0c0\",\n    skyblue: \"#87ceeb\",\n    slateblue: \"#6a5acd\",\n    slategray: \"#708090\",\n    snow: \"#fffafa\",\n    springgreen: \"#00ff7f\",\n    steelblue: \"#4682b4\",\n    tan: \"#d2b48c\",\n    teal: \"#008080\",\n    thistle: \"#d8bfd8\",\n    tomato: \"#ff6347\",\n    turquoise: \"#40e0d0\",\n    violet: \"#ee82ee\",\n    wheat: \"#f5deb3\",\n    white: \"#ffffff\",\n    whitesmoke: \"#f5f5f5\",\n    yellow: \"#ffff00\",\n    yellowgreen: \"#9acd32\"\n};\n\nvar _instance = void 0;\n\nvar Color = function () {\n    function Color() {\n        _classCallCheck(this, Color);\n\n        if (_instance) {\n            return _instance;\n        }\n        _instance = this;\n        this.colorMap = {};\n        for (var key in colorKeywords) {\n            var v = colorKeywords[key];\n            var vec3 = this.convertHEXToVet3(v);\n            this.colorMap[v] = vec3;\n        }\n    }\n\n    _createClass(Color, [{\n        key: \"convertStringToColor\",\n        value: function convertStringToColor(string) {\n            string = string.toLowerCase();\n            if (Color.isHEXString(string)) {\n                var vec3 = this.colorMap[string];\n                if (vec3 != undefined) return vec3;\n                vec3 = this.convertHEXToVet3(string);\n                this.colorMap[string] = vec3;\n                return vec3;\n            }\n            return this.convertKeywordToVet3(string);\n        }\n    }, {\n        key: \"convertKeywordToVet3\",\n        value: function convertKeywordToVet3(keyword) {\n            var value = Color.ColorMap[keyword];\n            if (value) {\n                var vec3 = this.colorMap[value];\n                if (vec3 != undefined) return vec3;\n                vec3 = this.convertHEXToVet3(value);\n                this.colorMap[value] = vec3;\n                return vec3;\n            }\n            return [0, 0, 0];\n        }\n    }, {\n        key: \"convertHEXToVet3\",\n        value: function convertHEXToVet3(hex) {\n            var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n            var r = parseInt(result[1], 16);\n            var g = parseInt(result[2], 16);\n            var b = parseInt(result[3], 16);\n            return [r, g, b];\n        }\n    }], [{\n        key: \"getInstance\",\n        value: function getInstance() {\n            if (!_instance) {\n                _instance = new Color();\n            }\n            return _instance;\n        }\n    }, {\n        key: \"isHEXString\",\n        value: function isHEXString(string) {\n            if (string) {\n                if (string.length == 7 && string.indexOf('#') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: \"ColorMap\",\n        get: function get() {\n            return colorKeywords;\n        }\n    }]);\n\n    return Color;\n}();\n\nexports.default = Color;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/utils/Color.js?");

/***/ }),

/***/ "./public/src/utils/Tools.js":
/*!***********************************!*\
  !*** ./public/src/utils/Tools.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EPSILON = 0.00001;\nvar PI2 = Math.PI * 2;\n\nvar Tools = function () {\n    function Tools() {\n        _classCallCheck(this, Tools);\n\n        this.instance = null;\n    }\n\n    _createClass(Tools, null, [{\n        key: \"equals\",\n        value: function equals(a, b) {\n            // return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n            return Math.abs(a - b) <= EPSILON;\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance(point1, point2) {\n            var dx = point1.x - point2.x;\n            var dy = point1.y - point2.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        // static collisionResponse(v1, m1, v2, m2, n, e) {\n        //     if (e == undefined) e = 1; // 恢复系数默认为1\n        //     let m1d = undefined;\n        //     let m2d = undefined;\n        //     if (m1 == Infinity) {\n        //         m2d = 1;\n        //         m1d = 0;\n        //     }\n        //     if (m2 == Infinity) {\n        //         m2d = 0;\n        //         m1d = 1;\n        //     }\n        //     if (m1d == undefined && m2d == undefined) {\n        //         m1d = 1 / m1;\n        //         m2d = 1 / m2;\n        //     }\n        //     let up = 0 - (1 + e);\n        //     let v12 = Vector2.TEMP_VECTORS[0];\n        //     v12.x = v1.x - v2.x;\n        //     v12.y = v1.y - v2.y;\n        //     up = up * Vector2.dot(v12, n);\n        //     let tempVector = v12;// {x: n.x, y: n.y};\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, (m1d + m2d));\n        //     let down = Vector2.dot(n, tempVector);\n        //     let j = up / down;\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m1d);\n        //     let newV1 = {x: 0, y: 0};\n        //     Vector2.add(newV1, v1, tempVector);\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m2d);\n        //     let newV2 = {x: 0, y: 0};\n        //     Vector2.sub(newV2, v2, tempVector);\n        //\n        //     return {newV1: newV1, newV2: newV2};\n        // }\n        //\n        //\n        // getProjectionPointOnLine(point, linePoint1, linePoint2) {\n        //     let p = point; // 线外一点p\n        //     let a = linePoint1; // 线上端点a\n        //     let b = linePoint2; // 线上端点b\n        //     let ap = new Vector2(p.x - a.x, p.y - a.y);\n        //     let ab = new Vector2(b.x - a.x, b.y - a.y);\n        //     let abN = Vector2.normalize(ab, ab);//计算出ab的单位向量\n        //     let compAP = Vector2.dot(ap, abN);//ap在ab上分量\n        //     abN.multiply(compAP); //ap在ab上的投影,返回值就是abN\n        //     let p0 = {x: 0, y: 0};\n        //     Vector2.plus(p0, a, abN);\n        //     return p0;\n        // }\n\n    }, {\n        key: \"clamp\",\n        value: function clamp(value, min, max) {\n            if (value > max) {\n                return max;\n            }\n            if (value < min) {\n                return min;\n            }\n            return value;\n        }\n    }, {\n        key: \"getInsance\",\n        value: function getInsance() {\n            if (this.instance == null) {\n                this.instance = new Tools();\n            }\n            return this.instance;\n        }\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(bounds1, bounds2) {\n            var a = bounds1;\n            var b = bounds2;\n            return a.left <= b.right && a.right >= b.left && a.bottom >= b.top && a.top <= b.bottom;\n        }\n    }, {\n        key: \"isHit\",\n        value: function isHit(rect1, rect2) {\n            var result = false;\n            var x = rect1.left;\n            var y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left + rect1.width;\n            y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n\n            x = rect1.left + rect1.width;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            if (!result) {\n                x = rect2.left;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left + rect2.width;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n\n                x = rect2.left + rect2.width;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n            }\n            return result;\n        }\n    }, {\n        key: \"isInTheRect\",\n        value: function isInTheRect(x, y, rect) {\n            var fx = rect.left;\n            var fy = rect.top;\n            var currentWidth = rect.width;\n            var currentHeight = rect.height;\n            if (x > fx && x < fx + currentWidth && y > fy && y < fy + currentHeight) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: \"PI2\",\n        get: function get() {\n            return PI2;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return EPSILON;\n        }\n    }]);\n\n    return Tools;\n}();\n\nexports.default = Tools;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/utils/Tools.js?");

/***/ }),

/***/ "./public/src/webgl/CanvasDrawingStylesWebgl2D.js":
/*!********************************************************!*\
  !*** ./public/src/webgl/CanvasDrawingStylesWebgl2D.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _lineWidth = Symbol('线宽度,默认1');\nvar _lineCap = Symbol('线连接样式，\"butt\", \"round\", \"square\" (默认: \"butt\")');\nvar _lineJoin = Symbol('线连接样式，\"round\", \"bevel\", \"miter\" (默认: \"miter\")');\nvar _miterLimit = Symbol('默认10');\n\nvar _font = Symbol('文字字体大小等，默认\"10px sans-serif\"');\nvar _textAlign = Symbol('文字对齐,\"start\", \"end\", \"left\", \"right\", \"center\" (默认: \"start\")');\nvar _textBaseline = Symbol('文字纵向对齐，\"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\" (默认: \"alphabetic\")');\n\nvar CanvasDrawingStylesWebgl2D = function () {\n    function CanvasDrawingStylesWebgl2D() {\n        _classCallCheck(this, CanvasDrawingStylesWebgl2D);\n\n        this[_lineWidth] = 1;\n        this[_lineCap] = \"butt\";\n        this[_lineJoin] = \"miter\";\n        this[_miterLimit] = 10;\n        this.font = '10px sans-serif';\n        this.textAlign = 'start';\n        this.textBaseline = 'alphabetic';\n    }\n\n    // line caps/joins\n\n\n    _createClass(CanvasDrawingStylesWebgl2D, [{\n        key: 'clone',\n        value: function clone() {\n            var c = new CanvasDrawingStylesWebgl2D();\n            c.textBaseline = this.textBaseline;\n            c.textAlign = this.textAlign;\n            c.font = this.font;\n            c.lineCap = this.lineCap;\n            c.lineJoin = this.lineJoin;\n            c.lineWidth = this.lineWidth;\n            return c;\n        }\n    }, {\n        key: 'lineWidth',\n        get: function get() {\n            return this[_lineWidth];\n        },\n        set: function set(lineWidth) {\n            this[_lineWidth] = lineWidth;\n        }\n    }, {\n        key: 'lineCap',\n        get: function get() {\n            return this[_lineCap];\n        },\n        set: function set(lineCap) {\n            this[_lineCap] = lineCap;\n        }\n    }, {\n        key: 'lineJoin',\n        get: function get() {\n            return this[_lineJoin];\n        },\n        set: function set(lineJoin) {\n            this[_lineJoin] = lineJoin;\n        }\n    }, {\n        key: 'miterLimit',\n        get: function get() {\n            return this[_miterLimit];\n        },\n        set: function set(miterLimit) {\n            this[_miterLimit] = miterLimit;\n        }\n\n        // 没有实现的：\n        // dashed lines\n        // void setLineDash(sequence<unrestricted double> segments); // (default: empty)\n        // sequence<unrestricted double> getLineDash();\n        // attribute unrestricted double lineDashOffset;\n\n\n        // text\n\n    }, {\n        key: 'font',\n        get: function get() {\n            return this[_font];\n        },\n        set: function set(font) {\n            this[_font] = font;\n        }\n    }, {\n        key: 'textAlign',\n        get: function get() {\n            return this[_textAlign];\n        },\n        set: function set(textAlign) {\n            this[_textAlign] = textAlign;\n        }\n    }, {\n        key: 'textBaseline',\n        get: function get() {\n            return this[_textBaseline];\n        },\n        set: function set(textBaseline) {\n            this[_textBaseline] = textBaseline;\n        }\n    }]);\n\n    return CanvasDrawingStylesWebgl2D;\n}();\n\nexports.default = CanvasDrawingStylesWebgl2D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/CanvasDrawingStylesWebgl2D.js?");

/***/ }),

/***/ "./public/src/webgl/CanvasRenderingContextWebgl2D.js":
/*!***********************************************************!*\
  !*** ./public/src/webgl/CanvasRenderingContextWebgl2D.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ContextState = __webpack_require__(/*! ./ContextState.js */ \"./public/src/webgl/ContextState.js\");\n\nvar _ContextState2 = _interopRequireDefault(_ContextState);\n\nvar _CanvasDrawingStylesWebgl2D = __webpack_require__(/*! ./CanvasDrawingStylesWebgl2D.js */ \"./public/src/webgl/CanvasDrawingStylesWebgl2D.js\");\n\nvar _CanvasDrawingStylesWebgl2D2 = _interopRequireDefault(_CanvasDrawingStylesWebgl2D);\n\nvar _Path3D = __webpack_require__(/*! ./Path3D.js */ \"./public/src/webgl/Path3D.js\");\n\nvar _Path3D2 = _interopRequireDefault(_Path3D);\n\nvar _Point3D = __webpack_require__(/*! ./Point3D.js */ \"./public/src/webgl/Point3D.js\");\n\nvar _Point3D2 = _interopRequireDefault(_Point3D);\n\nvar _SubPath3D = __webpack_require__(/*! ./SubPath3D.js */ \"./public/src/webgl/SubPath3D.js\");\n\nvar _SubPath3D2 = _interopRequireDefault(_SubPath3D);\n\nvar _Color = __webpack_require__(/*! ../utils/Color.js */ \"./public/src/utils/Color.js\");\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _RenderAction = __webpack_require__(/*! ./RenderAction.js */ \"./public/src/webgl/RenderAction.js\");\n\nvar _RenderAction2 = _interopRequireDefault(_RenderAction);\n\nvar _WebGLRender = __webpack_require__(/*! ./WebGLRender.js */ \"./public/src/webgl/WebGLRender.js\");\n\nvar _WebGLRender2 = _interopRequireDefault(_WebGLRender);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./public/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _canvas = Symbol('对应的Canvas');\nvar _stateStack = Symbol('状态栈');\nvar _stateArray = Symbol('状态数组，记录全部状态');\nvar _pathList = Symbol('路径列表');\nvar _renderActionList = Symbol('绘制动作List');\n\nvar CanvasRenderingContextWebgl2D = function () {\n    function CanvasRenderingContextWebgl2D(canvas, properties) {\n        _classCallCheck(this, CanvasRenderingContextWebgl2D);\n\n        if (properties == null || properties == undefined) properties = [];\n        this[_canvas] = canvas;\n        if (canvas == null || canvas == undefined) throw new Error('TempCanvas can not be undefined or null');\n        this.gl = canvas.getContext('webgl');\n        if (this.gl == undefined) throw new Error('Current canvas doesnt support WebGL');\n        this[_stateStack] = [];\n        this[_stateArray] = [];\n        this[_pathList] = [];\n        this[_renderActionList] = [];\n        this.webglRender = new _WebGLRender2.default(this.gl);\n    }\n\n    // getRenderAction(type) {\n    //     if (this[_renderActionList].length == 0) {\n    //         let action = new RenderAction(type);\n    //         this[_renderActionList].push(action);\n    //         return action;\n    //     } else {\n    //         let lastRender = this[_renderActionList][this[_renderActionList].length - 1];\n    //         if (lastRender.type == type) {\n    //             return lastRender;\n    //         } else {\n    //             let action = new RenderAction(type);\n    //             this[_renderActionList].push(action);\n    //             return action;\n    //         }\n    //     }\n    // }\n\n    _createClass(CanvasRenderingContextWebgl2D, [{\n        key: \"clean\",\n        value: function clean() {\n            this[_pathList].length = 0;\n            this.webglRender.clean();\n        }\n\n        /**\r\n         * 没有实现,只能全部清空\r\n         * @param left\r\n         * @param top\r\n         * @param width\r\n         * @param height\r\n         */\n\n    }, {\n        key: \"clearRect\",\n        value: function clearRect(left, top, width, height) {\n            this.clean();\n        }\n\n        /************** CanvasPathMethods ************************/\n\n        // 没有实现的有这些：\n        // arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): void;\n        // arcTo(x1: number, y1: number, x2: number, y2: number, radiusX: number, radiusY: number, rotation: number): void;\n        // bezierCurveTo(cp1x: number, cp1y: number, cp2x: number, cp2y: number, x: number, y: number): void;\n        // quadraticCurveTo(cpx: number, cpy: number, x: number, y: number): void;\n\n    }, {\n        key: \"beginPath\",\n        value: function beginPath() {\n            this.currentPath.clean();\n        }\n\n        /**\r\n         * 关闭当前Path，下面是规范说明\r\n         * The closePath() method must do nothing if the object's path has no subpaths.\r\n         * Otherwise, it must mark the last subpath as closed,\r\n         * create a new subpath whose first point is the same as the previous subpath's first point,\r\n         * and finally add this new subpath to the path.\r\n         */\n\n    }, {\n        key: \"closePath\",\n        value: function closePath() {\n            var path = this.currentPath;\n            if (path.subPathNumber == 0) return;\n            var lastSubPath = path.lastSubPath;\n            lastSubPath.close();\n            var firstPoint = lastSubPath.getPoint(0);\n            var newSubPath = new _SubPath3D2.default(firstPoint);\n            path.addSubPath(newSubPath);\n        }\n\n        /**\r\n         * 连接某个点x，y，下面是规范说明\r\n         * The lineTo(x, y) method must ensure there is a subpath for (x, y) if the object's path has no subpaths.\r\n         * Otherwise, it must connect the last point in the subpath to the given point (x, y) using a straight line,\r\n         * and must then add the given point (x, y) to the subpath.\r\n         * @param x\r\n         * @param y\r\n         * @param z\r\n         */\n\n    }, {\n        key: \"lineTo\",\n        value: function lineTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n            var currentSubPath = this.currentPath;\n            var lastSubPath = currentSubPath.lastSubPath;\n            var point = new _Point3D2.default(x, y, z);\n            point.contextStateIndex = currentState.id;\n            point.transformMatrixIndex = currentState.transformMatrixId;\n            currentState.fireDirty();\n            lastSubPath.pushPoint(point);\n        }\n\n        /**\r\n         * 规范说明\r\n         * The moveTo(x, y) method must create a new subpath with the specified point as its first (and only) point.\r\n         * When the user agent is to ensure there is a subpath for a coordinate (x, y) on a path,\r\n         * the user agent must check to see if the path has any subpaths,\r\n         * and if it does not, then the user agent must create a new subpath with the point (x, y) as its first\r\n         * (and only) point, as if the moveTo() method had been called.\r\n         * @param x\r\n         * @param y\r\n         * @param z\r\n         */\n\n    }, {\n        key: \"moveTo\",\n        value: function moveTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n\n            var currentSubPath = this.currentPath;\n            var point = new _Point3D2.default(x, y, z);\n            point.contextStateIndex = currentState.id;\n            point.transformMatrixIndex = currentState.transformMatrixId;\n            currentState.fireDirty();\n\n            var subPath = new _SubPath3D2.default(point);\n            currentSubPath.addSubPath(subPath);\n        }\n\n        /**\r\n         * The rect(x, y, w, h) method must create a new subpath containing just the four points\r\n         * (x, y), (x+w, y), (x+w, y+h), (x, y+h), with those four points connected by straight lines,\r\n         * and must then mark the subpath as closed.\r\n         * It must then create a new subpath with the point (x, y) as the only point in the subpath.\r\n         * @param x\r\n         * @param y\r\n         * @param w\r\n         * @param h\r\n         * @param depth 这个参数可选，不给的话就是0\r\n         */\n\n    }, {\n        key: \"rect\",\n        value: function rect(x, y, w, h, depth) {\n            if (depth == undefined) depth = 0;\n            this.moveTo(x, y, depth);\n            this.lineTo(x + w, y, depth);\n            this.lineTo(x + w, y + h, depth);\n            this.lineTo(x, y + h, depth);\n            var currentSubPath = this.currentPath.lastSubPath;\n            currentSubPath.type = _SubPath3D2.default.TYPE_RECTANGLE;\n            this.closePath();\n        }\n    }, {\n        key: \"ellipse\",\n        value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n            if (rotation == undefined) rotation = 0;\n            if (radiusX < 0 || radiusY < 0) throw new Error('半径必须不小于0. Radius should not be smaller than zero. BanJing BiXu BuXiaoYu Ling');\n            if (radiusX == 0 || radiusY == 0) return;\n            if (anticlockwise == undefined) anticlockwise = false;\n\n            var subpath = this.currentPath.lastSubPath;\n            if (subpath == undefined) {\n                subpath = new _SubPath3D2.default();\n                this.currentPath.addSubPath(subpath);\n            }\n\n            startAngle = adjustAngle(startAngle);\n            endAngle = adjustAngle(endAngle);\n\n            if (startAngle > endAngle && !anticlockwise || startAngle < endAngle && anticlockwise) {\n                if (startAngle < 0 || endAngle < 0) {\n                    endAngle -= 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle -= 2 * Math.PI;\n                }\n                if (startAngle > 0 || endAngle > 0) {\n                    endAngle += 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle += 2 * Math.PI;\n                }\n            }\n\n            var realRadius = Math.max(radiusX, radiusY); // 这个值要根据当前缩放算一下\n            var plusAngle = Math.asin(1 / realRadius) * 2;\n            var count = 0;\n            if (anticlockwise) {\n                plusAngle *= -1;\n            }\n\n            for (var radian = startAngle; Math.abs(radian) < Math.abs(endAngle); radian += plusAngle, count++) {\n                var _nextPoint = getPoint(x, y, radiusX, radiusY, radian);\n                this.lineTo(_nextPoint.x, _nextPoint.y);\n            }\n\n            // 连接上最后一个点：\n            var nextPoint = getPoint(x, y, radiusX, radiusY, endAngle);\n            this.lineTo(nextPoint.x, nextPoint.y);\n\n            function adjustAngle(angle) {\n                var PI2 = 2 * Math.PI;\n                var beishu = Math.floor(Math.abs(angle / PI2)) + 1;\n                if (Math.abs(angle) > PI2) beishu++;\n                if (angle < 0 && !anticlockwise) {\n                    angle += beishu * PI2;\n                }\n                if (angle > 0 && anticlockwise) {\n                    angle -= beishu * PI2;\n                }\n                return angle;\n            }\n\n            function getPoint(x, y, radiusX, radiusY, radian) {\n                var cos = Math.cos(radian);\n                var sin = Math.sin(radian);\n                var tan = sin / cos;\n                var x1 = Math.sqrt(radiusY * radiusY * radiusX * radiusX / (radiusY * radiusY + radiusX * radiusX * tan * tan));\n                var y1 = tan * x1;\n                if (cos * x1 < 0) x1 *= -1;\n                if (sin * y1 < 0) y1 *= -1;\n                x1 += x;\n                y1 += y;\n                if (rotation != 0) {\n                    var nx = (x1 - x) * Math.cos(rotation) - (y1 - y) * Math.sin(rotation) + x;\n                    var ny = (y1 - y) * Math.cos(rotation) + (x1 - x) * Math.sin(rotation) + y;\n                    x1 = nx;\n                    y1 = ny;\n                }\n                return { x: x1, y: y1 };\n            }\n        }\n\n        /**\r\n         * 该方法已经在canvas2d下模拟测试通过\r\n         * 规范说明\r\n         * The arc(x, y, radius, startAngle, endAngle, counterclockwise) method draws an arc.\r\n         * If the context has any subpaths, then the method must add a straight line from the last point in\r\n         * the subpath to the start point of the arc. In any case, it must draw the arc between the start point of\r\n         * the arc and the end point of the arc, and add the start and end points of the arc to the subpath.\r\n         * The arc and its start and end points are defined as follows:\r\n         * Consider a circle that has its origin at (x, y), and that has radius radius.\r\n         * The points at startAngle and endAngle this circle's circumference, measured in radians clockwise\r\n         * from the positive x-axis, are the start and end points respectively.\r\n         * If the counterclockwise argument false and endAngle-startAngle is equal to or greater than 2π,\r\n         * or if the counterclockwise argument is true and startAngle-endAngle is equal to or greater than 2π,\r\n         * then the arc is the whole circumference of this circle.\r\n         * Otherwise, the arc is the path along the circumference of this circle from the start point to the end point,\r\n         * going anti-clockwise if the counterclockwise argument is true, and clockwise otherwise.\r\n         * Since the points are on the circle, as opposed to being simply angles from zero,\r\n         * the arc can never cover an angle greater than 2π radians.\r\n         * If the two points are the same, or if the radius is zero, then the arc is defined as being of zero length in both directions.\r\n         * Negative values for radius must cause the implementation to throw an IndexSizeError exception.\r\n         * @param x\r\n         * @param y\r\n         * @param radius\r\n         * @param startAngle\r\n         * @param endAngle\r\n         * @param anticlockwise\r\n         */\n\n    }, {\n        key: \"arc\",\n        value: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n            this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);\n        }\n\n        /*************************** sate **************************/\n\n        /**\r\n         * push state on state stack\r\n         * 将当前状态放入状态栈中\r\n         */\n\n    }, {\n        key: \"save\",\n        value: function save() {\n            // 取出最后一个状态，克隆一个新状态，然后把新状态加入到栈内\n            var currentState = this.currentContextState;\n            var stateClone = currentState.clone();\n            this[_stateStack].push(stateClone);\n            this[_stateArray].push(stateClone);\n            stateClone.id = this[_stateArray].length - 1;\n        }\n\n        /**\r\n         * pop state stack and restore state\r\n         * 将当前状态弹出栈，即恢复之前的状态\r\n         */\n\n    }, {\n        key: \"restore\",\n        value: function restore() {\n            // 弹出栈底状态\n            if (this[_stateStack].length != 0) {\n                this[_stateStack].pop();\n            }\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            this.currentContextState.translate(x, y, z);\n        }\n\n        /**\r\n         * 默认2D是按照Z轴旋转\r\n         * @param radian\r\n         */\n\n    }, {\n        key: \"rotate\",\n        value: function rotate(radian) {\n            this.currentContextState.rotateZ(radian);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            this.currentContextState.rotateX(radian);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            this.currentContextState.rotateY(radian);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            this.currentContextState.scale(scaleX, scaleY, scaleZ);\n        }\n\n        /*********************** 绘制 */ //////////////\n\n    }, {\n        key: \"drawImage\",\n        value: function drawImage(image, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight) {\n            var texture = this.webglRender.textureManager.getTexture(image, this.gl, true);\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.textureIndex = texture.index;\n            var left = void 0,\n                top = void 0,\n                right = void 0,\n                bottom = void 0; // 图形对应矩形的四个点\n            var tx = void 0,\n                ty = void 0,\n                tr = void 0,\n                tb = void 0; // 贴图对应的四个点\n            // 只有x,y传入的调用\n            if (arguments.length == 3) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            // 有x,y,width,height传入的调用\n            if (arguments.length == 5) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            // 有9个参数传入的调用，即要调整贴图做镖\n            if (arguments.length == 9) {\n                left = dstX;\n                top = dstY;\n                right = dstX + dstWidth;\n                bottom = dstY + dstHeight;\n                tx = texture.x + srcX;\n                tr = texture.x + srcX + srcWidth;\n                ty = texture.y + srcY;\n                tb = texture.y + srcY + srcHeight;\n            }\n            this.beginPath();\n            this.rect(left, top, right - left, bottom - top);\n\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            this[_renderActionList].push(action);\n            var texCoordArray = new Array(4);\n            texCoordArray[0] = [tx, ty]; // 左上角\n            texCoordArray[1] = [tr, ty]; // 右上角\n            texCoordArray[2] = [tr, tb]; // 右下角\n            texCoordArray[3] = [tx, tb]; // 左下角\n            var color = [255, 255, 255]; //白色，在glsl里会成为一个1,1,1的向量，这样就不会改变贴图数据了\n            action.collectVertexData(pathList, color, opacity, texCoordArray);\n        }\n    }, {\n        key: \"fill\",\n        value: function fill() {\n            var fillColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            this[_renderActionList].push(action);\n            action.collectVertexData(pathList, fillColor, opacity, [0, 0]);\n        }\n    }, {\n        key: \"fillRect\",\n        value: function fillRect(x, y, w, h) {\n            this.beginPath();\n            this.rect(x, y, w, h);\n            this.fill();\n        }\n    }, {\n        key: \"stroke\",\n        value: function stroke() {\n            var strokeColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.strokeStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_STROKE);\n            this[_renderActionList].push(action);\n            action.collectVertexData(pathList, strokeColor, opacity, [0, 0]);\n        }\n\n        //******************** 扩展接口 *****************************//\n\n    }, {\n        key: \"fillOrStroke\",\n        value: function fillOrStroke(fillColor, borderColor) {\n            if (fillColor != undefined) {\n                this.fillStyle = fillColor;\n                this.fill();\n            }\n            if (borderColor != undefined) {\n                this.strokeStyle = borderColor;\n                this.stroke();\n            }\n        }\n    }, {\n        key: \"drawRectangle\",\n        value: function drawRectangle(x, y, width, height, fillColor, borderColor) {\n            this.beginPath();\n            this.rect(x, y, width, height);\n            this.closePath();\n            this.save();\n            this.fillOrStroke(fillColor, borderColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawEllipse\",\n        value: function drawEllipse(x, y, radiusA, radiusB, fillColor, borderColor, rotate) {\n            this.beginPath();\n            this.ellipse(x, y, radiusA, radiusB, rotate, 0, _Tools2.default.PI2, false);\n            this.closePath();\n            this.save();\n            this.fillOrStroke(fillColor, borderColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawCircle\",\n        value: function drawCircle(x, y, radius, fillColor, borderColor) {\n            this.drawEllipse(x, y, radius, radius, fillColor, borderColor, 0);\n        }\n    }, {\n        key: \"draw\",\n        value: function draw(x, y, z) {\n            this.webglRender.initRending();\n            this.webglRender.executeRenderAction(this[_renderActionList], this[_stateArray]);\n            this[_renderActionList].length = 0;\n            // debug:\n            // console.log(\"绘制调用次数：\", this.webglRender.DEBUG_DRAW_COUNT);\n        }\n    }, {\n        key: \"currentContextState\",\n        get: function get() {\n            if (this[_stateStack].length == 0) {\n                // 状态栈永远不为空\n                var state = new _ContextState2.default(new _CanvasDrawingStylesWebgl2D2.default());\n                this[_stateStack].push(state);\n                this[_stateArray].push(state);\n                state.id = this[_stateArray].length - 1;\n            }\n            return this[_stateStack][this[_stateStack].length - 1];\n        }\n    }, {\n        key: \"currentPath\",\n        get: function get() {\n            if (this[_pathList].length == 0) {\n                this[_pathList].push(new _Path3D2.default());\n            }\n            return this[_pathList][this[_pathList].length - 1];\n        }\n\n        /**************** 下面是标准接口实现 *************************/\n\n        /**\r\n         * back-reference to the canvas\r\n         * Canvas的回引用\r\n         * @returns {canvas}\r\n         */\n\n    }, {\n        key: \"canvas\",\n        get: function get() {\n            return this[_canvas];\n        }\n    }, {\n        key: \"strokeStyle\",\n        set: function set(stroke) {\n            this.currentContextState.strokeStyle = stroke;\n        },\n        get: function get() {\n            return this.currentContextState.strokeStyle;\n        }\n    }, {\n        key: \"fillStyle\",\n        set: function set(fill) {\n            this.currentContextState.fillStyle = fill;\n        },\n        get: function get() {\n            return this.currentContextState.fillStyle;\n        }\n    }, {\n        key: \"globalAlpha\",\n        set: function set(alpha) {\n            this.currentContextState.globalAlpha = alpha;\n        },\n        get: function get() {\n            return this.currentContextState.globalAlpha;\n        }\n    }]);\n\n    return CanvasRenderingContextWebgl2D;\n}();\n\nexports.default = CanvasRenderingContextWebgl2D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ }),

/***/ "./public/src/webgl/ContextState.js":
/*!******************************************!*\
  !*** ./public/src/webgl/ContextState.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./public/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./public/src/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _transformMatrix = Symbol('变换矩阵');\n\nvar ContextState = function () {\n    function ContextState(canvasDrawingStyle) {\n        _classCallCheck(this, ContextState);\n\n        this.canvasDrawingStyle = canvasDrawingStyle;\n        this.matrixIndex = 0;\n        this.fillStyle = '#000000';\n        this.strokeStyle = '#000000';\n        this.globalAlpha = 1;\n        this.id = -1;\n        this.matrixArray = [];\n        this.matrixArray.push(_Mat2.default.identity());\n        this.dirty = false;\n    }\n\n    _createClass(ContextState, [{\n        key: \"fireDirty\",\n        value: function fireDirty() {\n            this.dirty = true;\n        }\n    }, {\n        key: \"setTransformMatrix\",\n        value: function setTransformMatrix(value) {\n            var current = this.transformMatrix.matrix;\n            _Mat2.default.copy(value, current);\n        }\n    }, {\n        key: \"checkDirty\",\n        value: function checkDirty() {\n            // 如果当前的矩阵会被应用到某些节点上，则说明这个矩阵脏了，\n            // 一旦变换矩阵就要保存一下，并把这个矩阵的克隆放入数组底\n            if (this.dirty) {\n                var m1 = _Mat2.default.identity();\n                var lastMatrix = this.transformMatrix.matrix;\n                _Mat2.default.copy(lastMatrix, m1);\n                this.matrixArray.push(m1);\n                this.dirty = false;\n            }\n        }\n    }, {\n        key: \"applyTransform\",\n        value: function applyTransform(currentTransformMatrix) {\n            this.checkDirty();\n            var lastMatrix = this.transformMatrix.matrix;\n            _Mat2.default.multiply(lastMatrix, lastMatrix, currentTransformMatrix);\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            if (z === undefined) z = 0;\n            if (_Tools2.default.equals(x, 0) && _Tools2.default.equals(y, 0) && _Tools2.default.equals(z, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.translationMatrix(m, x, y, z);\n            this.applyTransform(m);\n        }\n\n        // 默然是按照z轴旋转\n\n    }, {\n        key: \"rotateZ\",\n        value: function rotateZ(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationZMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationXMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationYMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            if (scaleZ === undefined) scaleZ = 1;\n            if (_Tools2.default.equals(scaleX, 1) && _Tools2.default.equals(scaleY, 1) && _Tools2.default.equals(scaleZ, 1)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.scalingMatrix(m, scaleX, scaleY, scaleZ);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"clone\",\n        value: function clone() {\n            var newState = new ContextState(this.canvasDrawingStyle.clone());\n            newState.fillStyle = this.fillStyle;\n            newState.strokeStyle = this.strokeStyle;\n            newState.globalAlpha = this.globalAlpha;\n            newState.matrixIndex = this.matrixIndex;\n            // 把当前的矩阵作为新矩阵的最后一个\n            newState.setTransformMatrix(this.transformMatrix.matrix);\n            return newState;\n        }\n    }, {\n        key: \"transformMatrixId\",\n        get: function get() {\n            return this.matrixArray.length - 1;\n        }\n    }, {\n        key: \"transformMatrix\",\n        get: function get() {\n            var index = this.matrixArray.length - 1;\n            var m = this.matrixArray[index];\n            return { matrix: m, id: index };\n        }\n    }]);\n\n    return ContextState;\n}();\n\nexports.default = ContextState;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/ContextState.js?");

/***/ }),

/***/ "./public/src/webgl/DataBuffer.js":
/*!****************************************!*\
  !*** ./public/src/webgl/DataBuffer.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar MAX_SINGLE_BYTE_LENGTH = 32 * 6 * 100; // 默认buffer长度就是100个矩形的长度\nvar TYPE_FLOAT32 = 4;\nvar TYPE_FLOAT64 = 8;\nvar TYPE_UINT8 = 2;\nvar TYPE_UINT16 = 3;\nvar TYPE_UINT32 = 0;\nvar TYPE_INT8 = 5;\nvar TYPE_INT16 = 6;\nvar TYPE_INT32 = 7;\nvar TYPE_UINT8CLAMPED = 1;\nvar _currentByteIndex = Symbol('当前buffer数据所在的字节索引');\nvar _singleDataFragmentSize = Symbol('单个数据块字节大小');\nvar _dataStructure = Symbol('ArrayBuffer的数据存放结构');\nvar _currentStructureIndex = Symbol('当前所在结构中的索引');\nvar littleEndian = undefined; // DataView是否是按照低位存放\n\nvar DataBuffer = function () {\n    function DataBuffer(dataStructure, length) {\n        _classCallCheck(this, DataBuffer);\n\n        if (length === undefined) length = MAX_SINGLE_BYTE_LENGTH;\n        this.buffer = new ArrayBuffer(length);\n        this.dv = new DataView(this.buffer);\n        this.byteDv = new Uint8Array(this.buffer);\n        this[_dataStructure] = dataStructure;\n        var that = this;\n        var initDataStructure = function initDataStructure(dataStructure) {\n            if (dataStructure === undefined || dataStructure === null) {\n                // 如果没有设置数据结构，那就默认是单个float32进行添加\n                console.warn(\"DataStructure没有指定，默认单个float32数据进行存放。DataStructure必须是一个数组，其内部结构为 [...{type:type,count:count,byteSize:size},...]\");\n                that[_singleDataFragmentSize] = 4;\n                that[_dataStructure] = undefined;\n                return;\n            } else {\n                if (!(dataStructure instanceof Array)) {\n                    console.warn(\"DataStructure必须是一个数组，其内部结构为 [...{type:type,count:count,byteSize:size},...]\");\n                    that[_singleDataFragmentSize] = 4;\n                    that[_dataStructure] = undefined;\n                    return;\n                }\n                var size = 0;\n                var startByte = 0;\n                var endByte = 0;\n                for (var i = 0; i < dataStructure.length; i++) {\n                    var s = dataStructure[i];\n                    s.byteSize = that.getByteSize(s.type) * s.count;\n                    s.startByte = startByte;\n                    endByte = startByte + s.byteSize;\n                    s.endByte = endByte - 1;\n                    size += s.byteSize;\n                    startByte = endByte;\n                }\n                that[_singleDataFragmentSize] = size;\n            }\n        };\n\n        initDataStructure(this[_dataStructure]);\n        this[_currentStructureIndex] = 0;\n        this[_currentByteIndex] = 0;\n    }\n\n    _createClass(DataBuffer, [{\n        key: 'flush',\n        value: function flush(byteLength) {\n            if (byteLength != undefined) {\n                if (byteLength != this.buffer.byteLength) {\n                    this.buffer = new ArrayBuffer(byteLength);\n                    this.dv = new DataView(this.buffer);\n                    this.byteDv = new Uint8Array(this.buffer);\n                }\n            } else {\n                for (var i = 0; i < this.buffer.byteLength; i++) {\n                    this.byteDv[i] = 0.0;\n                }\n            }\n            this[_currentStructureIndex] = 0;\n            this[_currentByteIndex] = 0;\n        }\n    }, {\n        key: 'getByteSize',\n        value: function getByteSize(type) {\n            switch (type) {\n                case TYPE_FLOAT64:\n                    return 8;\n                case TYPE_UINT8CLAMPED:\n                case TYPE_INT8:\n                case TYPE_UINT8:\n                    return 1;\n                case TYPE_INT16:\n                case TYPE_UINT16:\n                    return 2;\n                case TYPE_FLOAT32:\n                case TYPE_INT32:\n                case TYPE_UINT32:\n                    return 4;\n            }\n            return 0;\n        }\n    }, {\n        key: 'put',\n        value: function put(value) {\n            if (value instanceof Array) {\n                for (var i = 0; i < value.length; i++) {\n                    this.put(value[i]);\n                }\n            } else {\n                if (this.dataStructure === undefined) {\n                    this.resizeBuffer(4);\n                    this.dv.setFloat32(this.currentIndex, value, DataBuffer.littleEndian);\n                    this[_currentByteIndex] += this.singleDataFragmentByteSize;\n                } else {\n                    var structure = this.dataStructure[this[_currentStructureIndex]];\n                    var size = this.getByteSize(structure.type);\n                    this.resizeBuffer(size);\n                    this.setValue(structure.type, value);\n                    var k = this.currentIndex % this.singleDataFragmentByteSize;\n                    if (k == 0) {\n                        this[_currentStructureIndex] = 0;\n                        return;\n                    }\n                    if (k > structure.endByte) {\n                        this[_currentStructureIndex]++;\n                    }\n                }\n            }\n        }\n    }, {\n        key: 'get',\n        value: function get(offset, type) {\n            var littleEndian = DataBuffer.littleEndian;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    return this.dv.getFloat64(offset, littleEndian);\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    return this.dv.getUint8(offset);\n                    break;\n                case TYPE_INT8:\n                    return this.dv.getInt8(offset);\n                    break;\n                case TYPE_UINT8:\n                    return this.dv.getUint8(offset);\n                    break;\n                case TYPE_INT16:\n                    return this.dv.getInt16(offset, littleEndian);\n                    break;\n                case TYPE_UINT16:\n                    return this.dv.getUint16(offset, littleEndian);\n                    break;\n                case TYPE_FLOAT32:\n                    return this.dv.getFloat32(offset, littleEndian);\n                    break;\n                case TYPE_INT32:\n                    return this.dv.getInt32(offset, littleEndian);\n                    break;\n                case TYPE_UINT32:\n                    return this.dv.getUint32(offset, littleEndian);\n                    break;\n            }\n        }\n    }, {\n        key: 'setValue',\n        value: function setValue(type, value) {\n            var littleEndian = DataBuffer.littleEndian;\n            var index = this.currentIndex;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    this.dv.setFloat64(index, value, littleEndian);\n                    this[_currentByteIndex] += 8;\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    this.dv.setUint8(index, value);\n                    this[_currentByteIndex] += 1;\n                    break;\n                case TYPE_INT8:\n                    this.dv.setInt8(index, value);\n                    this[_currentByteIndex] += 1;\n                    break;\n                case TYPE_UINT8:\n                    this.dv.setUint8(index, value);\n                    this[_currentByteIndex] += 1;\n                    break;\n                case TYPE_INT16:\n                    this.dv.setInt16(index, value, littleEndian);\n                    this[_currentByteIndex] += 2;\n                    break;\n                case TYPE_UINT16:\n                    this.dv.setUint16(index, value, littleEndian);\n                    this[_currentByteIndex] += 2;\n                    break;\n                case TYPE_FLOAT32:\n                    this.dv.setFloat32(index, value, littleEndian);\n                    this[_currentByteIndex] += 4;\n                    break;\n                case TYPE_INT32:\n                    this.dv.setInt32(index, value, littleEndian);\n                    this[_currentByteIndex] += 4;\n                    break;\n                case TYPE_UINT32:\n                    this.dv.setUint32(index, value, littleEndian);\n                    this[_currentByteIndex] += 4;\n                    break;\n            }\n        }\n    }, {\n        key: 'addLength',\n        value: function addLength(additionLength) {\n            // ArrayBuffer是不能直接进行读取的，所以利用uint8一个一个字节复制过去,这里用了TypedArray的set方法\n            var sourceView = this.byteDv;\n            var destView = new Uint8Array(new ArrayBuffer(this.buffer.byteLength + additionLength));\n            destView.set(sourceView);\n            this.buffer = destView.buffer;\n            this.dv = new DataView(this.buffer);\n            this.byteDv = new Uint8Array(this.buffer);\n        }\n    }, {\n        key: 'resizeBuffer',\n        value: function resizeBuffer(additionLength) {\n            if (additionLength === undefined) additionLength = this.singleDataFragmentByteSize;\n            if (this[_currentByteIndex] + additionLength > this.buffer.byteLength) {\n                this.addLength(additionLength);\n            }\n        }\n    }, {\n        key: 'clean',\n        value: function clean() {\n            // 重新new一个出来\n            this.buffer = new ArrayBuffer(this.buffer.byteLength);\n            this.dv = new DataView(this.buffer);\n            this.byteDv = new Uint8Array(this.buffer);\n            this[_currentByteIndex] = 0;\n            this[_currentStructureIndex] = 0;\n        }\n    }, {\n        key: 'getVertex',\n        value: function getVertex(index) {\n            if (index > this.currentIndex || index < 0) throw new Error('Index Error');\n            return [this.dv.getFloat32(index), this.dv.getFloat32(index + 4), this.dv.getFloat32(index + 8)];\n        }\n    }, {\n        key: 'modifyVertex',\n        value: function modifyVertex(vertex, index) {\n            var littleEndian = DataBuffer.littleEndian;\n            if (index > this.currentIndex || index < 0) throw new Error('Index Error');\n            this.dv.setFloat32(index, vertex[0], littleEndian);\n            this.dv.setFloat32(index + 4, vertex[1], littleEndian);\n            this.dv.setFloat32(index + 8, vertex[2], littleEndian);\n        }\n    }, {\n        key: 'putVertexData',\n        value: function putVertexData(vertex, color, opacity, texcoord) {\n            this.resizeBuffer(this.singleDataFragmentByteSize);\n            var littleEndian = DataBuffer.littleEndian;\n            var index = this.currentIndex;\n            this.dv.setFloat32(index, vertex[0], littleEndian);\n            this.dv.setFloat32(index + 4, vertex[1], littleEndian);\n            this.dv.setFloat32(index + 8, vertex[2], littleEndian);\n            // this.dv.setFloat32(index + 12, trasnformMatrixIndex, littleEndian);\n            // 这里插入1位float类型的无用数据，为了数据对齐\n            this.dv.setFloat32(index + 16, 0, littleEndian);\n            // 再继续添加顶点数据\n            this.dv.setUint8(index + 20, color[0]);\n            this.dv.setUint8(index + 21, color[1]);\n            this.dv.setUint8(index + 22, color[2]);\n            this.dv.setUint8(index + 23, Math.floor(opacity * 100));\n            this.dv.setFloat32(index + 24, texcoord[0], littleEndian);\n            this.dv.setFloat32(index + 28, texcoord[1], littleEndian);\n\n            this[_currentByteIndex] += this.singleDataFragmentByteSize;\n        }\n    }, {\n        key: 'dataStructure',\n        get: function get() {\n            return this[_dataStructure];\n        }\n    }, {\n        key: 'currentIndex',\n        get: function get() {\n            return this[_currentByteIndex];\n        }\n    }, {\n        key: 'bufferByteLength',\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }, {\n        key: 'singleDataFragmentByteSize',\n        get: function get() {\n            return this[_singleDataFragmentSize];\n        }\n    }, {\n        key: 'vertexCount',\n        get: function get() {\n            return this.currentIndex / this.singleDataFragmentByteSize;\n        }\n    }, {\n        key: 'length',\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }], [{\n        key: 'TYPE_FLOAT32',\n        get: function get() {\n            return TYPE_FLOAT32;\n        }\n    }, {\n        key: 'TYPE_FLOAT64',\n        get: function get() {\n            return TYPE_FLOAT64;\n        }\n    }, {\n        key: 'TYPE_UINT8',\n        get: function get() {\n            return TYPE_UINT8;\n        }\n    }, {\n        key: 'TYPE_UINT16',\n        get: function get() {\n            return TYPE_UINT16;\n        }\n    }, {\n        key: 'TYPE_UINT32',\n        get: function get() {\n            return TYPE_UINT32;\n        }\n    }, {\n        key: 'TYPE_INT8',\n        get: function get() {\n            return TYPE_INT8;\n        }\n    }, {\n        key: 'TYPE_INT16',\n        get: function get() {\n            return TYPE_INT16;\n        }\n    }, {\n        key: 'TYPE_INT32',\n        get: function get() {\n            return TYPE_INT32;\n        }\n    }, {\n        key: 'TYPE_UINT8CLAMPED',\n        get: function get() {\n            return TYPE_UINT8CLAMPED;\n        }\n    }, {\n        key: 'littleEndian',\n        get: function get() {\n            if (littleEndian === undefined) {\n                // DataView是默认按照高位存放，这里要做判断，更改存放顺序\n                // PS: Float32Array却是按照低位存放的\n                var arrayBuffer = new ArrayBuffer(2);\n                var uint8Array = new Uint8Array(arrayBuffer);\n                var uint16array = new Uint16Array(arrayBuffer);\n                uint8Array[0] = 0xAA; // 第一位是AA\n                uint8Array[1] = 0xBB; // 第二位是BB\n                // 如果从16的view中读取数据，按照其排序就能得出高低位，以便DataView在设置值的时候能正确\n                if (uint16array[0] === 0xBBAA) littleEndian = true;\n                if (uint16array[0] === 0xAABB) littleEndian = false;\n            }\n            return littleEndian;\n        }\n    }]);\n\n    return DataBuffer;\n}();\n\nexports.default = DataBuffer;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/DataBuffer.js?");

/***/ }),

/***/ "./public/src/webgl/Path3D.js":
/*!************************************!*\
  !*** ./public/src/webgl/Path3D.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Path3D = function () {\n    function Path3D() {\n        _classCallCheck(this, Path3D);\n\n        this.subPathArray = [];\n    }\n\n    _createClass(Path3D, [{\n        key: \"addSubPath\",\n        value: function addSubPath(subPath) {\n            this.subPathArray.push(subPath);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.subPathArray = [];\n        }\n    }, {\n        key: \"subPathNumber\",\n        get: function get() {\n            return this.subPathArray.length;\n        }\n    }, {\n        key: \"lastSubPath\",\n        get: function get() {\n            if (this.subPathNumber != 0) {\n                return this.subPathArray[this.subPathNumber - 1];\n            }\n        }\n    }]);\n\n    return Path3D;\n}();\n\nexports.default = Path3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/Path3D.js?");

/***/ }),

/***/ "./public/src/webgl/Point3D.js":
/*!*************************************!*\
  !*** ./public/src/webgl/Point3D.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _point = Symbol('存放坐标值的Float32数组');\nvar _transformMatrixIndex = Symbol('坐标转换矩阵索引');\n\nvar Point3D = function () {\n    function Point3D(x, y, z) {\n        _classCallCheck(this, Point3D);\n\n        this[_point] = new Float32Array(3);\n        this[_transformMatrixIndex] = new Uint16Array(2);\n        this[_point][0] = x;\n        this[_point][1] = y;\n        this[_point][2] = z;\n    }\n\n    _createClass(Point3D, [{\n        key: 'matrixIdData',\n        get: function get() {\n            return this[_transformMatrixIndex];\n        }\n    }, {\n        key: 'contextStateIndex',\n        get: function get() {\n            return this[_transformMatrixIndex][0];\n        },\n        set: function set(index) {\n            this[_transformMatrixIndex][0] = index;\n        }\n    }, {\n        key: 'transformMatrixIndex',\n        get: function get() {\n            return this[_transformMatrixIndex][1];\n        },\n        set: function set(index) {\n            this[_transformMatrixIndex][1] = index;\n        }\n    }, {\n        key: 'value',\n        get: function get() {\n            return this[_point];\n        },\n        set: function set(value) {\n            this[_point][0] = value[0];\n            this[_point][1] = value[1];\n            this[_point][2] = value[2];\n        }\n    }, {\n        key: 'x',\n        get: function get() {\n            return this[_point][0];\n        },\n        set: function set(x) {\n            this[_point][0] = x;\n        }\n    }, {\n        key: 'y',\n        get: function get() {\n            return this[_point][1];\n        },\n        set: function set(y) {\n            this[_point][1] = y;\n        }\n    }, {\n        key: 'z',\n        get: function get() {\n            return this[_point][2];\n        },\n        set: function set(z) {\n            this[_point][2] = z;\n        }\n    }]);\n\n    return Point3D;\n}();\n\nexports.default = Point3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/Point3D.js?");

/***/ }),

/***/ "./public/src/webgl/RenderAction.js":
/*!******************************************!*\
  !*** ./public/src/webgl/RenderAction.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _VertexData = __webpack_require__(/*! ./VertexData.js */ \"./public/src/webgl/VertexData.js\");\n\nvar _VertexData2 = _interopRequireDefault(_VertexData);\n\nvar _EarClipping = __webpack_require__(/*! ../geometry/EarClipping.js */ \"./public/src/geometry/EarClipping.js\");\n\nvar _EarClipping2 = _interopRequireDefault(_EarClipping);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ACTION_STROKE = 0; // stroke动作\nvar ACTION_FILL = 1; // fill动作\n\nvar RenderAction = function () {\n    function RenderAction(type) {\n        _classCallCheck(this, RenderAction);\n\n        this.type = type;\n        this.vertexData = null;\n        this.textureIndex = -1;\n    }\n\n    _createClass(RenderAction, [{\n        key: \"getVertexData\",\n        value: function getVertexData(vertexNumber) {\n            if (this.vertexData == null) {\n                this.vertexData = new _VertexData2.default(this.type, vertexNumber);\n            } else {\n                this.vertexData.resize(vertexNumber);\n            }\n            return this.vertexData;\n        }\n    }, {\n        key: \"collectVertexData\",\n        value: function collectVertexData(pathList, color, opacity, textureCoord) {\n            if (this.type == ACTION_FILL) {\n                this.collectVertexDataForFill(pathList, color, opacity, textureCoord);\n                return;\n            }\n            if (this.type == ACTION_STROKE) {\n                this.collectVertexDataForStroke(pathList, color, opacity, textureCoord);\n                return;\n            }\n        }\n    }, {\n        key: \"collectVertexDataForStroke\",\n        value: function collectVertexDataForStroke(pathList, color, opacity, textureCoord) {\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    var vertexCount = subPath.pointsNumber;\n                    if (vertexCount < 2) continue;\n                    if (subPath.isClosed) vertexCount++;\n                    var vertexData = this.getVertexData(vertexCount);\n                    for (var _i = 0; _i < vertexCount; _i++) {\n                        var index = _i % subPath.pointsNumber;\n                        vertexData.addMatrixIdData(subPath.getPoint(index).matrixIdData);\n                        vertexData.addVertexData(subPath.getPoint(index).value, color, opacity, textureCoord);\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"collectVertexDataForFill\",\n        value: function collectVertexDataForFill(pathList, color, opacity, textureCoord) {\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                if (path.subPathNumber == 0) {\n                    continue;\n                }\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    if (subPath.pointsNumber < 3) continue; // 小于三个无法填充成一个面\n                    this.organizeVertexForFill(subPath, color, opacity, textureCoord);\n                }\n            }\n        }\n    }, {\n        key: \"organizeVertexForFill\",\n        value: function organizeVertexForFill(subPath, color, opacity, textureCoord) {\n            var temp = new Array(subPath.pointsNumber * 2);\n            for (var i = 0; i < subPath.pointsNumber; i++) {\n                var p = subPath.getPoint(i);\n                var index = i * 2;\n                temp[index] = p.x;\n                temp[index + 1] = p.y;\n            }\n            var vertexOrg = _EarClipping2.default.earcut(temp);\n            var vertexData = this.getVertexData(vertexOrg.length);\n            for (var _i2 = 0; _i2 < vertexOrg.length; _i2++) {\n                var vertexIndex = vertexOrg[_i2];\n                vertexData.addMatrixIdData(subPath.getPoint(vertexIndex).matrixIdData);\n                if (textureCoord[0] instanceof Array) {\n                    vertexData.addVertexData(subPath.getPoint(vertexIndex).value, color, opacity, textureCoord[vertexIndex]);\n                } else {\n                    vertexData.addVertexData(subPath.getPoint(vertexIndex).value, color, opacity, textureCoord);\n                }\n            }\n        }\n    }], [{\n        key: \"ACTION_STROKE\",\n        get: function get() {\n            return ACTION_STROKE;\n        }\n    }, {\n        key: \"ACTION_FILL\",\n        get: function get() {\n            return ACTION_FILL;\n        }\n    }]);\n\n    return RenderAction;\n}();\n\nexports.default = RenderAction;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/RenderAction.js?");

/***/ }),

/***/ "./public/src/webgl/SubPath3D.js":
/*!***************************************!*\
  !*** ./public/src/webgl/SubPath3D.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TYPE_RECTANGLE = 0;\nvar TYPE_TRIANGLE = 1;\nvar TYPE_POLYGON = 2;\nvar TYPE_ELLIPSE = 3;\n\nvar SubPath3D = function () {\n    function SubPath3D(startPoint, type) {\n        _classCallCheck(this, SubPath3D);\n\n        this.pointsArray = [];\n        if (startPoint != undefined && startPoint != null) {\n            this.pushPoint(startPoint);\n        }\n        this.isClosed = false;\n        this.type = type || TYPE_POLYGON;\n    }\n\n    _createClass(SubPath3D, [{\n        key: \"close\",\n        value: function close() {\n            this.isClosed = true;\n        }\n    }, {\n        key: \"getPoint\",\n        value: function getPoint(index) {\n            return this.pointsArray[index];\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.pointsArray = []; // 这样比length = 0 效率高?\n            this.isClosed = false;\n            // this.pointsArray.length = 0;\n        }\n    }, {\n        key: \"pushPoint\",\n        value: function pushPoint(point) {\n            this.pointsArray.push(point);\n        }\n    }, {\n        key: \"popPoint\",\n        value: function popPoint() {\n            this.pointsArray.pop();\n        }\n    }, {\n        key: \"pointsNumber\",\n        get: function get() {\n            return this.pointsArray.length;\n        }\n    }], [{\n        key: \"TYPE_RECTANGLE\",\n        get: function get() {\n            return TYPE_RECTANGLE;\n        }\n    }, {\n        key: \"TYPE_POLYGON\",\n        get: function get() {\n            return TYPE_POLYGON;\n        }\n    }, {\n        key: \"TYPE_TRIANGLE\",\n        get: function get() {\n            return TYPE_TRIANGLE;\n        }\n    }, {\n        key: \"TYPE_ELLIPSE\",\n        get: function get() {\n            return TYPE_ELLIPSE;\n        }\n    }]);\n\n    return SubPath3D;\n}();\n\nexports.default = SubPath3D;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/SubPath3D.js?");

/***/ }),

/***/ "./public/src/webgl/TempCanvas.js":
/*!****************************************!*\
  !*** ./public/src/webgl/TempCanvas.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TempCanvas = function TempCanvas() {\n    _classCallCheck(this, TempCanvas);\n\n    return document.createElement('canvas');\n};\n\nexports.default = TempCanvas;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/TempCanvas.js?");

/***/ }),

/***/ "./public/src/webgl/TextureManager.js":
/*!********************************************!*\
  !*** ./public/src/webgl/TextureManager.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TempCanvas = __webpack_require__(/*! ./TempCanvas.js */ \"./public/src/webgl/TempCanvas.js\");\n\nvar _TempCanvas2 = _interopRequireDefault(_TempCanvas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _imageCatch = Symbol('图片缓存');\nvar _textCatch = Symbol('texture缓存');\n\nvar TextureManager = function () {\n    function TextureManager(maxWidth, maxHeight, maxTextureNum, space) {\n        _classCallCheck(this, TextureManager);\n\n        this.maxWidth = maxWidth || 1;\n        this.maxHeight = maxHeight || 1;\n        this.maxTextureNum = maxTextureNum || 1;\n        this[_imageCatch] = [];\n        this[_textCatch] = [];\n        this.imageDataArray = new Array(this.maxTextureNum);\n        this.textureArray = new Array(this.maxTextureNum);\n        this.space = space || 3;\n    }\n\n    _createClass(TextureManager, [{\n        key: 'getTexture',\n        value: function getTexture(image, gl, autoGenerateTexture) {\n            var index = this.imageCatch.indexOf(image);\n            if (index == -1) {\n                return this.registerImageData(image, gl, autoGenerateTexture);\n            } else {\n                return this[_textCatch][index];\n            }\n        }\n    }, {\n        key: 'registerImageData',\n        value: function registerImageData(image, gl, autoGenerateTexture) {\n            if (image == undefined || image == null) {\n                console.error('Image can not be null');\n                return;\n            }\n            if (autoGenerateTexture == undefined) autoGenerateTexture = false;\n            var x = 0;\n            var y = 0;\n            var imgW = image.width;\n            var imgH = image.height;\n            if (imgW > this.maxWidth || imgH > this.maxHeight) {\n                throw new Error('图片大小超过了最大限制：' + this.maxWidth + \" x \" + this.maxHeight);\n                return;\n            }\n            if (this.imageCatch.indexOf(image) == -1) {\n                var canvas = new _TempCanvas2.default(); // 这个地方用个类是为了便于微信小程序的适配\n                var ctx = canvas.getContext('2d');\n                ctx.clearRect(0, 0, canvas.width, canvas.height);\n                /**\r\n                 * 利用一个离屏canvas的2d context重新绘制一个套image并生成texture\r\n                 * 这个离屏canvas的0,0点是一个黑色的像素点，所以绘制其他image从[0,1]开始\r\n                 */\n                var currentTextureIndex = -1;\n                for (var i = 0; i < this.imageDataArray.length; i++) {\n                    var imageData = this.imageDataArray[i];\n                    if (imageData == undefined) {\n                        imageData = { imageData: undefined, startX: 0, startY: 0, width: 0, height: 0 };\n                        this.imageDataArray[i] = imageData;\n                        canvas.width = image.width;\n                        canvas.height = image.height + 1;\n                        x = 0;\n                        y = 1;\n                        ctx.fillStyle = \"#ffffff\";\n                        ctx.fillRect(0, 0, 1, 1); // 这个像素点是给一般fill用的texture颜色\n                        ctx.drawImage(image, 0, 1);\n                        // 保存当前绘制出来的图像数据\n                        imageData.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        imageData.startX = canvas.width + this.space;\n                        imageData.startY = 1;\n                        imageData.width = canvas.width;\n                        imageData.height = canvas.height;\n                    } else {\n                        var width = image.width;\n                        var height = image.height;\n                        x = imageData.startX;\n                        y = imageData.startY;\n                        if (x + width > this.maxWidth) {\n                            x = 0; // 从下一行开始画\n                            y = imageData.height + this.space;\n                            canvas.width = Math.max(imageData.width, width);\n                            canvas.height = y + height;\n                            console.log('换行');\n                        } else {\n                            canvas.width = Math.max(imageData.width, x + width);\n                            canvas.height = Math.max(imageData.height, y + height);\n                            console.log('不换行');\n                        }\n                        if (y + height > this.maxHeight) {\n                            // 图片已经超过最大可以绘制的空间，换另外一个texture\n                            console.log('图片超过贴图内存最大尺寸');\n                            continue;\n                        }\n                        // 将之前的像素数据放入新的canvas中\n                        ctx.putImageData(imageData.imageData, 0, 0);\n                        ctx.drawImage(image, x, y);\n                        imageData.imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        imageData.startX = x + width + this.space;\n                        imageData.startY = y;\n                        imageData.width = canvas.width;\n                        imageData.height = canvas.height;\n                    }\n                    currentTextureIndex = i;\n                    break;\n                }\n\n                if (currentTextureIndex != -1) {\n                    this.imageCatch.push(image);\n                    var textureInfo = { x: x, y: y, width: imgW, height: imgH, index: currentTextureIndex };\n                    if (autoGenerateTexture) {\n                        this.createTexture(gl, currentTextureIndex, canvas);\n                    }\n                    this[_textCatch].push(textureInfo);\n                    return textureInfo;\n                }\n            }\n        }\n    }, {\n        key: 'createAllTexture',\n        value: function createAllTexture(gl) {\n            if (gl == undefined) return;\n            var canvas = new _TempCanvas2.default();\n            var ctx = canvas.getContext('2d');\n            for (var i = 0; i < this.textureArray.length; i++) {\n                this.createTexture(gl, i, canvas);\n            }\n        }\n    }, {\n        key: 'createTexture',\n        value: function createTexture(gl, index, canvas) {\n            if (gl == undefined || index == undefined || index == -1) return;\n            if (canvas == undefined) {\n                canvas = new _TempCanvas2.default();\n            }\n            var ctx = canvas.getContext('2d');\n            var texture = this.textureArray[index];\n            var imgData = this.imageDataArray[index];\n            if (imgData != undefined) {\n                canvas.width = imgData.width;\n                canvas.height = imgData.height;\n                ctx.putImageData(imgData.imageData, 0, 0);\n                if (texture == undefined) {\n                    texture = gl.createTexture();\n                    this.textureArray[index] = texture;\n                }\n                gl.bindTexture(gl.TEXTURE_2D, texture);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                if (TextureManager.isPOT(canvas.width) && TextureManager.isPOT(canvas.height)) {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                    gl.generateMipmap(gl.TEXTURE_2D);\n                } else {\n                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                }\n                gl.bindTexture(gl.TEXTURE_2D, null);\n            }\n        }\n    }, {\n        key: 'imageCatch',\n        get: function get() {\n            return this[_imageCatch];\n        }\n    }], [{\n        key: 'isPOT',\n        value: function isPOT(value) {\n            return value > 0 && (value - 1 & value) === 0;\n        }\n    }]);\n\n    return TextureManager;\n}();\n\nexports.default = TextureManager;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/TextureManager.js?");

/***/ }),

/***/ "./public/src/webgl/VertexData.js":
/*!****************************************!*\
  !*** ./public/src/webgl/VertexData.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _DataBuffer = __webpack_require__(/*! ./DataBuffer.js */ \"./public/src/webgl/DataBuffer.js\");\n\nvar _DataBuffer2 = _interopRequireDefault(_DataBuffer);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// 这里每个节点大小如下：\n// 1. 三位是坐标，float类型，共3*4 , 12字节\n// 2. 两位是贴图坐标，float类型，共2*4 , 8个字节\n// 3. 四位颜色坐标, unsigleint类型，共4个字节\n// 4. 有两位float类型，是空的，只是为了让整个数据块成为16的倍数,这不是强迫症，而是叫做数据对齐\nvar VERTEX_DATA_STRUCTURE = [{ type: _DataBuffer2.default.TYPE_FLOAT32, count: 3 }, { type: _DataBuffer2.default.TYPE_FLOAT32, count: 2 }, { type: _DataBuffer2.default.TYPE_UINT8, count: 4 }, { type: _DataBuffer2.default.TYPE_FLOAT32, count: 2 }];\nvar VERTEX_BYTE_LENGTH = 32;\n\nvar MATRIX_INDEX_STRUCTURE = [{ type: _DataBuffer2.default.TYPE_FLOAT32, count: 1 }];\nvar MATRIX_INDEX_BYTE_LENGTH = 4;\n\nvar MATRIX_ID_STRUCTURE = [{ type: _DataBuffer2.default.TYPE_UINT16, count: 2 }];\nvar MATRIX_ID_BYTE_LENGTH = 4;\n\nvar TYPE_FILL = 0;\nvar TYPE_STROKE = 1;\n\nvar VertexData = function () {\n    function VertexData(type, vertexNum) {\n        _classCallCheck(this, VertexData);\n\n        this.type = type;\n        this.dataBuffer = new _DataBuffer2.default(VERTEX_DATA_STRUCTURE, vertexNum * VERTEX_BYTE_LENGTH);\n        // 因为attribute不允许int类型，只有用float代替了\n        this.matrixIndexBuffer = new _DataBuffer2.default(MATRIX_INDEX_STRUCTURE, vertexNum * MATRIX_INDEX_BYTE_LENGTH);\n        // this.matrixIdBuffer = new DataBuffer(MATRIX_ID_STRUCTURE, vertexNum * MATRIX_ID_BYTE_LENGTH);\n        this.matrixIdArray = [];\n    }\n\n    _createClass(VertexData, [{\n        key: \"resize\",\n        value: function resize(vertexNum) {\n            this.dataBuffer.addLength(vertexNum * VERTEX_BYTE_LENGTH);\n            this.matrixIndexBuffer.addLength(vertexNum * MATRIX_INDEX_BYTE_LENGTH);\n            // this.matrixIdBuffer.addLength(vertexNum * MATRIX_ID_BYTE_LENGTH);\n        }\n    }, {\n        key: \"addVertexData\",\n        value: function addVertexData(points, color, opacity, textureCoor) {\n            this.dataBuffer.putVertexData(points, color, opacity, textureCoor);\n            // this.matrixIndexBuffer.put(transformMatrixId);\n        }\n    }, {\n        key: \"addMatrixIdData\",\n        value: function addMatrixIdData(data) {\n            this.matrixIdArray.push(data);\n        }\n    }, {\n        key: \"getMatrixIdData\",\n        value: function getMatrixIdData(vertexIndex) {\n            return this.matrixIdArray[vertexIndex];\n        }\n    }, {\n        key: \"getContextStateIndex\",\n        value: function getContextStateIndex(vertexIndex) {\n            return this.matrixIdArray[vertexIndex][0];\n        }\n    }, {\n        key: \"getMatrixIndex\",\n        value: function getMatrixIndex(vertexIndex) {\n            return this.matrixIdArray[vertexIndex][1];\n        }\n    }, {\n        key: \"putMatrixId\",\n        value: function putMatrixId(id) {\n            this.matrixIndexBuffer.put(id);\n        }\n    }, {\n        key: \"vertexNumber\",\n        get: function get() {\n            return this.bufferSize / VERTEX_BYTE_LENGTH;\n        }\n    }, {\n        key: \"bufferSize\",\n        get: function get() {\n            return this.dataBuffer.currentIndex;\n        }\n    }], [{\n        key: \"VERTEX_BYTE_SIZE\",\n        get: function get() {\n            return VERTEX_BYTE_LENGTH;\n        }\n    }, {\n        key: \"TYPE_FILL\",\n        get: function get() {\n            return TYPE_FILL;\n        }\n    }, {\n        key: \"TYPE_STROKE\",\n        get: function get() {\n            return TYPE_STROKE;\n        }\n    }]);\n\n    return VertexData;\n}();\n\nexports.default = VertexData;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/VertexData.js?");

/***/ }),

/***/ "./public/src/webgl/WebGLRender.js":
/*!*****************************************!*\
  !*** ./public/src/webgl/WebGLRender.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TextureManager = __webpack_require__(/*! ./TextureManager.js */ \"./public/src/webgl/TextureManager.js\");\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _RenderAction = __webpack_require__(/*! ./RenderAction.js */ \"./public/src/webgl/RenderAction.js\");\n\nvar _RenderAction2 = _interopRequireDefault(_RenderAction);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./public/src/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SINGLE_DATA_BYTE_LENGTH = 32;\nvar fsSource = \"\\n  // \\u7247\\u65AD\\u7740\\u8272\\u5668\\u6CA1\\u6709\\u9ED8\\u8BA4\\u7CBE\\u5EA6\\uFF0C\\u6240\\u4EE5\\u6211\\u4EEC\\u9700\\u8981\\u8BBE\\u7F6E\\u4E00\\u4E2A\\u7CBE\\u5EA6\\n  // mediump\\u4EE3\\u8868\\u201Cmedium precision\\u201D\\uFF08\\u4E2D\\u7B49\\u7CBE\\u5EA6\\uFF09\\n  precision mediump float;\\n  varying vec4 currentColor;\\n  varying vec2 v_texcoord;\\n  varying vec3 normal;\\n  uniform vec2 singleCanvas;\\n  uniform vec3 u_lightPosition;\\n  uniform sampler2D u_texture;\\n  void main() {\\n        vec3 r_normal = normalize(normal);\\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\\n        vec4 color = currentColor;    \\n        vec3 r_lightLocation = normalize(u_lightPosition);    \\n        gl_FragColor = color * texture2D(u_texture,coord);\\n        gl_FragColor.rgb *= abs(dot(r_normal,r_lightLocation));\\n  }\\n  \";\n/**\r\n // 片断着色器没有默认精度，所以我们需要设置一个精度\r\n // mediump代表“medium precision”（中等精度）\r\n precision mediump float;\r\n varying vec4 currentColor;\r\n varying vec2 v_texcoord;\r\n uniform vec2 singleCanvas;\r\n uniform sampler2D u_texture;\r\n void main() {\r\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\r\n        vec4 color = currentColor;\r\n        gl_FragColor = color * texture2D(u_texture,coord);\r\n  }\r\n */\n\nvar _program = Symbol('WebGL的program');\nvar _maxTransformMatrixNum = Symbol('转换矩阵变量可用的最大数量');\n\nvar WebGLRender = function () {\n    function WebGLRender(gl) {\n        _classCallCheck(this, WebGLRender);\n\n        this.gl = gl;\n        this.firstTIMEDEBUG = true;\n        this.DEBUG_DRAW_COUNT = 0;\n        this.configured = false;\n        var maxVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        // 顶点作色器里已经用了一个mat4了和一个vec3，就是7个vector,减去这4个然后除以4就得到可以定义的最大mat4数组\n        this[_maxTransformMatrixNum] = Math.floor((maxVectors - 7) / 4);\n        this[_maxTransformMatrixNum] = 10; // 测试设置\n        this.textureManager = null;\n        this.lightPosition = [0, 0, 1];\n        this.init();\n    }\n\n    _createClass(WebGLRender, [{\n        key: \"clean\",\n        value: function clean() {\n            this.DEBUG_DRAW_COUNT = 0;\n            this.gl.clearColor(0, 0, 0, 0);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n        }\n    }, {\n        key: \"initRending\",\n        value: function initRending() {\n            var gl = this.gl;\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        }\n    }, {\n        key: \"rendVertexArray\",\n        value: function rendVertexArray(type, vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex) {\n            var gl = this.gl;\n            this.setLightPosition(this.lightPosition);\n            switch (type) {\n                case _RenderAction2.default.ACTION_FILL:\n                    this.fillRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex);\n                    break;\n                case _RenderAction2.default.ACTION_STROKE:\n                    this.strokeRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex);\n                    break;\n            }\n        }\n    }, {\n        key: \"setUniformTransformMatrix\",\n        value: function setUniformTransformMatrix(matrix, id) {\n            var gl = this.gl;\n            gl.uniformMatrix4fv(this.shaderInformation.transformMatrixArray[id], false, matrix);\n        }\n    }, {\n        key: \"configVerticesBufferData\",\n        value: function configVerticesBufferData(vertexDataArray, firstVerticesStart, lastVerticesEnd) {\n            var size = 0;\n            var vertexNumber = 0;\n            if (firstVerticesStart == undefined) firstVerticesStart = 0;\n            for (var i = 0; i < vertexDataArray.length; i++) {\n                size += vertexDataArray[i].bufferSize;\n                if (i == vertexDataArray.length - 1 && lastVerticesEnd != undefined) {\n                    vertexNumber += lastVerticesEnd + 1;\n                } else {\n                    vertexNumber += vertexDataArray[i].vertexNumber;\n                }\n            }\n            vertexNumber -= firstVerticesStart;\n            var gl = this.gl;\n            this.prepareVertexDatas(size);\n            this.prepareMatrixIndexDatas(size / 8); //因为单个顶点的大小为32，矩阵索引是4，所以就是8倍的关系\n\n            var offset = 0;\n            var offset1 = 0;\n            for (var _i = 0; _i < vertexDataArray.length; _i++) {\n                var vertexData = vertexDataArray[_i];\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.shaderInformation.verticesBuffer);\n                this.gl.bufferSubData(this.gl.ARRAY_BUFFER, offset, vertexData.dataBuffer.buffer);\n                gl.bindBuffer(gl.ARRAY_BUFFER, this.shaderInformation.matrixIndexBuffer);\n                this.gl.bufferSubData(this.gl.ARRAY_BUFFER, offset1, vertexData.matrixIndexBuffer.buffer);\n                offset += vertexData.dataBuffer.currentIndex;\n                offset1 += vertexData.matrixIndexBuffer.currentIndex;\n            }\n            return vertexNumber;\n        }\n    }, {\n        key: \"fillRendVertexArray\",\n        value: function fillRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd, textureIndex) {\n            if (firstVerticesStart == undefined) firstVerticesStart = 0;\n            if (vertexDataArray.length == 0) return;\n            this.configTexture(textureIndex);\n            var vertexNumber = this.configVerticesBufferData(vertexDataArray, firstVerticesStart, lastVerticesEnd);\n            if (vertexNumber < 3) return;\n            this.gl.drawArrays(this.gl.TRIANGLES, 0, vertexNumber);\n            this.DEBUG_DRAW_COUNT++;\n        }\n    }, {\n        key: \"strokeRendVertexArray\",\n        value: function strokeRendVertexArray(vertexDataArray, firstVerticesStart, lastVerticesEnd) {\n            if (firstVerticesStart == undefined) firstVerticesStart = 0;\n            if (vertexDataArray.length == 0) return;\n            this.configTexture();\n            var vertexNumber = this.configVerticesBufferData(vertexDataArray, firstVerticesStart, lastVerticesEnd);\n            if (vertexNumber < 2) return;\n            this.gl.drawArrays(this.gl.LINE_STRIP, 0, vertexNumber);\n            this.DEBUG_DRAW_COUNT++;\n        }\n    }, {\n        key: \"executeRenderAction\",\n        value: function executeRenderAction(actionList, stateArray) {\n            var matrixIndex = 1; // 每次绘制都要重新设置矩阵的索引\n            var lastAction = undefined;\n            var vertexDataArray = [];\n            var matrixMap = {}; // 由状态id和状态内矩阵id组合成一个key，value是对应的矩阵索引值\n            var firstVerticesStart = 0;\n\n            for (var i = 0; i < actionList.length; i++) {\n                var currentAction = actionList[i];\n                if (lastAction == undefined) lastAction = currentAction;\n                if (currentAction.type == _RenderAction2.default.ACTION_STROKE) {\n                    if (lastAction != currentAction && lastAction != undefined) {\n                        this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n                    }\n                    vertexDataArray = [];\n                    vertexDataArray.push(currentAction.vertexData);\n                    matrixIndex = 1;\n                    matrixMap = {};\n                    lastAction = currentAction;\n                    for (var k = 0; k < currentAction.vertexData.vertexNumber; k++) {\n                        var mid = currentAction.vertexData.getMatrixIndex(k);\n                        var sid = currentAction.vertexData.getContextStateIndex(k);\n                        var key = sid + \"-\" + mid;\n                        var currentMatrixIndex = matrixMap[key];\n                        if (currentMatrixIndex == undefined) {\n                            currentMatrixIndex = matrixIndex;\n                            if (currentMatrixIndex + 1 > this.maxTransformMatrixNum) {\n                                //为了能让一个绘制动作顺利结束，只能自己计算坐标咯\n                                var m = stateArray[sid].matrixArray[mid];\n                                var vertex = currentAction.vertexData.dataBuffer.getVertex(k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n                                vertex = _Mat2.default.multiplyWithVertex(m, vertex);\n                                currentAction.vertexData.dataBuffer.modifyVertex(vertex, k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n                                currentAction.vertexData.matrixIndexBuffer.put(0);\n                            } else {\n                                var _m = stateArray[sid].matrixArray[mid];\n                                matrixMap[key] = currentMatrixIndex;\n                                this.setUniformTransformMatrix(_m, currentMatrixIndex);\n                                currentAction.vertexData.matrixIndexBuffer.put(currentMatrixIndex);\n                                matrixIndex++;\n                            }\n                        } else {\n                            currentAction.vertexData.matrixIndexBuffer.put(currentMatrixIndex);\n                        }\n                    }\n                    this.rendVertexArray(currentAction.type, vertexDataArray);\n                    matrixMap = {};\n                    vertexDataArray = [];\n                    matrixIndex = 1;\n                    continue;\n                } else {\n                    // 先收集顶点数据，顶点的矩阵在下一步再设置\n                    if (currentAction.type == lastAction.type) {\n                        // 同个Fill绘制可以进行叠加统一绘制\n                        if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                            this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n                            vertexDataArray = [];\n                            lastAction = currentAction;\n                            matrixIndex = 1;\n                            matrixMap = {};\n                        }\n                        if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n                            lastAction = currentAction;\n                        }\n                        vertexDataArray.push(currentAction.vertexData); // 叠加\n                    } else {\n                        // 如果类型不一样，先绘制之前的类型，并且当前的index退回去\n                        this.rendVertexArray(lastAction.type, vertexDataArray);\n                        matrixIndex = 1;\n                        i--;\n                        lastAction = undefined;\n                        vertexDataArray = [];\n                        continue;\n                    }\n                }\n\n                // 开始设置顶点的变换矩阵\n                for (var _k = 0; _k < currentAction.vertexData.vertexNumber; _k++) {\n                    var _mid = currentAction.vertexData.getMatrixIndex(_k);\n                    var _sid = currentAction.vertexData.getContextStateIndex(_k);\n                    var _key = _sid + \"-\" + _mid;\n                    var _currentMatrixIndex = matrixMap[_key];\n                    if (_currentMatrixIndex == undefined) {\n                        _currentMatrixIndex = matrixIndex;\n                        if (_currentMatrixIndex + 1 > this.maxTransformMatrixNum) {\n                            // 如果Index已经超过最大限制，就先绘制之前的\n                            if (_k == 0) {\n                                vertexDataArray.pop();\n                                this.rendVertexArray(lastAction.type, vertexDataArray, undefined, undefined, lastAction.textureIndex);\n                                matrixMap = {};\n                                matrixIndex = 1;\n                                vertexDataArray = [];\n                                lastAction = undefined;\n                                i--;\n                                break;\n                            } else {\n                                //为了能让一个绘制动作顺利结束，只能自己计算坐标咯\n                                var _m2 = stateArray[_sid].matrixArray[_mid];\n                                var _vertex = currentAction.vertexData.dataBuffer.getVertex(_k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n                                _vertex = _Mat2.default.multiplyWithVertex(_m2, _vertex);\n                                currentAction.vertexData.dataBuffer.modifyVertex(_vertex, _k * currentAction.vertexData.dataBuffer.singleDataFragmentByteSize);\n                                currentAction.vertexData.matrixIndexBuffer.put(0);\n                            }\n                        } else {\n                            var _m3 = stateArray[_sid].matrixArray[_mid];\n                            matrixMap[_key] = _currentMatrixIndex;\n                            this.setUniformTransformMatrix(_m3, _currentMatrixIndex);\n                            currentAction.vertexData.matrixIndexBuffer.put(_currentMatrixIndex);\n                            matrixIndex++;\n                        }\n                    } else {\n                        currentAction.vertexData.matrixIndexBuffer.put(_currentMatrixIndex);\n                    }\n                }\n            }\n\n            if (vertexDataArray.length != 0 && lastAction != undefined) {\n                this.rendVertexArray(lastAction.type, vertexDataArray, firstVerticesStart, undefined, lastAction.textureIndex);\n            }\n        }\n    }, {\n        key: \"configTexture\",\n        value: function configTexture(textureIndex) {\n            if (textureIndex == undefined) textureIndex = -1;\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.uniform1i(shaderInfo.textureLocation, 0);\n            var texture = void 0;\n            var c = void 0;\n            if (textureIndex == -1) {\n                texture = shaderInfo.blackTexture;\n                c = { width: 1, height: 1 };\n            } else {\n                texture = this.textureManager.textureArray[textureIndex];\n                c = this.textureManager.imageDataArray[textureIndex];\n            }\n            gl.uniform2f(shaderInfo.singleCanvas, c.width, c.height);\n            gl.activeTexture(gl.TEXTURE0 + 0);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n        }\n    }, {\n        key: \"prepareVertexDatas\",\n        value: function prepareVertexDatas(dataByteLength) {\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.enableVertexAttribArray(shaderInfo.vertexAttribute);\n            gl.enableVertexAttribArray(shaderInfo.colorAttribute);\n            gl.enableVertexAttribArray(shaderInfo.textureCoordAttribute);\n            // gl.enableVertexAttribArray(shaderInfo.transformMatrixIndex);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.verticesBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, dataByteLength, gl.DYNAMIC_DRAW);\n\n            // 设置如何从buffer中读出顶点\n            var floatByteSize = 4;\n\n            // 设置如何从buffer中读出顶点\n            var size = 3; // 这是表示这组数据由多少个数组element组成\n            var type = gl.FLOAT; // 给出数据的类型\n            var normalize = false; // 是否要标准化，比如gl.UNSIGN8BIT,就会变成[1-0】之间的数字\n            var stride = SINGLE_DATA_BYTE_LENGTH; // 读取的时候移动多少字节到达该类型数据的下一个，这个很关键，一般都是这个数据layout的单个组成所有数据的大小\n            // 比如现在，就是3个顶点坐标+2个贴图坐标+2个无用float，因为都设置成了float，再加上4位颜色 所以这个stride值就是 7*4+4 =32;\n            var offset = 0; // 读取的起始位置，和stride一样，移动的位置也是字节大小。顶点数据是在整个layout的开始，所以是0，而颜色数据在顶点之后，则是3*4\n            gl.vertexAttribPointer(shaderInfo.vertexAttribute, size, type, normalize, stride, offset);\n\n            // type = gl.FLOAT;\n            // size = 1;\n            // offset = 3 * floatByteSize;\n            // gl.vertexAttribPointer(shaderInfo.transformMatrixIndex, size, type, normalize, stride, offset);\n\n            type = gl.UNSIGNED_BYTE;\n            size = 4;\n            offset = 5 * floatByteSize; // 注意：这里要跳过两个无用的float类型数据\n            gl.vertexAttribPointer(shaderInfo.colorAttribute, size, type, normalize, stride, offset);\n\n            type = gl.FLOAT;\n            size = 2;\n            offset += 4;\n            gl.vertexAttribPointer(shaderInfo.textureCoordAttribute, size, type, normalize, stride, offset);\n        }\n    }, {\n        key: \"prepareMatrixIndexDatas\",\n        value: function prepareMatrixIndexDatas(length) {\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n\n            gl.enableVertexAttribArray(shaderInfo.transformMatrixIndex);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.matrixIndexBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, length, gl.DYNAMIC_DRAW);\n            var type = gl.FLOAT;\n            var size = 1;\n            var offset = 0;\n            var stripe = 4;\n            gl.vertexAttribPointer(shaderInfo.transformMatrixIndex, size, type, false, stripe, offset);\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(position) {\n            this.gl.uniform3f(this.shaderInformation.lightPosition, position[0], position[1], position[2]);\n        }\n    }, {\n        key: \"createShaderProgram\",\n        value: function createShaderProgram() {\n            var gl = this.gl;\n            var vertexShader = this.loadShader(gl.VERTEX_SHADER, this.getVertexShaderSource(this.maxTransformMatrixNum));\n            var fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);\n\n            // 创建Shader程序，一个是顶点shader一个是片段shader\n            var shaderProgram = gl.createProgram();\n            gl.attachShader(shaderProgram, vertexShader);\n            gl.attachShader(shaderProgram, fragmentShader);\n            gl.linkProgram(shaderProgram);\n\n            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n                console.error('无法初始化Program: ' + gl.getProgramInfoLog(shaderProgram));\n                gl.deleteProgram(shaderProgram);\n                return null;\n            }\n            gl.useProgram(shaderProgram);\n            return shaderProgram;\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var gl = this.gl;\n            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n            this.gl.enable(this.gl.BLEND);\n            this.gl.disable(this.gl.DEPTH_TEST);\n            this[_program] = this.createShaderProgram();\n            var program = this[_program];\n            this.shaderInformation = this.initShaderInformation(program);\n            this.textureManager = new _TextureManager2.default(801, 801, 10, 4);\n            this.textureManager.maxHeight = gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n            this.textureManager.maxWidth = this.textureManager.maxHeight;\n            // 设置正射投影矩阵\n            var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;\n            var m1 = _Mat2.default.orthoProjection(0, 0, gl.canvas.width, gl.canvas.height, -1000, 1000);\n            gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m1);\n        }\n    }, {\n        key: \"initShaderInformation\",\n        value: function initShaderInformation(program) {\n            var gl = this.gl;\n\n            var textureCoordAttribute = gl.getAttribLocation(program, \"u_texCoord\");\n            gl.enableVertexAttribArray(textureCoordAttribute);\n\n            var vertexAttribute = gl.getAttribLocation(program, \"a_position\");\n            gl.enableVertexAttribArray(vertexAttribute);\n\n            var transformMatrixIndex = gl.getAttribLocation(program, \"transform_matrix_index\");\n            gl.enableVertexAttribArray(transformMatrixIndex);\n\n            var colorAttribute = gl.getAttribLocation(program, 'color');\n            gl.enableVertexAttribArray(colorAttribute);\n\n            // 转化矩阵全局变量\n            var perspectiveMatrix = gl.getUniformLocation(program, \"perspective_matrix\");\n            var transformMatrixArray = new Array(this.maxTransformMatrixNum);\n            for (var i = 0; i < transformMatrixArray.length; i++) {\n                transformMatrixArray[i] = gl.getUniformLocation(program, \"transform_matrix_array[\" + i + \"]\");\n            }\n            gl.uniformMatrix4fv(transformMatrixArray[0], false, _Mat2.default.identity());\n            var singleCanvas = gl.getUniformLocation(program, \"singleCanvas\");\n            var lightPosition = gl.getUniformLocation(program, \"u_lightPosition\");\n            var textureLocation = gl.getUniformLocation(program, \"u_texture\");\n\n            // 创建数据缓存\n            var verticesBuffer = gl.createBuffer();\n            var matrixIndexBuffer = gl.createBuffer();\n            var blackTexture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, blackTexture);\n            var blackPixel = new Uint8Array([255, 255, 255, 255]);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, blackPixel);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            return {\n                lightPosition: lightPosition,\n                vertexAttribute: vertexAttribute,\n                colorAttribute: colorAttribute,\n                textureCoordAttribute: textureCoordAttribute,\n                verticesBuffer: verticesBuffer,\n                matrixIndexBuffer: matrixIndexBuffer,\n                perspectiveMatrix: perspectiveMatrix,\n                transformMatrixArray: transformMatrixArray,\n                transformMatrixIndex: transformMatrixIndex,\n                singleCanvas: singleCanvas,\n                textureLocation: textureLocation,\n                blackTexture: blackTexture,\n                webgl: gl\n            };\n        }\n\n        /**\r\n         * 创建作色器\r\n         * @param type 着色器类型\r\n         * @param source 代码源\r\n         * @returns {*} Shader对象\r\n         */\n\n    }, {\n        key: \"loadShader\",\n        value: function loadShader(type, source) {\n            var gl = this.gl;\n            var shader = gl.createShader(type);\n            // 把GLSL代码给shader\n            gl.shaderSource(shader, source);\n            // 编译着色器程序\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error('着色器编译错误: ' + gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        /**\r\n           这样我看得更清楚些\r\n           attribute vec4 color;\r\n         attribute vec4 a_position;\r\n         attribute vec2 u_texCoord;\r\n         attribute vec2 transform_matrix_index;\r\n         varying vec2 v_texcoord;\r\n         varying vec4 currentColor;\r\n         uniform mat4 texture_matrix;\r\n         uniform mat4 perspective_matrix;\r\n         uniform mat4 transform_matrix_array[transformMatrixCount];\r\n         void main() {\r\n                // v_texcoord = u_texCoord;\r\n                // 切换坐标系到投影坐标系中\r\n                vec4 new_position = transform_matrix_array[0] * a_position;\r\n                vec4 finalPosition = perspective_matrix* new_position;\r\n                currentColor = vec4 (color.xyz/255.0,color.w/100.0);\r\n                gl_Position = finalPosition;\r\n        };\r\n           * @param transformMatrixCount\r\n         * @returns {string}\r\n         */\n\n    }, {\n        key: \"getVertexShaderSource\",\n        value: function getVertexShaderSource(transformMatrixCount) {\n            var vsSource = ' attribute vec4 color;\\n' + '     attribute vec4 a_position;\\n' + '     attribute vec2 u_texCoord;\\n' + '     attribute float transform_matrix_index;\\n' + '     varying vec2 v_texcoord;\\n' + '     varying vec4 currentColor;\\n' + '     varying vec3 normal;\\n' + '     uniform mat4 perspective_matrix;\\n' + '     uniform mat4 transform_matrix_array[' + transformMatrixCount + '];\\n' + '     void main() {\\n' + '             normal = vec3(0,0,1);\\n' + '             v_texcoord = u_texCoord;\\n' + '            // 切换坐标系到投影坐标系中\\n' + '            vec4 new_position = transform_matrix_array[int(transform_matrix_index)] * a_position;\\n' + '            normal = mat3(transform_matrix_array[int(transform_matrix_index)]) * normal;\\n' + '            vec4 finalPosition = perspective_matrix* new_position;\\n' + '            currentColor = vec4 (color.xyz/255.0,color.w/100.0);\\n' + '            gl_Position = finalPosition;\\n' + '    }';\n            return vsSource;\n        }\n    }, {\n        key: \"maxTransformMatrixNum\",\n        get: function get() {\n            return this[_maxTransformMatrixNum];\n        }\n    }]);\n\n    return WebGLRender;\n}();\n\nexports.default = WebGLRender;\n\n//# sourceURL=webpack://tielifa.WebGL2D/./public/src/webgl/WebGLRender.js?");

/***/ }),

/***/ 0:
/*!*****************************************************************!*\
  !*** multi ./public/src/webgl/CanvasRenderingContextWebgl2D.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./public/src/webgl/CanvasRenderingContextWebgl2D.js */\"./public/src/webgl/CanvasRenderingContextWebgl2D.js\");\n\n\n//# sourceURL=webpack://tielifa.WebGL2D/multi_./public/src/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ })

/******/ })["default"];
});