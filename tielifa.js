(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["tielifa"] = factory();
	else
		root["tielifa"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./build/EntryPoints.js":
/*!******************************!*\
  !*** ./build/EntryPoints.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; // import CanvasRenderingContextWebgl2D from \"./webgl/CanvasRenderingContextWebgl2D.js\";\n//\n// module.exports = {\n//     WebGL2D:CanvasRenderingContextWebgl2D\n// };\n\n\nvar _CanvasRenderingContextWebgl2D = __webpack_require__(/*! ./webgl/CanvasRenderingContextWebgl2D.js */ \"./build/webgl/CanvasRenderingContextWebgl2D.js\");\n\nvar _CanvasRenderingContextWebgl2D2 = _interopRequireDefault(_CanvasRenderingContextWebgl2D);\n\nvar _Vector = __webpack_require__(/*! ./math/Vector2.js */ \"./build/math/Vector2.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Vector3 = __webpack_require__(/*! ./math/Vector3.js */ \"./build/math/Vector3.js\");\n\nvar _Vector4 = _interopRequireDefault(_Vector3);\n\nvar _Mat = __webpack_require__(/*! ./math/Mat3.js */ \"./build/math/Mat3.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Mat3 = __webpack_require__(/*! ./math/Mat4.js */ \"./build/math/Mat4.js\");\n\nvar _Mat4 = _interopRequireDefault(_Mat3);\n\nvar _GeometryTools = __webpack_require__(/*! ./geometry/GeometryTools.js */ \"./build/geometry/GeometryTools.js\");\n\nvar _GeometryTools2 = _interopRequireDefault(_GeometryTools);\n\nvar _TextureManager = __webpack_require__(/*! ./texture/TextureManager.js */ \"./build/texture/TextureManager.js\");\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _Tools = __webpack_require__(/*! ./utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar style = \"color:yellow;background-color:grey\";\nvar version = '1.0.1';\nvar outdefine = {\n    version: version,\n    WebGL2D: _CanvasRenderingContextWebgl2D2.default,\n    Vector2: _Vector2.default,\n    Vector3: _Vector4.default,\n    Mat3: _Mat2.default,\n    Mat4: _Mat4.default,\n    GeometryTools: _GeometryTools2.default,\n    TextureManager: _TextureManager2.default,\n    Tools: _Tools2.default\n};\n// let out = {};\n// for (let p in outdefine) {\n//     let v = outdefine[p];\n//     Object.defineProperty(out, p, {\n//         get: function () {\n//             return v;\n//         }\n//     });\n// }\n\n\nvar out = {};\ndefinedReadOnly(outdefine, out);\n\nfunction definedReadOnly(maps, out) {\n    var _loop = function _loop(p) {\n        var v = maps[p];\n        var v1 = v;\n        if ((typeof v1 === \"undefined\" ? \"undefined\" : _typeof(v1)) == 'object') {\n            v1 = {};\n            definedReadOnly(v, v1);\n        }\n        Object.defineProperty(out, p, {\n            get: function get() {\n                return v1;\n            }\n        });\n    };\n\n    for (var p in maps) {\n        _loop(p);\n    }\n}\nconsole.group(\"%c \\u262D TieLiFa (version \" + version + \") \\u262D \", style);\nconsole.log(\"%c Developer \\uD83D\\uDC68 \\u2192 \\u8001\\u8138\\u53D4\\u53D4(Old Face Uncle) \", style);\nconsole.log(\"%c Email \\uD83D\\uDCE7 \\u2192 947734830@qq.com or deaocy@yeah.net \", style);\nconsole.log(\"%c Link \\uD83D\\uDD17 \\u2192 http://github.com/eclipseglory/tielifa \", style);\nconsole.groupEnd();\n\nexports.default = out;\n\n//# sourceURL=webpack://tielifa/./build/EntryPoints.js?");

/***/ }),

/***/ "./build/font/BMFontManager.js":
/*!*************************************!*\
  !*** ./build/font/BMFontManager.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BMFontParser = __webpack_require__(/*! ./BMFontParser.js */ \"./build/font/BMFontParser.js\");\n\nvar _BMFontParser2 = _interopRequireDefault(_BMFontParser);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar instance = null;\n\nvar BMFontManager = function () {\n    function BMFontManager() {\n        _classCallCheck(this, BMFontManager);\n\n        this.pageImages = [];\n        this.fontImageMap = {};\n        this.fontMap = {};\n        this.loadCount = 0;\n    }\n\n    _createClass(BMFontManager, [{\n        key: 'getBMFont',\n        value: function getBMFont(fontFamily) {\n            return this.fontMap[fontFamily.trim()];\n        }\n    }, {\n        key: 'getFontImage',\n        value: function getFontImage(fontFamily, id) {\n            return this.fontImageMap[fontFamily.trim()][id];\n        }\n    }, {\n        key: 'loadBMFont',\n        value: function loadBMFont(fntFileURL, textureManager, gl, callbacks) {\n            callbacks = callbacks || {};\n            fntFileURL = fntFileURL.replace(/\\\\/g, '/');\n            var parentDir = '';\n            var index = fntFileURL.lastIndexOf('/');\n            if (index != -1) {\n                parentDir = fntFileURL.slice(0, index);\n                parentDir += '/';\n            }\n            var request = new XMLHttpRequest();\n            request.open('GET', fntFileURL, true);\n            request.responseType = 'text';\n            var that = this;\n            request.onload = function (evt) {\n                if (request.status == 200) {\n                    var _ret = function () {\n                        var loadCount = 0;\n                        var xml = request.responseText;\n                        var font = _BMFontParser2.default.parseXML(xml);\n                        var pageCount = font.pages.length;\n                        if (font == null) {\n                            if (callbacks.fail) {\n                                callbacks.fail('can not parse xml fnt file,make sure it\\'s xml type');\n                                return {\n                                    v: void 0\n                                };\n                            }\n                        } else {\n                            (function () {\n                                var key = font.fontFamily.toLocaleLowerCase().trim();\n                                if (font.isBold) {\n                                    key += '_bold';\n                                }\n                                if (font.isItalic) {\n                                    key += '_italic';\n                                }\n                                that.fontMap[key] = font;\n                                that.fontImageMap[key] = {};\n                                loadCount = 0;\n\n                                var _loop = function _loop(i) {\n                                    var page = font.pages[i];\n                                    var image = new Image();\n                                    image.pageId = page.id;\n                                    image.onload = function (evt) {\n                                        var img = evt.target;\n                                        that.fontImageMap[key][img.pageId] = img;\n                                        textureManager.registerTexture(null, gl, image);\n                                        loadCount++;\n                                        if (loadCount == pageCount) {\n                                            // 说明全部加载完毕\n                                            if (callbacks.success) {\n                                                callbacks.success();\n                                            }\n                                        }\n                                    };\n                                    image.onerror = function (evt) {\n                                        if (callbacks.fail) {\n                                            callbacks.fail('cant load image', evt);\n                                        }\n                                    };\n                                    image.src = parentDir + page.file;\n                                };\n\n                                for (var i = 0; i < font.pages.length; i++) {\n                                    _loop(i);\n                                }\n                            })();\n                        }\n                    }();\n\n                    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n                } else {\n                    if (callbacks.fail) {\n                        callbacks.fail(request.statusText);\n                    }\n                }\n            };\n            request.send(null);\n            if (callbacks.complete) {\n                callbacks.complete();\n            }\n        }\n\n        /**\r\n         * @deprecated\r\n         * @param textureManager\r\n         * @param gl\r\n         */\n\n    }, {\n        key: 'initDefaultFont',\n        value: function initDefaultFont(textureManager, gl) {\n            // let font = BMFontParser.parseXML(defaultXML);\n            // let key = font.fontFamily.toLocaleLowerCase().trim();\n            // if (font.isBold) {\n            //     key += '_bold';\n            // }\n            // if (font.isItalic) {\n            //     key += '_italic';\n            // }\n            // this.fontMap[key] = font;\n            // this.fontImageMap[key] = {};\n            // this.loadCount = 0;\n            // for (let i = 0; i < font.pages.length; i++) {\n            //     let page = font.pages[i];\n            //     // 内置的是base64的文件\n            //     let image = new Image();\n            //     image.pageId = page.id;\n            //     let that = this;\n            //     image.onload = function (evt) {\n            //         let img = evt.target;\n            //         that.fontImageMap[key][img.pageId] = img;\n            //         textureManager.registerImageData(img, gl, true);\n            //         that.loadCount++;\n            //     };\n            //     image.src = this.pageImages[page.id];\n            // }\n            // return;\n        }\n    }]);\n\n    return BMFontManager;\n}();\n\nexports.default = BMFontManager;\n\n//# sourceURL=webpack://tielifa/./build/font/BMFontManager.js?");

/***/ }),

/***/ "./build/font/BMFontParser.js":
/*!************************************!*\
  !*** ./build/font/BMFontParser.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TAG_FONT = 'font';\nvar TAG_INFO = 'info';\nvar TAG_COMMON = 'common';\nvar ATT_FACE = 'face';\nvar ATT_SIZE = 'size';\n\nvar BMFontParser = function () {\n    function BMFontParser() {\n        _classCallCheck(this, BMFontParser);\n    }\n\n    _createClass(BMFontParser, null, [{\n        key: 'parseXML',\n        value: function parseXML(content) {\n            var parser = new DOMParser();\n            var xmlDoc = parser.parseFromString(content, \"text/xml\");\n            var root = xmlDoc.getElementsByTagName(TAG_FONT);\n            if (root == null) return null;\n\n            var font = {\n                fontFamily: null, size: 0, isBold: false, isItalic: false, charset: null, isUnicode: false,\n                stretchH: 0, isSmooth: false, aa: 0, leftPadding: 0, topPadding: 0, rightPadding: 0, bottomPadding: 0,\n                leftSpacing: 0, rightSpacing: 0, outline: 0\n            };\n            // 解析info节点\n            var infos = xmlDoc.getElementsByTagName(TAG_INFO);\n            if (infos == null || infos.length == 0) return null;\n            var info = infos[0];\n            font.fontFamily = info.getAttribute(ATT_FACE);\n            font.size = Number.parseInt(info.getAttribute(ATT_SIZE));\n            font.isBold = Number.parseInt(info.getAttribute(\"bold\")) == 1;\n            font.isItalic = Number.parseInt(info.getAttribute(\"italic\")) == 1;\n            font.charset = info.getAttribute(\"charset\");\n            font.isUnicode = Number.parseInt(info.getAttribute(\"unicode\")) == 1;\n            font.stretchH = Number.parseInt(info.getAttribute(\"stretchH\"));\n            font.isSmooth = Number.parseInt(info.getAttribute(\"smooth\")) == 1;\n            font.aa = Number.parseInt(info.getAttribute(\"aa\"));\n            var paddingStr = info.getAttribute('padding');\n            var paddingArray = paddingStr.split(',');\n            font.leftPadding = Number.parseInt(paddingArray[0]);\n            font.rightPadding = Number.parseInt(paddingArray[1]);\n            font.topPadding = Number.parseInt(paddingArray[2]);\n            font.bottomPadding = Number.parseInt(paddingArray[3]);\n\n            var spacingStr = info.getAttribute('spacing');\n            var spacingArray = spacingStr.split(',');\n            font.leftSpacing = Number.parseInt(spacingArray[0]);\n            font.rightSpacing = Number.parseInt(spacingArray[1]);\n\n            font.outline = Number.parseInt(info.getAttribute(\"outline\"));\n\n            // 解析common节点\n            var commons = xmlDoc.getElementsByTagName(TAG_COMMON);\n            if (commons == null || commons.length == 0) return null;\n            var c = commons[0];\n            var common = {\n                lineHeight: 0,\n                base: 0,\n                scaleW: 0,\n                scaleH: 0,\n                pages: 0,\n                packed: 0,\n                alphaChnl: 0,\n                redChnl: 0,\n                greenChnl: 0,\n                blueChnl: 0\n            };\n            common.lineHeight = Number.parseInt(c.getAttribute(\"lineHeight\"));\n            common.base = Number.parseInt(c.getAttribute(\"base\"));\n            common.scaleW = Number.parseInt(c.getAttribute(\"scaleW\"));\n            common.scaleH = Number.parseInt(c.getAttribute(\"scaleH\"));\n            common.pages = Number.parseInt(c.getAttribute(\"pages\"));\n            common.alphaChnl = Number.parseInt(c.getAttribute(\"alphaChnl\"));\n            common.redChnl = Number.parseInt(c.getAttribute(\"redChnl\"));\n            common.greenChnl = Number.parseInt(c.getAttribute(\"greenChnl\"));\n            common.blueChnl = Number.parseInt(c.getAttribute(\"blueChnl\"));\n            font.common = common;\n\n            // 解析pages节点\n            var pagesNode = xmlDoc.getElementsByTagName('pages');\n            if (pagesNode == null || pagesNode.length == 0) return null;\n            var pages = pagesNode[0];\n            font.pages = [];\n            for (var i = 0; i < pages.childNodes.length; i++) {\n                var page = pages.childNodes[i];\n                if (page.nodeType == Node.ELEMENT_NODE) {\n                    var p = {};\n                    p.file = page.getAttribute('file');\n                    p.id = Number.parseInt(page.getAttribute(\"id\"));\n                    font.pages.push(p);\n                }\n            }\n            // 解析chars\n            var charsNodes = xmlDoc.getElementsByTagName('chars');\n            if (charsNodes == null || charsNodes.length == 0) return font;\n            var charsNode = charsNodes[0];\n            font.charsCount = Number.parseInt(charsNode.getAttribute('count'));\n            font.chars = [];\n            for (var _i = 0; _i < charsNode.childNodes.length; _i++) {\n                var charNode = charsNode.childNodes[_i];\n                if (charNode.nodeType == Node.TEXT_NODE) continue;\n                var char = {};\n                char.id = Number.parseInt(charNode.getAttribute(\"id\"));\n                char.x = Number.parseInt(charNode.getAttribute(\"x\"));\n                char.y = Number.parseInt(charNode.getAttribute(\"y\"));\n                char.width = Number.parseInt(charNode.getAttribute(\"width\"));\n                char.height = Number.parseInt(charNode.getAttribute(\"height\"));\n                char.xoffset = Number.parseInt(charNode.getAttribute(\"xoffset\"));\n                char.yoffset = Number.parseInt(charNode.getAttribute(\"yoffset\"));\n                char.xadvance = Number.parseInt(charNode.getAttribute(\"xadvance\"));\n                char.page = Number.parseInt(charNode.getAttribute(\"page\"));\n                char.chnl = Number.parseInt(charNode.getAttribute(\"chnl\"));\n                font.chars[char.id] = char;\n            }\n\n            //解析kernings\n            var kerningsNodes = xmlDoc.getElementsByTagName('kernings');\n            if (kerningsNodes == null || kerningsNodes.length == 0) return font;\n            var kerningsNode = kerningsNodes[0];\n            font.kerningsCount = Number.parseInt(kerningsNode.getAttribute('count'));\n            font.kernings = [];\n            for (var _i2 = 0; _i2 < kerningsNode.childNodes.length; _i2++) {\n                var kerningNode = kerningsNode.childNodes[_i2];\n                if (kerningNode.nodeType == Node.TEXT_NODE) continue;\n                var kerning = {};\n                kerning.first = Number.parseInt(kerningNode.getAttribute(\"first\"));\n                kerning.second = Number.parseInt(kerningNode.getAttribute(\"second\"));\n                kerning.amount = Number.parseInt(kerningNode.getAttribute(\"amount\"));\n                font.kernings.push(kerning);\n            }\n            font.kernings.sort(function (a, b) {\n                if (a.first - b.first == 0) {\n                    return a.second - b.second;\n                } else {\n                    return a.first - b.first;\n                }\n            });\n            return font;\n        }\n    }]);\n\n    return BMFontParser;\n}();\n\nexports.default = BMFontParser;\n\n//# sourceURL=webpack://tielifa/./build/font/BMFontParser.js?");

/***/ }),

/***/ "./build/geometry/EarClipping.js":
/*!***************************************!*\
  !*** ./build/geometry/EarClipping.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Node = __webpack_require__(/*! ./Node.js */ \"./build/geometry/Node.js\");\n\nvar _Node2 = _interopRequireDefault(_Node);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EarClipping = function () {\n    function EarClipping() {\n        _classCallCheck(this, EarClipping);\n    }\n\n    _createClass(EarClipping, null, [{\n        key: 'earcut',\n        value: function earcut(backMapData, holeIndices, dim) {\n\n            dim = dim || 2;\n\n            var hasHoles = holeIndices && holeIndices.length,\n                outerLen = hasHoles ? holeIndices[0] * dim : backMapData.length,\n                outerNode = this.linkedList(backMapData, 0, outerLen, dim, true),\n                triangles = [];\n\n            if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n            var minX = void 0,\n                minY = void 0,\n                maxX = void 0,\n                maxY = void 0,\n                x = void 0,\n                y = void 0,\n                invSize = void 0;\n\n            if (hasHoles) outerNode = this.eliminateHoles(backMapData, holeIndices, outerNode, dim);\n\n            // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n            if (backMapData.length > 80 * dim) {\n                minX = maxX = backMapData[0];\n                minY = maxY = backMapData[1];\n\n                for (var i = dim; i < outerLen; i += dim) {\n                    x = backMapData[i];\n                    y = backMapData[i + 1];\n                    if (x < minX) minX = x;\n                    if (y < minY) minY = y;\n                    if (x > maxX) maxX = x;\n                    if (y > maxY) maxY = y;\n                }\n\n                // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n                invSize = Math.max(maxX - minX, maxY - minY);\n                invSize = invSize !== 0 ? 1 / invSize : 0;\n            }\n\n            this.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n            return triangles;\n        }\n\n        // create a circular doubly linked list from polygon points in the specified winding order\n\n    }, {\n        key: 'linkedList',\n        value: function linkedList(backMapData, start, end, dim, clockwise) {\n            var i, last;\n\n            if (clockwise === EarClipping.signedArea(backMapData, start, end, dim) > 0) {\n                for (i = start; i < end; i += dim) {\n                    last = this.insertNode(i, backMapData[i], backMapData[i + 1], last);\n                }\n            } else {\n                for (i = end - dim; i >= start; i -= dim) {\n                    last = this.insertNode(i, backMapData[i], backMapData[i + 1], last);\n                }\n            }\n\n            if (last && EarClipping.equals(last, last.next)) {\n                this.removeNode(last);\n                last = last.next;\n            }\n\n            return last;\n        }\n\n        // eliminate colinear or duplicate points\n\n    }, {\n        key: 'filterPoints',\n        value: function filterPoints(start, end) {\n            if (!start) return start;\n            if (!end) end = start;\n\n            var p = start,\n                again;\n            do {\n                again = false;\n\n                if (!p.steiner && (EarClipping.equals(p, p.next) || EarClipping.area(p.prev, p, p.next) === 0)) {\n                    this.removeNode(p);\n                    p = end = p.prev;\n                    if (p === p.next) break;\n                    again = true;\n                } else {\n                    p = p.next;\n                }\n            } while (again || p !== end);\n\n            return end;\n        }\n\n        // main ear slicing loop which triangulates a polygon (given as a linked list)\n\n    }, {\n        key: 'earcutLinked',\n        value: function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n            if (!ear) return;\n\n            // interlink polygon nodes in z-order\n            if (!pass && invSize) this.indexCurve(ear, minX, minY, invSize);\n\n            var stop = ear,\n                prev,\n                next;\n\n            // iterate through ears, slicing them one by one\n            while (ear.prev !== ear.next) {\n                prev = ear.prev;\n                next = ear.next;\n\n                if (invSize ? this.isEarHashed(ear, minX, minY, invSize) : this.isEar(ear)) {\n                    // cut off the triangle\n                    triangles.push(prev.i / dim);\n                    triangles.push(ear.i / dim);\n                    triangles.push(next.i / dim);\n\n                    this.removeNode(ear);\n\n                    // skipping the next vertex leads to less sliver triangles\n                    ear = next.next;\n                    stop = next.next;\n\n                    continue;\n                }\n\n                ear = next;\n\n                // if we looped through the whole remaining polygon and can't find any more ears\n                if (ear === stop) {\n                    // try filtering points and slicing again\n                    if (!pass) {\n                        this.earcutLinked(this.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                        // if this didn't work, try curing all small self-intersections locally\n                    } else if (pass === 1) {\n                        ear = this.cureLocalIntersections(ear, triangles, dim);\n                        this.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                        // as a last resort, try splitting the remaining polygon into two\n                    } else if (pass === 2) {\n                        this.splitEarcut(ear, triangles, dim, minX, minY, invSize);\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        // check whether a polygon node forms a valid ear with adjacent nodes\n\n    }, {\n        key: 'isEar',\n        value: function isEar(ear) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // now make sure we don't have other points inside the potential ear\n            var p = ear.next.next;\n\n            while (p !== ear.prev) {\n                if (this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.next;\n            }\n\n            return true;\n        }\n    }, {\n        key: 'isEarHashed',\n        value: function isEarHashed(ear, minX, minY, invSize) {\n            var a = ear.prev,\n                b = ear,\n                c = ear.next;\n\n            if (this.area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n            // triangle bbox; min & max are calculated like this for speed\n            var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x,\n                minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y,\n                maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x,\n                maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n\n            // z-order range for the current triangle bbox;\n            var minZ = this.zOrder(minTX, minTY, minX, minY, invSize),\n                maxZ = this.zOrder(maxTX, maxTY, minX, minY, invSize);\n\n            var p = ear.prevZ,\n                n = ear.nextZ;\n\n            // look for points inside the triangle in both directions\n            while (p && p.z >= minZ && n && n.z <= maxZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            // look for remaining points in decreasing z-order\n            while (p && p.z >= minZ) {\n                if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && EarClipping.area(p.prev, p, p.next) >= 0) return false;\n                p = p.prevZ;\n            }\n\n            // look for remaining points in increasing z-order\n            while (n && n.z <= maxZ) {\n                if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && EarClipping.area(n.prev, n, n.next) >= 0) return false;\n                n = n.nextZ;\n            }\n\n            return true;\n        }\n\n        // go through all polygon nodes and cure small local self-intersections\n\n    }, {\n        key: 'cureLocalIntersections',\n        value: function cureLocalIntersections(start, triangles, dim) {\n            var p = start;\n            do {\n                var a = p.prev,\n                    b = p.next.next;\n\n                if (!EarClipping.equals(a, b) && this.intersects(a, p, p.next, b) && this.locallyInside(a, b) && this.locallyInside(b, a)) {\n\n                    triangles.push(a.i / dim);\n                    triangles.push(p.i / dim);\n                    triangles.push(b.i / dim);\n\n                    // remove two nodes involved\n                    this.removeNode(p);\n                    this.removeNode(p.next);\n\n                    p = start = b;\n                }\n                p = p.next;\n            } while (p !== start);\n\n            return p;\n        }\n\n        // try splitting polygon into two and triangulate them independently\n\n    }, {\n        key: 'splitEarcut',\n        value: function splitEarcut(start, triangles, dim, minX, minY, invSize) {\n            // look for a valid diagonal that divides the polygon into two\n            var a = start;\n            do {\n                var b = a.next.next;\n                while (b !== a.prev) {\n                    if (a.i !== b.i && this.isValidDiagonal(a, b)) {\n                        // split the polygon in two by the diagonal\n                        var c = this.splitPolygon(a, b);\n\n                        // filter colinear points around the cuts\n                        a = this.filterPoints(a, a.next);\n                        c = this.filterPoints(c, c.next);\n\n                        // run earcut on each half\n                        this.earcutLinked(a, triangles, dim, minX, minY, invSize);\n                        this.earcutLinked(c, triangles, dim, minX, minY, invSize);\n                        return;\n                    }\n                    b = b.next;\n                }\n                a = a.next;\n            } while (a !== start);\n        }\n\n        // link every hole into the outer loop, producing a single-ring polygon without holes\n\n    }, {\n        key: 'eliminateHoles',\n        value: function eliminateHoles(backMapData, holeIndices, outerNode, dim) {\n            var queue = [],\n                i,\n                len,\n                start,\n                end,\n                list;\n\n            for (i = 0, len = holeIndices.length; i < len; i++) {\n                start = holeIndices[i] * dim;\n                end = i < len - 1 ? holeIndices[i + 1] * dim : backMapData.length;\n                list = this.linkedList(backMapData, start, end, dim, false);\n                if (list === list.next) list.steiner = true;\n                queue.push(this.getLeftmost(list));\n            }\n\n            queue.sort(this.compareX);\n\n            // process holes from left to right\n            for (i = 0; i < queue.length; i++) {\n                this.eliminateHole(queue[i], outerNode);\n                outerNode = this.filterPoints(outerNode, outerNode.next);\n            }\n\n            return outerNode;\n        }\n    }, {\n        key: 'compareX',\n        value: function compareX(a, b) {\n            return a.x - b.x;\n        }\n\n        // find a bridge between vertices that connects hole with an outer ring and and link it\n\n    }, {\n        key: 'eliminateHole',\n        value: function eliminateHole(hole, outerNode) {\n            outerNode = this.findHoleBridge(hole, outerNode);\n            if (outerNode) {\n                var b = this.splitPolygon(outerNode, hole);\n                this.filterPoints(b, b.next);\n            }\n        }\n\n        // David Eberly's algorithm for finding a bridge between hole and outer polygon\n\n    }, {\n        key: 'findHoleBridge',\n        value: function findHoleBridge(hole, outerNode) {\n            var p = outerNode,\n                hx = hole.x,\n                hy = hole.y,\n                qx = -Infinity,\n                m;\n\n            // find a segment intersected by a ray from the hole's leftmost point to the left;\n            // segment's endpoint with lesser x will be potential connection point\n            do {\n                if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n                    var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n                    if (x <= hx && x > qx) {\n                        qx = x;\n                        if (x === hx) {\n                            if (hy === p.y) return p;\n                            if (hy === p.next.y) return p.next;\n                        }\n                        m = p.x < p.next.x ? p : p.next;\n                    }\n                }\n                p = p.next;\n            } while (p !== outerNode);\n\n            if (!m) return null;\n\n            if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n            // look for points inside the triangle of hole point, segment intersection and endpoint;\n            // if there are no points found, we have a valid connection;\n            // otherwise choose the point of the minimum angle with the ray as connection point\n\n            var stop = m,\n                mx = m.x,\n                my = m.y,\n                tanMin = Infinity,\n                tan;\n\n            p = m.next;\n\n            while (p !== stop) {\n                if (hx >= p.x && p.x >= mx && hx !== p.x && this.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n                    tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n                    if ((tan < tanMin || tan === tanMin && p.x > m.x) && this.locallyInside(p, hole)) {\n                        m = p;\n                        tanMin = tan;\n                    }\n                }\n\n                p = p.next;\n            }\n\n            return m;\n        }\n\n        // interlink polygon nodes in z-order\n\n    }, {\n        key: 'indexCurve',\n        value: function indexCurve(start, minX, minY, invSize) {\n            var p = start;\n            do {\n                if (p.z === null) p.z = this.zOrder(p.x, p.y, minX, minY, invSize);\n                p.prevZ = p.prev;\n                p.nextZ = p.next;\n                p = p.next;\n            } while (p !== start);\n\n            p.prevZ.nextZ = null;\n            p.prevZ = null;\n\n            this.sortLinked(p);\n        }\n\n        // Simon Tatham's linked list merge sort algorithm\n        // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\n\n    }, {\n        key: 'sortLinked',\n        value: function sortLinked(list) {\n            var i,\n                p,\n                q,\n                e,\n                tail,\n                numMerges,\n                pSize,\n                qSize,\n                inSize = 1;\n\n            do {\n                p = list;\n                list = null;\n                tail = null;\n                numMerges = 0;\n\n                while (p) {\n                    numMerges++;\n                    q = p;\n                    pSize = 0;\n                    for (i = 0; i < inSize; i++) {\n                        pSize++;\n                        q = q.nextZ;\n                        if (!q) break;\n                    }\n                    qSize = inSize;\n\n                    while (pSize > 0 || qSize > 0 && q) {\n\n                        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                            e = p;\n                            p = p.nextZ;\n                            pSize--;\n                        } else {\n                            e = q;\n                            q = q.nextZ;\n                            qSize--;\n                        }\n\n                        if (tail) tail.nextZ = e;else list = e;\n\n                        e.prevZ = tail;\n                        tail = e;\n                    }\n\n                    p = q;\n                }\n\n                tail.nextZ = null;\n                inSize *= 2;\n            } while (numMerges > 1);\n\n            return list;\n        }\n\n        // z-order of a point given coords and inverse of the longer side of backMapData bbox\n\n    }, {\n        key: 'zOrder',\n        value: function zOrder(x, y, minX, minY, invSize) {\n            // coords are transformed into non-negative 15-bit integer range\n            x = 32767 * (x - minX) * invSize;\n            y = 32767 * (y - minY) * invSize;\n\n            x = (x | x << 8) & 0x00FF00FF;\n            x = (x | x << 4) & 0x0F0F0F0F;\n            x = (x | x << 2) & 0x33333333;\n            x = (x | x << 1) & 0x55555555;\n\n            y = (y | y << 8) & 0x00FF00FF;\n            y = (y | y << 4) & 0x0F0F0F0F;\n            y = (y | y << 2) & 0x33333333;\n            y = (y | y << 1) & 0x55555555;\n\n            return x | y << 1;\n        }\n\n        // find the leftmost node of a polygon ring\n\n    }, {\n        key: 'getLeftmost',\n        value: function getLeftmost(start) {\n            var p = start,\n                leftmost = start;\n            do {\n                if (p.x < leftmost.x) leftmost = p;\n                p = p.next;\n            } while (p !== start);\n\n            return leftmost;\n        }\n\n        // check if a point lies within a convex triangle\n\n    }, {\n        key: 'pointInTriangle',\n        value: function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n            return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n        }\n\n        // check if a diagonal between two polygon nodes is valid (lies in polygon interior)\n\n    }, {\n        key: 'isValidDiagonal',\n        value: function isValidDiagonal(a, b) {\n            return a.next.i !== b.i && a.prev.i !== b.i && !this.intersectsPolygon(a, b) && this.locallyInside(a, b) && this.locallyInside(b, a) && this.middleInside(a, b);\n        }\n\n        // signed area of a triangle\n\n    }, {\n        key: 'area',\n        value: function area(p, q, r) {\n            return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        }\n\n        // check if two points are equal\n\n    }, {\n        key: 'equals',\n        value: function equals(p1, p2) {\n            return p1.x === p2.x && p1.y === p2.y;\n        }\n\n        // check if two segments intersect\n\n    }, {\n        key: 'intersects',\n        value: function intersects(p1, q1, p2, q2) {\n            if (EarClipping.equals(p1, q1) && EarClipping.equals(p2, q2) || EarClipping.equals(p1, q2) && EarClipping.equals(p2, q1)) return true;\n            return EarClipping.area(p1, q1, p2) > 0 !== EarClipping.area(p1, q1, q2) > 0 && EarClipping.area(p2, q2, p1) > 0 !== EarClipping.area(p2, q2, q1) > 0;\n        }\n\n        // check if a polygon diagonal intersects any polygon segments\n\n    }, {\n        key: 'intersectsPolygon',\n        value: function intersectsPolygon(a, b) {\n            var p = a;\n            do {\n                if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && this.intersects(p, p.next, a, b)) return true;\n                p = p.next;\n            } while (p !== a);\n\n            return false;\n        }\n\n        // check if a polygon diagonal is locally inside the polygon\n\n    }, {\n        key: 'locallyInside',\n        value: function locallyInside(a, b) {\n            return EarClipping.area(a.prev, a, a.next) < 0 ? EarClipping.area(a, b, a.next) >= 0 && EarClipping.area(a, a.prev, b) >= 0 : EarClipping.area(a, b, a.prev) < 0 || EarClipping.area(a, a.next, b) < 0;\n        }\n\n        // check if the middle point of a polygon diagonal is inside the polygon\n\n    }, {\n        key: 'middleInside',\n        value: function middleInside(a, b) {\n            var p = a,\n                inside = false,\n                px = (a.x + b.x) / 2,\n                py = (a.y + b.y) / 2;\n            do {\n                if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;\n                p = p.next;\n            } while (p !== a);\n\n            return inside;\n        }\n\n        // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n        // if one belongs to the outer ring and another to a hole, it merges it into a single ring\n\n    }, {\n        key: 'splitPolygon',\n        value: function splitPolygon(a, b) {\n            var a2 = new _Node2.default(a.i, a.x, a.y),\n                b2 = new _Node2.default(b.i, b.x, b.y),\n                an = a.next,\n                bp = b.prev;\n\n            a.next = b;\n            b.prev = a;\n\n            a2.next = an;\n            an.prev = a2;\n\n            b2.next = a2;\n            a2.prev = b2;\n\n            bp.next = b2;\n            b2.prev = bp;\n\n            return b2;\n        }\n\n        // create a node and optionally link it with previous one (in a circular doubly linked list)\n\n    }, {\n        key: 'insertNode',\n        value: function insertNode(i, x, y, last) {\n            var p = new _Node2.default(i, x, y);\n\n            if (!last) {\n                p.prev = p;\n                p.next = p;\n            } else {\n                p.next = last.next;\n                p.prev = last;\n                last.next.prev = p;\n                last.next = p;\n            }\n            return p;\n        }\n    }, {\n        key: 'removeNode',\n        value: function removeNode(p) {\n            p.next.prev = p.prev;\n            p.prev.next = p.next;\n\n            if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n            if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n        }\n    }, {\n        key: 'signedArea',\n        value: function signedArea(backMapData, start, end, dim) {\n            var sum = 0;\n            for (var i = start, j = end - dim; i < end; i += dim) {\n                sum += (backMapData[j] - backMapData[i]) * (backMapData[i + 1] + backMapData[j + 1]);\n                j = i;\n            }\n            return sum;\n        }\n\n        // return a percentage difference between the polygon area and its triangulation area;\n        // used to verify correctness of triangulation\n\n    }, {\n        key: 'deviation',\n        value: function deviation(backMapData, holeIndices, dim, triangles) {\n            var hasHoles = holeIndices && holeIndices.length;\n            var outerLen = hasHoles ? holeIndices[0] * dim : backMapData.length;\n\n            var polygonArea = Math.abs(this.signedArea(backMapData, 0, outerLen, dim));\n            if (hasHoles) {\n                for (var i = 0, len = holeIndices.length; i < len; i++) {\n                    var start = holeIndices[i] * dim;\n                    var end = i < len - 1 ? holeIndices[i + 1] * dim : backMapData.length;\n                    polygonArea -= Math.abs(this.signedArea(backMapData, start, end, dim));\n                }\n            }\n\n            var trianglesArea = 0;\n            for (i = 0; i < triangles.length; i += 3) {\n                var a = triangles[i] * dim;\n                var b = triangles[i + 1] * dim;\n                var c = triangles[i + 2] * dim;\n                trianglesArea += Math.abs((backMapData[a] - backMapData[c]) * (backMapData[b + 1] - backMapData[a + 1]) - (backMapData[a] - backMapData[b]) * (backMapData[c + 1] - backMapData[a + 1]));\n            }\n\n            return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);\n        }\n    }, {\n        key: 'flatten',\n\n\n        // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form EarClipping accepts\n        value: function flatten(backMapData) {\n            var dim = backMapData[0][0].length,\n                result = { vertices: [], holes: [], dimensions: dim },\n                holeIndex = 0;\n\n            for (var i = 0; i < backMapData.length; i++) {\n                for (var j = 0; j < backMapData[i].length; j++) {\n                    for (var d = 0; d < dim; d++) {\n                        result.vertices.push(backMapData[i][j][d]);\n                    }\n                }\n                if (i > 0) {\n                    holeIndex += backMapData[i - 1].length;\n                    result.holes.push(holeIndex);\n                }\n            }\n            return result;\n        }\n    }]);\n\n    return EarClipping;\n}();\n\nexports.default = EarClipping;\n\n//# sourceURL=webpack://tielifa/./build/geometry/EarClipping.js?");

/***/ }),

/***/ "./build/geometry/GeometryTools.js":
/*!*****************************************!*\
  !*** ./build/geometry/GeometryTools.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ../math/Vector3.js */ \"./build/math/Vector3.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat3.js */ \"./build/math/Mat3.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Vector3 = __webpack_require__(/*! ../math/Vector2.js */ \"./build/math/Vector2.js\");\n\nvar _Vector4 = _interopRequireDefault(_Vector3);\n\nvar _Mat3 = __webpack_require__(/*! ../math/Mat4.js */ \"./build/math/Mat4.js\");\n\nvar _Mat4 = _interopRequireDefault(_Mat3);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TEMP_VET3 = [new _Vector2.default()];\nvar TEMP_MAT3 = [_Mat2.default.identity()];\n\nvar GeometryTools = function () {\n    function GeometryTools() {\n        _classCallCheck(this, GeometryTools);\n    }\n\n    _createClass(GeometryTools, null, [{\n        key: \"getProjectionPointOnLine\",\n        value: function getProjectionPointOnLine(point, linep1, linep2) {\n            var temp = _Vector4.default.TEMP_VECTORS[0];\n            temp.x = linep2.x - linep1.x;\n            temp.y = linep2.y - linep1.y;\n            _Vector4.default.normalize(temp, temp);\n            var temp1 = _Vector4.default.TEMP_VECTORS[1];\n            temp1.x = point.x - linep1.x;\n            temp1.y = point.y - linep1.y;\n            var d = _Vector4.default.dot(temp1, temp);\n            _Vector4.default.multiplyValue(temp, temp, d);\n            var out = { x: 0, y: 0 };\n            _Vector4.default.plus(out, temp, linep1);\n            return out;\n        }\n    }, {\n        key: \"cubicBezier\",\n        value: function cubicBezier(t, p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y, out) {\n            // b(t) = (1-t)^3p0 + 3(1-t)^2tp1+3(1-t)t^2p2+t^3p3\n            out = out || [0, 0];\n            var t1 = 1 - t;\n            var x = t1 * t1 * t1 * p0x;\n            x += 3 * t1 * t1 * t * p1x;\n            x += 3 * t1 * t * t * p2x;\n            x += t * t * t * p3x;\n\n            var y = t1 * t1 * t1 * p0y;\n            y += 3 * t1 * t1 * t * p1y;\n            y += 3 * t1 * t * t * p2y;\n            y += t * t * t * p3y;\n            out[0] = x;\n            out[1] = y;\n            return out;\n        }\n    }, {\n        key: \"quadraticBezier\",\n        value: function quadraticBezier(t, p0x, p0y, p1x, p1y, p2x, p2y, out) {\n            // b(t) = (1-t)^2p0 + 2(1-t)tp1+t^2p2\n            out = out || [0, 0];\n            var t1 = 1 - t;\n            var x = t1 * t1 * p0x;\n            x += 2 * t1 * t * p1x;\n            x += t * t * p2x;\n            out[0] = x;\n\n            var y = t1 * t1 * p0y;\n            y += 2 * t1 * t * p1y;\n            y += t * t * p2y;\n            out[1] = y;\n\n            return out;\n        }\n\n        /**\r\n         * 计算过椭圆上某两点的椭圆圆心以及两点对应的角度\r\n         * 计算圆心和夹角方法和公式：https://www.w3.org/TR/SVG/implnote.html#ArcConversionEndpointToCenter\r\n         * @param x1 椭圆上某点1 x\r\n         * @param y1 椭圆上某点1 y\r\n         * @param x2 椭圆上某点2 x\r\n         * @param y2 椭圆上某点2 y\r\n         * @param radiusX 椭圆横向半径\r\n         * @param radiusY 椭圆纵向半径\r\n         * @param rotation 椭圆旋转弧度\r\n         * @returns {{x: number, y: number, theta: number, deltaTheta: number}}\r\n         */\n\n    }, {\n        key: \"arcConversionEndpointToCenter\",\n        value: function arcConversionEndpointToCenter(x1, y1, x2, y2, radiusX, radiusY, rotation) {\n            var fa = 0;\n            var fs = 1;\n            var v = [(x1 - x2) / 2, (y1 - y2) / 2, 1];\n            var m = TEMP_MAT3[0];\n            if (rotation != 0) {\n                _Mat2.default.rotate(m, -rotation);\n                _Mat2.default.multiplyWithVertex(m, m, v);\n                v[0] = m[0];\n                v[1] = m[1];\n            }\n\n            var scaleUp = radiusX * radiusX * radiusY * radiusY / (radiusX * radiusX * v[1] * v[1] + radiusY * radiusY * v[0] * v[0]);\n            scaleUp = Math.abs(scaleUp - 1);\n            if (scaleUp < 0) throw new Error('radius is small, the ellipse does not across these two points');\n            var scale = Math.sqrt(scaleUp);\n            var sign = 1;\n            if (fa == fs) sign = -1;\n            scale *= sign;\n            var v1 = [radiusX * v[1] / radiusY, -radiusY * v[0] / radiusX, 0];\n            v1[0] *= scale;\n            v1[1] *= scale;\n            var c = [v1[0], v1[1], 1];\n            if (rotation != 0) {\n                _Mat2.default.rotate(m, rotation);\n                _Mat2.default.multiplyWithVertex(m, m, c);\n            }\n            var cx = c[0] + (x1 + x2) / 2;\n            var cy = c[1] + (y1 + y2) / 2;\n\n            var u = _Vector4.default.TEMP_VECTORS[0];\n            u.x = 1;\n            u.y = 0;\n            var u1 = _Vector4.default.TEMP_VECTORS[1];\n            u1.x = (v[0] - v1[0]) / radiusX;\n            u1.y = (v[1] - v1[1]) / radiusY;\n\n            var theta = Math.abs(Math.acos(_Vector4.default.dot(u, u1) / (u.magnitude * u1.magnitude)));\n            if (u.x * u1.y < 0) {\n                theta *= -1;\n            }\n            u.x = (-v[0] - v1[0]) / radiusX;\n            u.y = (-v[1] - v1[1]) / radiusY;\n            var deltaTheta = Math.acos(_Vector4.default.dot(u, u1) / (u.magnitude * u1.magnitude));\n            deltaTheta = Math.abs(deltaTheta % (Math.PI * 2));\n            if (fs == 0) deltaTheta *= -1;\n            return { x: cx, y: cy, theta: theta, deltaTheta: deltaTheta };\n        }\n\n        /**\r\n         * 计算平面椭圆上某弧度对应的坐标点\r\n         * @param x\r\n         * @param y\r\n         * @param radiusX\r\n         * @param radiusY\r\n         * @param radian\r\n         * @param rotation\r\n         * @param output\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"getEllipsePointWithRadian\",\n        value: function getEllipsePointWithRadian(x, y, radiusX, radiusY, radian, rotation, output) {\n            output = output || [0, 0];\n            var v = TEMP_VET3[0];\n            v.x = radiusX * Math.cos(radian);\n            v.y = radiusY * Math.sin(radian);\n            v.z = 0;\n            if (rotation != 0) {\n                var m = TEMP_MAT3[0];\n                _Mat2.default.rotate(m, rotation);\n                _Mat2.default.multiplyWithVertex(m, m, v.value);\n                v.x = m[0];\n                v.y = m[1];\n            }\n            output[0] = v.x + x;\n            output[1] = v.y + y;\n            return output;\n        }\n    }, {\n        key: \"getRodriguesRotateMatrix\",\n        value: function getRodriguesRotateMatrix(v1, v2) {\n            // R = I + K sin(theta) + (1- cos(theta)) K^2\n            // K = [0 , -k2 , k1\n            //      k2 , 0 , -k0\n            //      -k1, k0,0 ]\n            // k = normalize(v1 x v2) = [k0,k1,k2]\n            var cos = _Vector2.default.dot(v1, v2);\n            var sin = Math.sin(Math.acos(cos));\n            var k = TEMP_VET3[0];\n            _Vector2.default.cross(k, v1, v2);\n            _Vector2.default.normalize(k, k);\n\n            var r = TEMP_MAT3[0];\n            r[0] = 0;\n            r[1] = -k.value[2];\n            r[2] = k.value[1];\n            r[3] = k.value[2];\n            r[4] = 0;\n            r[5] = -k.value[0];\n            r[6] = -k.value[1];\n            r[7] = k.value[0];\n            r[8] = 0;\n\n            var k1 = _Mat2.default.identity();\n            _Mat2.default.copy(r, k1);\n            var I = _Mat2.default.identity();\n            _Mat2.default.multiplyWithValue(r, r, sin);\n\n            _Mat2.default.multiply(k1, k1, k1);\n            _Mat2.default.multiplyWithValue(k1, k1, 1 - cos);\n            _Mat2.default.plus(k1, k1, r);\n            _Mat2.default.plus(k1, k1, I);\n\n            _Mat2.default.rotateMatrix(k1, k1);\n\n            return _Mat4.default.transformMat3ToMat4(k1);\n        }\n\n        /**\r\n         * 计算空间中线到面的交点\r\n         * 计算方法来自：http://geomalgorithms.com/a05-_intersect-1.html\r\n         * @param n 面的法向量（单位向量）\r\n         * @param u 线的向量 （单位向量）\r\n         * @param p 线上某点\r\n         * @param v 面上某点\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"calculateIntersectionOfPlane\",\n        value: function calculateIntersectionOfPlane(n, u, p, v, out, maxLength) {\n            var down = _Vector2.default.dot(n, u);\n            if (Math.abs(down) == 0) {\n                return null;\n            }\n            var w = TEMP_VET3[0];\n            w.x = v.x - p.x;\n            w.y = v.y - p.y;\n            w.z = v.z - p.z;\n            var length = _Vector2.default.dot(w, n) / down;\n            var sign = length > 0 ? 1 : -1;\n            var realLength = length;\n            if (maxLength != undefined) {\n                if (Math.abs(length) > maxLength) {\n                    realLength = maxLength * sign;\n                }\n            }\n            length = realLength;\n            _Vector2.default.multiplyValue(w, u, length);\n            _Vector2.default.plus(out, w, p);\n            // return out;\n        }\n\n        /**\r\n         * 计算平面上两条线的交点\r\n         * @param p1\r\n         * @param p2\r\n         * @param p3\r\n         * @param p4\r\n         * @returns {*}\r\n         */\n\n    }, {\n        key: \"calculateIntersectionOfTowLines\",\n        value: function calculateIntersectionOfTowLines(p1, p2, p3, p4) {\n            var x1 = p1.x;\n            var y1 = p1.y;\n\n            var x2 = p2.x;\n            var y2 = p2.y;\n\n            var x3 = p3.x;\n            var y3 = p3.y;\n\n            var x4 = p4.x;\n            var y4 = p4.y;\n\n            var share = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n            if (share == 0) return undefined;\n            var px = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);\n            px = px / share;\n\n            var py = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);\n            py = py / share;\n\n            return { x: px, y: py };\n        }\n    }]);\n\n    return GeometryTools;\n}();\n\nexports.default = GeometryTools;\n\n//# sourceURL=webpack://tielifa/./build/geometry/GeometryTools.js?");

/***/ }),

/***/ "./build/geometry/LineToRectangle.js":
/*!*******************************************!*\
  !*** ./build/geometry/LineToRectangle.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Vector = __webpack_require__(/*! ../math/Vector3.js */ \"./build/math/Vector3.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _GeometryTools = __webpack_require__(/*! ./GeometryTools.js */ \"./build/geometry/GeometryTools.js\");\n\nvar _GeometryTools2 = _interopRequireDefault(_GeometryTools);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar p1Temp = new _Vector2.default(0, 0, 0);\nvar p2Temp = new _Vector2.default(0, 0, 0);\n\nvar halfWidth = new Float32Array(1);\n\nvar faceDirectionTemp = new _Vector2.default();\n\nvar lastR1Temp = new _Vector2.default(0, 0, 0);\nvar lastR2Temp = new _Vector2.default(0, 0, 0);\nvar lastR3Temp = new _Vector2.default(0, 0, 0);\nvar lastR4Temp = new _Vector2.default(0, 0, 0);\n\nvar r1Temp = new _Vector2.default(0, 0, 0);\nvar r2Temp = new _Vector2.default(0, 0, 0);\nvar r3Temp = new _Vector2.default(0, 0, 0);\nvar r4Temp = new _Vector2.default(0, 0, 0);\n\nvar firstPoint1 = new _Vector2.default(0, 0, 0);\nvar firstPoint2 = new _Vector2.default(0, 0, 0);\nvar firstPoint3 = new _Vector2.default(0, 0, 0);\nvar firstPoint4 = new _Vector2.default(0, 0, 0);\n\nvar lastPoint1 = new _Vector2.default(0, 0, 0);\nvar lastPoint2 = new _Vector2.default(0, 0, 0);\nvar lastPoint3 = new _Vector2.default(0, 0, 0);\nvar lastPoint4 = new _Vector2.default(0, 0, 0);\n\nvar rayVectorTemp = new _Vector2.default(0, 0, 0);\nvar planeNormalTemp = new _Vector2.default();\n\nvar line1VectorTemp = new _Vector2.default(0, 0, 0);\nvar line2VectorTemp = new _Vector2.default(0, 0, 0);\n\nvar endIndex = 0;\n\nvar LineToRectangle = function () {\n    function LineToRectangle(lineWidth) {\n        _classCallCheck(this, LineToRectangle);\n    }\n\n    _createClass(LineToRectangle, null, [{\n        key: \"generateRectanglesPoints\",\n        value: function generateRectanglesPoints(lineWidth, isClosed, faceDirection, outputInterface, inputInterface) {\n            if (lineWidth == undefined) lineWidth = 1;\n            outputInterface = outputInterface || {};\n            var setPoint = outputInterface.setPoint;\n            var addPoint = outputInterface.addPoint;\n            var rectPoints = [];\n            if (setPoint == undefined) {\n                setPoint = function setPoint(point, index) {\n                    index = index * 3;\n                    rectPoints[index] = point.x;\n                    rectPoints[index + 1] = point.y;\n                    rectPoints[index + 2] = point.z;\n                };\n            }\n            if (addPoint == undefined) {\n                addPoint = function addPoint(point) {\n                    rectPoints.push(point.x);\n                    rectPoints.push(point.y);\n                    rectPoints.push(point.z);\n                };\n            }\n\n            halfWidth[0] = lineWidth / 2;\n            endIndex = 0;\n            if (inputInterface == null || inputInterface.getPointsNum() < 2) {\n                return 0;\n            }\n            // if (points == null || points.length / 3 < 2) {\n            //     return null;\n            // }\n            faceDirectionTemp.x = faceDirection[0];\n            faceDirectionTemp.y = faceDirection[1];\n            faceDirectionTemp.z = faceDirection[2];\n            // let pointsCount = points.length / 3;\n            var pointsCount = inputInterface.getPointsNum();\n            var preRectLastPoints = { r1: null, r2: null, r3: null, r4: null };\n            var lineCount = pointsCount - 1;\n            var that = this;\n            //不确定设定的面朝向法向量是否是单位向量：\n            _Vector2.default.normalize(faceDirectionTemp, faceDirectionTemp);\n            if (isClosed) lineCount++;\n            var dim = 3;\n            for (var i = 0; i < lineCount; i++) {\n                // let index = i * dim;\n                // let x1 = points[index];\n                // let y1 = points[index + 1];\n                // p1Temp.x = x1;\n                // p1Temp.y = y1;\n                // p1Temp.z = points[index + 2];\n                // p1Temp.z = inputInterface.getZ(i);\n\n                p1Temp.x = inputInterface.getX(i);\n                p1Temp.y = inputInterface.getY(i);\n                p1Temp.z = inputInterface.getZ(i);\n\n                // let nextIndex = ((i + 1) * 3);\n                // if (nextIndex >= points.length) nextIndex = 0;\n                var nextPointIndex = i + 1;\n                if (nextPointIndex >= pointsCount) nextPointIndex = 0;\n                // let x2 = points[nextIndex];\n                // let y2 = points[nextIndex + 1];\n                // x2 = inputInterface.getX(nextPointIndex);\n                // y2 = inputInterface.getY(nextPointIndex);\n                // p2Temp.x = x2;\n                // p2Temp.y = y2;\n                // p2Temp.z = points[nextIndex + 2];\n                // p2Temp.z = inputInterface.getZ(nextPointIndex);\n\n                p2Temp.x = inputInterface.getX(nextPointIndex);\n                p2Temp.y = inputInterface.getY(nextPointIndex);\n                p2Temp.z = inputInterface.getZ(nextPointIndex);\n\n                line1VectorTemp.x = p2Temp.x - p1Temp.x;\n                line1VectorTemp.y = p2Temp.y - p1Temp.y;\n                line1VectorTemp.z = p2Temp.z - p1Temp.z;\n                var temp = _Vector2.default.TEMP_VECTORS[0];\n                _Vector2.default.cross(temp, line1VectorTemp, faceDirectionTemp);\n                _Vector2.default.normalize(temp, temp);\n                temp.x *= halfWidth[0];\n                temp.y *= halfWidth[0];\n                temp.z *= halfWidth[0];\n                _Vector2.default.plus(r1Temp, temp, p1Temp);\n                _Vector2.default.plus(r2Temp, temp, p2Temp);\n                // 反向\n                temp.x = -temp.x;\n                temp.y = -temp.y;\n                temp.z = -temp.z;\n                _Vector2.default.plus(r3Temp, temp, p2Temp);\n                _Vector2.default.plus(r4Temp, temp, p1Temp);\n\n                var lastR1 = preRectLastPoints.r1;\n                var lastR4 = preRectLastPoints.r4;\n                var lastR2 = preRectLastPoints.r2;\n                var lastR3 = preRectLastPoints.r3;\n                if (lastR1 != null) {\n                    this.updateConnectPoints(lastR1, lastR2, lastR3, lastR4, r1Temp, r2Temp, r3Temp, r4Temp, i, line1VectorTemp, faceDirectionTemp, rectPoints, setPoint);\n                }\n\n                //组织三角形\n                addPoint(r1Temp, i, 0);\n                addPoint(r2Temp, i, 1);\n                addPoint(r3Temp, i, 2);\n                addPoint(r4Temp, i, 3);\n\n                lastR1Temp.value[0] = r1Temp.value[0];\n                lastR1Temp.value[1] = r1Temp.value[1];\n                lastR1Temp.value[2] = r1Temp.value[2];\n\n                lastR2Temp.value[0] = r2Temp.value[0];\n                lastR2Temp.value[1] = r2Temp.value[1];\n                lastR2Temp.value[2] = r2Temp.value[2];\n\n                lastR3Temp.value[0] = r3Temp.value[0];\n                lastR3Temp.value[1] = r3Temp.value[1];\n                lastR3Temp.value[2] = r3Temp.value[2];\n\n                lastR4Temp.value[0] = r4Temp.value[0];\n                lastR4Temp.value[1] = r4Temp.value[1];\n                lastR4Temp.value[2] = r4Temp.value[2];\n                if (i == 0) {\n                    firstPoint1.value[0] = r1Temp.value[0];\n                    firstPoint1.value[1] = r1Temp.value[1];\n                    firstPoint1.value[2] = r1Temp.value[2];\n\n                    firstPoint2.value[0] = r2Temp.value[0];\n                    firstPoint2.value[1] = r2Temp.value[1];\n                    firstPoint2.value[2] = r2Temp.value[2];\n\n                    firstPoint3.value[0] = r3Temp.value[0];\n                    firstPoint3.value[1] = r3Temp.value[1];\n                    firstPoint3.value[2] = r3Temp.value[2];\n\n                    firstPoint4.value[0] = r4Temp.value[0];\n                    firstPoint4.value[1] = r4Temp.value[1];\n                    firstPoint4.value[2] = r4Temp.value[2];\n                }\n                if (i + 1 == lineCount) {\n                    lastPoint1.value[0] = r1Temp.value[0];\n                    lastPoint1.value[1] = r1Temp.value[1];\n                    lastPoint1.value[2] = r1Temp.value[2];\n\n                    lastPoint2.value[0] = r2Temp.value[0];\n                    lastPoint2.value[1] = r2Temp.value[1];\n                    lastPoint2.value[2] = r2Temp.value[2];\n\n                    lastPoint3.value[0] = r3Temp.value[0];\n                    lastPoint3.value[1] = r3Temp.value[1];\n                    lastPoint3.value[2] = r3Temp.value[2];\n\n                    lastPoint4.value[0] = r4Temp.value[0];\n                    lastPoint4.value[1] = r4Temp.value[1];\n                    lastPoint4.value[2] = r4Temp.value[2];\n                }\n\n                preRectLastPoints.r1 = lastR1Temp;\n                preRectLastPoints.r2 = lastR2Temp;\n                preRectLastPoints.r3 = lastR3Temp;\n                preRectLastPoints.r4 = lastR4Temp;\n            }\n\n            if (isClosed) {\n                //开始和结尾的地方连接点要改一下\n                var _endIndex = lineCount * 4; //rectPoints.length / 3;\n                rayVectorTemp.x = lastPoint2.x - lastPoint1.x;\n                rayVectorTemp.y = lastPoint2.y - lastPoint1.y;\n                rayVectorTemp.z = lastPoint2.z - lastPoint1.z;\n                var u1 = rayVectorTemp;\n                _Vector2.default.normalize(u1, u1);\n                var temp1 = _Vector2.default.TEMP_VECTORS[1];\n                temp1.x = firstPoint1.x - firstPoint2.x;\n                temp1.y = firstPoint1.y - firstPoint2.y;\n                temp1.z = firstPoint1.z - firstPoint2.z;\n                // TODO 如果平行，要跟之前连接点处理一致才行\n                var n = planeNormalTemp;\n                _Vector2.default.cross(n, temp1, faceDirectionTemp);\n                _Vector2.default.normalize(n, n);\n                var _temp = _Vector2.default.TEMP_VECTORS[0];\n                _GeometryTools2.default.calculateIntersectionOfPlane(n, u1, lastPoint2, firstPoint2, _temp);\n                if (_temp != undefined) {\n                    setPoint(_temp, 0);\n                    setPoint(_temp, _endIndex - 3);\n                }\n                u1.x = lastPoint3.x - lastPoint4.x;\n                u1.y = lastPoint3.y - lastPoint4.y;\n                u1.z = lastPoint3.z - lastPoint4.z;\n                _Vector2.default.normalize(u1, u1);\n\n                _GeometryTools2.default.calculateIntersectionOfPlane(n, u1, lastPoint3, firstPoint4, _temp);\n                if (_temp != undefined) {\n                    setPoint(_temp, 3);\n                    setPoint(_temp, _endIndex - 2);\n                }\n            }\n            if (rectPoints.length == 0) {\n                return lineCount;\n            }\n            return rectPoints;\n            // return {rects: rectPoints, end: rectPoints.length};\n        }\n\n        /**@deprecated*/\n\n    }, {\n        key: \"setPointValue\",\n        value: function setPointValue(x, y, z, index, rectPoints) {\n            index = index * 3;\n            rectPoints[index] = x;\n            rectPoints[index + 1] = y;\n            rectPoints[index + 2] = z;\n        }\n    }, {\n        key: \"updateRectPoint\",\n        value: function updateRectPoint(p, p1, lineIndex, rectPoints, setPoint) {\n            lineIndex = lineIndex * 4;\n            var r2Index = lineIndex + 1;\n            var r3Index = r2Index + 1;\n            if (p != null) {\n                setPoint(p, r2Index);\n            }\n            if (p1 != null) {\n                setPoint(p1, r3Index);\n            }\n        }\n    }, {\n        key: \"updateConnectPoints\",\n        value: function updateConnectPoints(lastR1, lastR2, lastR3, lastR4, r1, r2, r3, r4, lineIndex, lineDirection, faceDirection, rectPoints, setPoint) {\n            var maxLength = _Tools2.default.getDistance(lastR2, r1) * 2;\n            var temp = _Vector2.default.TEMP_VECTORS[0];\n            var u1 = rayVectorTemp;\n            u1.x = lastR2.x - lastR1.x;\n            u1.y = lastR2.y - lastR1.y;\n            u1.z = lastR2.z - lastR1.z;\n            _Vector2.default.normalize(u1, u1);\n            // Vector3.normalize(lineDirection, lineDirection);\n            var n = planeNormalTemp;\n            _Vector2.default.cross(n, lineDirection, faceDirection);\n            _Vector2.default.normalize(n, n);\n\n            /*\r\n            * 几乎平行：无法做交点计算，当前线段的矩形的p1和p4改成前一条线的p2,p3\r\n            */\n            var down = _Vector2.default.dot(n, u1);\n            if (Math.abs(down) < _Tools2.default.EPSILON) {\n                r1.x = lastR2.x;\n                r1.y = lastR2.y;\n                r1.z = lastR2.z;\n                r4.x = lastR3.x;\n                r4.y = lastR3.y;\n                r4.z = lastR3.z;\n                return;\n            }\n            /*\r\n             * 这里计算出没有交点时两条线端点距离，作为最大的距离（计算交点时候的向量所放量）\r\n             * 如果距离过大则需要计算，因为有时候两条线趋于平行，会造成计算出的交点特别远，这就让整个图形看上去是错误的\r\n             */\n            _GeometryTools2.default.calculateIntersectionOfPlane(n, u1, lastR2, r1, line2VectorTemp, maxLength);\n            // 此时说明两条线几乎平行无法计算出交点.当前线段的矩形的p1和p4改成前一条线的p2,p3\n            if (line2VectorTemp != null) {\n                //更新上个矩形r2和这个矩形的r1\n                r1.x = line2VectorTemp.x;\n                r1.y = line2VectorTemp.y;\n                r1.z = line2VectorTemp.z;\n            }\n            u1.x = lastR3.x - lastR4.x;\n            u1.y = lastR3.y - lastR4.y;\n            u1.z = lastR3.z - lastR4.z;\n            _Vector2.default.normalize(u1, u1);\n            _GeometryTools2.default.calculateIntersectionOfPlane(n, u1, lastR3, r4, temp, maxLength);\n            if (temp != null) {\n                //更新上个矩形r3和这个矩形的r4\n                r4.x = temp.x;\n                r4.y = temp.y;\n                r4.z = temp.z;\n            }\n            this.updateRectPoint(line2VectorTemp, temp, lineIndex - 1, rectPoints, setPoint);\n        }\n\n        /**@deprecated*/\n\n    }, {\n        key: \"addPoint\",\n        value: function addPoint(point, rectPoints) {\n            rectPoints.push(point.x);\n            rectPoints.push(point.y);\n            rectPoints.push(point.z);\n        }\n    }]);\n\n    return LineToRectangle;\n}();\n\nexports.default = LineToRectangle;\n\n//# sourceURL=webpack://tielifa/./build/geometry/LineToRectangle.js?");

/***/ }),

/***/ "./build/geometry/Node.js":
/*!********************************!*\
  !*** ./build/geometry/Node.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n        value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Node = function Node(i, x, y) {\n        _classCallCheck(this, Node);\n\n        // vertex index in coordinates array\n        this.i = i;\n\n        // vertex coordinates\n        this.x = x;\n        this.y = y;\n\n        // previous and next vertex nodes in a polygon ring\n        this.prev = null;\n        this.next = null;\n\n        // z-order curve value\n        this.z = null;\n\n        // previous and next nodes in z-order\n        this.prevZ = null;\n        this.nextZ = null;\n\n        // indicates whether this is a steiner point\n        this.steiner = false;\n};\n\nexports.default = Node;\n\n//# sourceURL=webpack://tielifa/./build/geometry/Node.js?");

/***/ }),

/***/ "./build/math/Mat3.js":
/*!****************************!*\
  !*** ./build/math/Mat3.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp_mat3Array = undefined;\n\nvar Mat3 = function () {\n    function Mat3() {\n        _classCallCheck(this, Mat3);\n    }\n\n    _createClass(Mat3, null, [{\n        key: \"projection\",\n        value: function projection(width, height) {\n            var m = this.identity();\n            m[0] = 2 / width;\n            m[4] = -2 / height;\n            m[6] = -1;\n            m[7] = 1;\n            m[8] = 1;\n            return m;\n        }\n    }, {\n        key: \"identity\",\n        value: function identity(out) {\n            if (out == undefined) {\n                // out = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n                out = new Float32Array(9);\n                out[0] = 1;\n                out[4] = 1;\n                out[8] = 1;\n            } else {\n                out[0] = 1;\n                out[1] = 0;\n                out[2] = 0;\n                out[3] = 0;\n                out[4] = 1;\n                out[5] = 0;\n                out[6] = 0;\n                out[7] = 0;\n                out[8] = 1;\n            }\n            return out;\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(out, tx, ty) {\n            var x = void 0,\n                y = void 0,\n                m = void 0;\n            if (arguments.length == 3) {\n                m = out;\n                this.identity(m);\n                x = tx;\n                y = ty;\n            }\n            if (arguments.length == 2) {\n                x = out;\n                y = tx;\n                m = this.identity();\n            }\n            m[6] = x;\n            m[7] = y;\n            return m;\n        }\n    }, {\n        key: \"rotate\",\n        value: function rotate(out, radian) {\n            var theta = void 0,\n                m = void 0;\n            if (arguments.length == 2) {\n                m = out;\n                this.identity(m);\n                theta = radian;\n            }\n            if (arguments.length == 1) {\n                theta = out;\n                m = this.identity();\n            }\n            var c = Math.cos(theta);\n            var s = Math.sin(theta);\n            m[0] = c;\n            m[1] = s;\n            m[3] = -s;\n            m[4] = c;\n            return m;\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(out, sx, sy) {\n            var x = void 0,\n                y = void 0,\n                m = void 0;\n            if (arguments.length == 3) {\n                m = out;\n                this.identity(m);\n                x = sx;\n                y = sy;\n            }\n            if (arguments.length == 2) {\n                x = out;\n                y = sx;\n                m = this.identity();\n            }\n            m[0] = x;\n            m[4] = y;\n            return m;\n        }\n    }, {\n        key: \"copy\",\n        value: function copy(from, to) {\n            to[0] = from[0];\n            to[1] = from[1];\n            to[2] = from[2];\n            to[3] = from[3];\n            to[4] = from[4];\n            to[5] = from[5];\n            to[6] = from[6];\n            to[7] = from[7];\n            to[8] = from[8];\n        }\n    }, {\n        key: \"multiplyWithVertex\",\n        value: function multiplyWithVertex(outMatrix, matrix, v2) {\n            var m = void 0;\n            var out = void 0;\n            var vertex = void 0;\n            if (arguments.length == 3) {\n                m = matrix;\n                out = outMatrix;\n                vertex = v2;\n            }\n            if (arguments.length == 2) {\n                m = outMatrix;\n                vertex = matrix;\n            }\n            if (out == null) out = Mat3.identity();\n            var a00 = m[0],\n                a01 = m[1],\n                a02 = m[2];\n            var a10 = m[3],\n                a11 = m[4],\n                a12 = m[5];\n            var a20 = m[6],\n                a21 = m[7],\n                a22 = m[8];\n\n            var b0 = vertex[0],\n                b1 = vertex[1],\n                b2 = vertex[2];\n            if (b2 == null) b2 = 1;\n\n            out[0] = b0 * a00 + b1 * a10 + b2 * a20;\n            out[1] = b0 * a01 + b1 * a11 + b2 * a21;\n            out[2] = b0 * a02 + b1 * a12 + b2 * a22;\n            return out;\n        }\n    }, {\n        key: \"rotateMatrix\",\n        value: function rotateMatrix(out, m) {\n            var a00 = m[0],\n                a01 = m[1],\n                a02 = m[2];\n            var a10 = m[3],\n                a11 = m[4],\n                a12 = m[5];\n            var a20 = m[6],\n                a21 = m[7],\n                a22 = m[8];\n\n            out[0] = a00;\n            out[1] = a10;\n            out[2] = a20;\n\n            out[3] = a01;\n            out[4] = a11;\n            out[5] = a21;\n\n            out[6] = a02;\n            out[7] = a12;\n            out[8] = a22;\n            // let a00 = m[0];\n            // let a00 = m[0];\n            // let a00 = m[0];\n            // let a00 = m[0];\n            // let a00 = m[0];\n            // let a00 = m[0];\n            // let a00 = m[0];\n            // let a00 = m[0];\n        }\n    }, {\n        key: \"multiplyWithValue\",\n        value: function multiplyWithValue(out, m, value) {\n            out[0] = m[0] * value;\n            out[1] = m[1] * value;\n            out[2] = m[2] * value;\n            out[3] = m[3] * value;\n            out[4] = m[4] * value;\n            out[5] = m[5] * value;\n            out[6] = m[6] * value;\n            out[7] = m[7] * value;\n            out[8] = m[8] * value;\n        }\n    }, {\n        key: \"plus\",\n        value: function plus(out, m1, m2) {\n            out[0] = m1[0] + m2[0];\n            out[1] = m1[1] + m2[1];\n            out[2] = m1[2] + m2[2];\n            out[3] = m1[3] + m2[3];\n            out[4] = m1[4] + m2[4];\n            out[5] = m1[5] + m2[5];\n            out[6] = m1[6] + m2[6];\n            out[7] = m1[7] + m2[7];\n            out[8] = m1[8] + m2[8];\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(out, a, b) {\n\n            var a00 = a[0],\n                a01 = a[1],\n                a02 = a[2];\n            var a10 = a[3],\n                a11 = a[4],\n                a12 = a[5];\n            var a20 = a[6],\n                a21 = a[7],\n                a22 = a[8];\n\n            var b00 = b[0],\n                b01 = b[1],\n                b02 = b[2];\n            var b10 = b[3],\n                b11 = b[4],\n                b12 = b[5];\n            var b20 = b[6],\n                b21 = b[7],\n                b22 = b[8];\n\n            out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n            out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n            out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n            out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n            out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n            out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n            out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n            out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n            out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n            return out;\n        }\n    }, {\n        key: \"TEMP_MAT3\",\n        get: function get() {\n            if (temp_mat3Array == undefined) {\n                temp_mat3Array = [Mat3.identity(), Mat3.identity(), Mat3.identity(), Mat3.identity()];\n            }\n            return temp_mat3Array;\n        }\n    }]);\n\n    return Mat3;\n}();\n\nexports.default = Mat3;\n\n//# sourceURL=webpack://tielifa/./build/math/Mat3.js?");

/***/ }),

/***/ "./build/math/Mat4.js":
/*!****************************!*\
  !*** ./build/math/Mat4.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nvar _Vector = __webpack_require__(/*! ./Vector3.js */ \"./build/math/Vector3.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _Mat = __webpack_require__(/*! ./Mat3.js */ \"./build/math/Mat3.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp_mat4 = undefined;\n\nvar Mat4 = function () {\n    function Mat4() {\n        _classCallCheck(this, Mat4);\n    }\n\n    _createClass(Mat4, null, [{\n        key: \"perspective2\",\n        value: function perspective2(left, top, right, bottom, near, far) {\n            return [2 * near / (right - left), 0, 0, 0, 0, 2 * near / (top - bottom), 0, 0, (right + left) / (right - left), (bottom + top) / (top - bottom), (-near - far) / (far - near), -1, 0, 0, -near * far * 2 / (far - near), 0];\n        }\n    }, {\n        key: \"perspective3\",\n        value: function perspective3(fieldOfViewInRadians, width, height, near, far, out) {\n            var m = this.perspective(fieldOfViewInRadians, width / height, near, far, out);\n            var m1 = Mat4.TEMP_MAT4[0];\n            Mat4.translationMatrix(m1, -width / 2, -height / 2, 0);\n            Mat4.multiply(m, m, m1);\n            return m;\n        }\n    }, {\n        key: \"isIdentity\",\n        value: function isIdentity(m) {\n            return !(m[0] !== 1 || m[1] !== 0 || m[2] !== 0 || m[3] !== 0 || m[4] !== 0 || m[5] !== 1 || m[6] !== 0 || m[7] !== 0 || m[8] !== 0 || m[9] !== 0 || m[10] !== 1 || m[11] !== 0 || m[12] !== 0 || m[13] !== 0 || m[14] !== 0 || m[15] !== 1);\n        }\n    }, {\n        key: \"perspective\",\n        value: function perspective(fieldOfViewInRadians, aspect, near, far, out) {\n            var f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewInRadians);\n            if (_Tools2.default.equals(f, 1)) f = 1;\n            var rangeInv = 1.0 / (near - far);\n            var m = void 0;\n            if (out != undefined) {\n                this.identityMatrix(out);\n                m = out;\n            } else {\n                m = this.identity();\n            }\n            m[0] = f / aspect;\n            m[5] = -f;\n            m[10] = (near + far) * rangeInv;\n            m[11] = -1;\n            m[14] = near * far * rangeInv * 2;\n\n            // return [\n            //     f / aspect, 0, 0, 0,\n            //     0, f, 0, 0,\n            //     0, 0, (near + far) * rangeInv, -1,\n            //     0, 0, near * far * rangeInv * 2, 0\n            // ];\n            return m;\n        }\n    }, {\n        key: \"orthoProjection\",\n        value: function orthoProjection(left, top, right, bottom, near, far, out) {\n            if (out != undefined) {\n                this.identityMatrix(out);\n                out[0] = 2 / (right - left);\n                out[5] = 2 / (top - bottom);\n                out[10] = 2 / (near - far);\n                out[12] = (left + right) / (left - right);\n                out[13] = (bottom + top) / (bottom - top);\n                out[14] = (near + far) / (near - far);\n                return out;\n            } else {\n                return new Float32Array([2 / (right - left), 0, 0, 0, 0, 2 / (top - bottom), 0, 0, 0, 0, 2 / (near - far), 0, (left + right) / (left - right), (bottom + top) / (bottom - top), (near + far) / (near - far), 1]);\n            }\n        }\n    }, {\n        key: \"copy\",\n        value: function copy(from, to) {\n            to[0] = from[0];\n            to[1] = from[1];\n            to[2] = from[2];\n            to[3] = from[3];\n            to[4] = from[4];\n            to[5] = from[5];\n            to[6] = from[6];\n            to[7] = from[7];\n            to[8] = from[8];\n            to[9] = from[9];\n            to[10] = from[10];\n            to[11] = from[11];\n            to[12] = from[12];\n            to[13] = from[13];\n            to[14] = from[14];\n            to[15] = from[15];\n        }\n    }, {\n        key: \"equals\",\n        value: function equals(a, b) {\n            var a0 = a[0],\n                a1 = a[1],\n                a2 = a[2],\n                a3 = a[3];\n            var a4 = a[4],\n                a5 = a[5],\n                a6 = a[6],\n                a7 = a[7];\n            var a8 = a[8],\n                a9 = a[9],\n                a10 = a[10],\n                a11 = a[11];\n            var a12 = a[12],\n                a13 = a[13],\n                a14 = a[14],\n                a15 = a[15];\n\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            var b4 = b[4],\n                b5 = b[5],\n                b6 = b[6],\n                b7 = b[7];\n            var b8 = b[8],\n                b9 = b[9],\n                b10 = b[10],\n                b11 = b[11];\n            var b12 = b[12],\n                b13 = b[13],\n                b14 = b[14],\n                b15 = b[15];\n\n            return Math.abs(a0 - b0) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _Tools2.default.EPSILON * Math.max(1.0, Math.abs(a15), Math.abs(b15));\n        }\n    }, {\n        key: \"exactEquals\",\n        value: function exactEquals(a, b) {\n            return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\n        }\n    }, {\n        key: \"projection\",\n        value: function projection(width, height, depth) {\n            var m = this.identity();\n            m[0] = 2 / width;\n            m[5] = -2 / height;\n            m[10] = 2 / depth;\n            m[12] = -1;\n            m[13] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identity\",\n        value: function identity() {\n            // let m = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n            var m = new Float32Array(16);\n            m[0] = 1;\n            m[5] = 1;\n            m[10] = 1;\n            m[15] = 1;\n            return m;\n        }\n    }, {\n        key: \"identityMatrix\",\n        value: function identityMatrix(matrix) {\n            var m = matrix;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translationMatrix\",\n        value: function translationMatrix(out, tx, ty, tz) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            m[15] = 1;\n        }\n    }, {\n        key: \"translation\",\n        value: function translation(tx, ty, tz) {\n            var m = this.identity();\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = tz;\n            return m;\n        }\n    }, {\n        key: \"rotationZMatrix\",\n        value: function rotationZMatrix(out, radian) {\n            var m = out;\n            m[2] = 0;\n            m[3] = 0;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = 1;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n        }\n    }, {\n        key: \"rotationZ\",\n        value: function rotationZ(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[1] = s;\n            m[4] = -s;\n            m[5] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationXMatrix\",\n        value: function rotationXMatrix(out, radian) {\n            var m = out;\n            m[0] = 1;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n            /* [1,0,0,0\r\n                0,c,s,0\r\n                0,-s,c,0\r\n                0,0,0,1]\r\n             */\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationX\",\n        value: function rotationX(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[5] = c;\n            m[6] = s;\n            m[9] = -s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"rotationYMatrix\",\n        value: function rotationYMatrix(out, radian) {\n            var m = out;\n            m[1] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = 1;\n            m[6] = 0;\n            m[7] = 0;\n            m[9] = 0;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n\n            /* [c,0,-s,0\r\n               0,1,0,0\r\n               s,0,c,0\r\n               0,0,0,1]\r\n            */\n\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n        }\n    }, {\n        key: \"rotationY\",\n        value: function rotationY(angleInRadians) {\n            var c = Math.cos(angleInRadians);\n            var s = Math.sin(angleInRadians);\n            var m = this.identity();\n            m[0] = c;\n            m[2] = -s;\n            m[8] = s;\n            m[10] = c;\n            return m;\n        }\n    }, {\n        key: \"scalingMatrix\",\n        value: function scalingMatrix(out, sx, sy, sz) {\n            var m = out;\n            m[0] = sx;\n            m[1] = 0;\n            m[2] = 0;\n            m[3] = 0;\n            m[4] = 0;\n            m[5] = sy;\n            m[6] = 0;\n            m[7] = 0;\n            m[8] = 0;\n            m[9] = 0;\n            m[10] = sz;\n            m[11] = 0;\n            m[12] = 0;\n            m[13] = 0;\n            m[14] = 0;\n            m[15] = 1;\n        }\n    }, {\n        key: \"mat4ToMat3\",\n        value: function mat4ToMat3(mat4, out) {\n            if (out === undefined) {\n                out = _Mat2.default.identity();\n            }\n            out[0] = mat4[0];\n            out[1] = mat4[1];\n            out[2] = mat4[2];\n            out[3] = mat4[4];\n            out[4] = mat4[5];\n            out[5] = mat4[6];\n            out[6] = mat4[8];\n            out[7] = mat4[9];\n            out[8] = mat4[10];\n            return out;\n        }\n    }, {\n        key: \"lookAt\",\n        value: function lookAt(cameraPosition, target, up, out) {\n            if (out === undefined) {\n                out = this.identity();\n            }\n            if (up === undefined) {\n                up = { x: 0, y: 1, z: 0 };\n            }\n            var zAxis = { x: 0, y: 0, z: 0 };\n            _Vector2.default.sub(zAxis, cameraPosition, target);\n            _Vector2.default.normalize(zAxis, zAxis);\n            out[8] = zAxis.x;\n            out[9] = zAxis.y;\n            out[10] = zAxis.z;\n\n            var xAxis = { x: 0, y: 0, z: 0 };\n            _Vector2.default.cross(xAxis, up, zAxis);\n            out[0] = xAxis.x;\n            out[1] = xAxis.y;\n            out[2] = xAxis.z;\n\n            var yAxis = { x: 0, y: 0, z: 0 };\n            _Vector2.default.cross(yAxis, zAxis, xAxis);\n            out[4] = yAxis.x;\n            out[5] = yAxis.y;\n            out[6] = yAxis.z;\n\n            out[12] = cameraPosition.x;\n            out[13] = cameraPosition.y;\n            out[14] = cameraPosition.z;\n\n            return out;\n        }\n    }, {\n        key: \"scaling\",\n        value: function scaling(sx, sy, sz) {\n            var m = this.identity();\n            m[0] = sx;\n            m[5] = sy;\n            m[10] = sz;\n            return m;\n        }\n    }, {\n        key: \"multiplyWithVet3\",\n        value: function multiplyWithVet3(matrix, vet3, out) {\n            var a00 = matrix[0];\n            var a01 = matrix[1];\n            var a02 = matrix[2];\n            var a03 = matrix[3];\n            var a10 = matrix[4];\n            var a11 = matrix[5];\n            var a12 = matrix[6];\n            var a13 = matrix[7];\n            var a20 = matrix[8];\n            var a21 = matrix[9];\n            var a22 = matrix[10];\n            var a23 = matrix[11];\n            var a30 = matrix[12];\n            var a31 = matrix[13];\n            var a32 = matrix[14];\n            var a33 = matrix[15];\n\n            var b00 = vet3.x;\n            var b01 = vet3.y;\n            var b02 = vet3.z;\n            var b03 = 1;\n            out.x = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n            out.y = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n            out.z = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n            return out;\n        }\n    }, {\n        key: \"multiplyWithVertex\",\n        value: function multiplyWithVertex(matrix, vertex, out) {\n            var a00 = matrix[0];\n            var a01 = matrix[1];\n            var a02 = matrix[2];\n            var a03 = matrix[3];\n            var a10 = matrix[4];\n            var a11 = matrix[5];\n            var a12 = matrix[6];\n            var a13 = matrix[7];\n            var a20 = matrix[8];\n            var a21 = matrix[9];\n            var a22 = matrix[10];\n            var a23 = matrix[11];\n            var a30 = matrix[12];\n            var a31 = matrix[13];\n            var a32 = matrix[14];\n            var a33 = matrix[15];\n\n            var b00 = vertex[0];\n            var b01 = vertex[1];\n            var b02 = vertex[2];\n            var b03 = vertex[3];\n            if (b02 == undefined) b02 = 0;\n            if (b03 == undefined) b03 = 1;\n            // if (out == undefined) {\n            //     out = [0, 0, 0, 0];\n            // }\n            out[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n            out[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n            out[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n            out[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n            return out;\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(out, a, b) {\n            // if(!(a instanceof Float32Array) || !(b instanceof Float32Array)){\n            //     console.log('here');\n            // }\n            var a00 = a[0],\n                a01 = a[1],\n                a02 = a[2],\n                a03 = a[3];\n            var a10 = a[4],\n                a11 = a[5],\n                a12 = a[6],\n                a13 = a[7];\n            var a20 = a[8],\n                a21 = a[9],\n                a22 = a[10],\n                a23 = a[11];\n            var a30 = a[12],\n                a31 = a[13],\n                a32 = a[14],\n                a33 = a[15];\n\n            // Cache only the current line of the second matrix\n            var b0 = b[0],\n                b1 = b[1],\n                b2 = b[2],\n                b3 = b[3];\n            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[4];\n            b1 = b[5];\n            b2 = b[6];\n            b3 = b[7];\n            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[8];\n            b1 = b[9];\n            b2 = b[10];\n            b3 = b[11];\n            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n            b0 = b[12];\n            b1 = b[13];\n            b2 = b[14];\n            b3 = b[15];\n            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n            return out;\n        }\n    }, {\n        key: \"inverse\",\n        value: function inverse(out, a) {\n            var a00 = a[0],\n                a01 = a[1],\n                a02 = a[2],\n                a03 = a[3];\n            var a10 = a[4],\n                a11 = a[5],\n                a12 = a[6],\n                a13 = a[7];\n            var a20 = a[8],\n                a21 = a[9],\n                a22 = a[10],\n                a23 = a[11];\n            var a30 = a[12],\n                a31 = a[13],\n                a32 = a[14],\n                a33 = a[15];\n\n            var b00 = a00 * a11 - a01 * a10;\n            var b01 = a00 * a12 - a02 * a10;\n            var b02 = a00 * a13 - a03 * a10;\n            var b03 = a01 * a12 - a02 * a11;\n            var b04 = a01 * a13 - a03 * a11;\n            var b05 = a02 * a13 - a03 * a12;\n            var b06 = a20 * a31 - a21 * a30;\n            var b07 = a20 * a32 - a22 * a30;\n            var b08 = a20 * a33 - a23 * a30;\n            var b09 = a21 * a32 - a22 * a31;\n            var b10 = a21 * a33 - a23 * a31;\n            var b11 = a22 * a33 - a23 * a32;\n\n            // Calculate the determinant\n            var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n            if (!det) {\n                return null;\n            }\n            det = 1.0 / det;\n\n            out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n            out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n            out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n            out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n            out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n            out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n            out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n            out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n            out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n            out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n            out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n            out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n            out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n            out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n            out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n            out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n            return out;\n        }\n    }, {\n        key: \"transformMat3ToMat4\",\n        value: function transformMat3ToMat4(m3, out) {\n            if (out === undefined) out = Mat4.identity();\n            out[0] = m3[0];\n            out[1] = m3[1];\n            out[2] = m3[2];\n\n            out[4] = m3[3];\n            out[5] = m3[4];\n            out[6] = m3[5];\n\n            out[8] = m3[6];\n            out[9] = m3[7];\n            out[10] = m3[8];\n\n            return out;\n        }\n    }, {\n        key: \"TEMP_MAT4\",\n        get: function get() {\n            if (temp_mat4 == undefined) {\n                temp_mat4 = [Mat4.identity(), Mat4.identity(), Mat4.identity(), Mat4.identity()];\n            }\n            return temp_mat4;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return _Tools2.default.EPSILON;\n        }\n    }]);\n\n    return Mat4;\n}();\n\nexports.default = Mat4;\n\n//# sourceURL=webpack://tielifa/./build/math/Mat4.js?");

/***/ }),

/***/ "./build/math/Vector2.js":
/*!*******************************!*\
  !*** ./build/math/Vector2.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /*\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * Copyright (c) 2018. 老脸叔叔创建，版权归老脸叔叔所有\r\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _value = Symbol('二维向量值数组,0是x，1是y');\n// 这是一个可以临时使用的vector数组，便于计算的时候不浪费内存\nvar TEMP_VECTORS = undefined;\n\nvar Vector2 = function () {\n    _createClass(Vector2, [{\n        key: \"x\",\n        get: function get() {\n            return this[_value][0];\n        },\n        set: function set(value) {\n            this[_value][0] = value;\n        }\n    }, {\n        key: \"y\",\n        get: function get() {\n            return this[_value][1];\n        },\n        set: function set(value) {\n            this[_value][1] = value;\n        }\n    }, {\n        key: \"value\",\n        get: function get() {\n            return this[_value];\n        },\n        set: function set(value) {\n            this[_value][0] = value[0];\n            this[_value][1] = value[1];\n        }\n    }, {\n        key: \"radian\",\n        get: function get() {\n            return Math.atan2(this.y, this.x);\n        }\n    }, {\n        key: \"magnitude\",\n        get: function get() {\n            return Math.sqrt(this.x * this.x + this.y * this.y);\n        }\n\n        // static vectorAngle(fromVector, toVector) {\n        //     return Math.atan2(toVector.y - fromVector.y, toVector.x - fromVector.x);\n        // }\n\n    }], [{\n        key: \"rotate\",\n        value: function rotate(out, sourceVector, radian) {\n            var cos = Math.cos(radian),\n                sin = Math.sin(radian);\n            if (!out) out = { x: 0, y: 0 };\n            var y = sourceVector.x * sin + sourceVector.y * cos;\n            var x = sourceVector.x * cos - sourceVector.y * sin;\n            out.x = x;\n            out.y = y;\n            return out;\n        }\n    }, {\n        key: \"rotateAbout\",\n        value: function rotateAbout(output, vector, rotatePoint, radian) {\n            var c = Math.cos(radian);\n            var s = Math.sin(radian);\n            if (!output) output = {};\n            output.x = rotatePoint.x + ((vector.x - rotatePoint.x) * c - (vector.y - rotatePoint.y) * s);\n            output.y = rotatePoint.y + ((vector.x - rotatePoint.x) * s + (vector.y - rotatePoint.y) * c);\n            return output;\n        }\n    }, {\n        key: \"normalize\",\n        value: function normalize(out, vector) {\n            var magnitude = vector.magnitude;\n            if (out == undefined) out = vector.clone();else {\n                if (out != vector) {\n                    out.x = vector.x;\n                    out.y = vector.y;\n                }\n            }\n            if (magnitude == 0) {\n                out.x = 0;\n                out.y = 0;\n                return out;\n            }\n            out.x = out.x / magnitude;\n            out.y = out.y / magnitude;\n            return out;\n        }\n    }, {\n        key: \"multiplyValue\",\n        value: function multiplyValue(out, v, value) {\n            var v1 = v.x * value;\n            var v2 = v.y * value;\n            out.x = v1;\n            out.y = v2;\n        }\n    }, {\n        key: \"dot\",\n        value: function dot(v1, v2) {\n            return v1.x * v2.x + v1.y * v2.y;\n        }\n    }, {\n        key: \"cross\",\n        value: function cross(v1, v2) {\n            return v1.x * v2.y - v1.y * v2.x;\n        }\n    }, {\n        key: \"crossZ\",\n        value: function crossZ(out, v, z) {\n            // A x B = (AyBz - AzBy , AzBx - AxBz , AxBy - AyBx)\n            // 所以把这个二维向量看成(Vx,Vy,0),这个z就是(0,0,z)，得到：\n            out.x = v.y * z;\n            out.y = -(v.x * z);\n            return out;\n        }\n    }, {\n        key: \"zCrossVector\",\n        value: function zCrossVector(out, z, v) {\n            out.x = -z * v.y;\n            out.y = z * v.x;\n            return out;\n        }\n    }, {\n        key: \"plus\",\n        value: function plus(out, v1, v2) {\n            out.x = v1.x + v2.x;\n            out.y = v1.y + v2.y;\n            return out;\n        }\n    }, {\n        key: \"sub\",\n        value: function sub(out, v1, v2) {\n            out.x = v1.x - v2.x;\n            out.y = v1.y - v2.y;\n            return out;\n        }\n    }, {\n        key: \"TEMP_VECTORS\",\n        get: function get() {\n            if (TEMP_VECTORS == undefined) {\n                TEMP_VECTORS = [new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0), new Vector2(0, 0)];\n            }\n            return TEMP_VECTORS;\n        }\n    }]);\n\n    function Vector2(x, y) {\n        _classCallCheck(this, Vector2);\n\n        this[_value] = new Float32Array(3);\n        // this[_value] = [0, 0, 1];//多一位是免得和mat计算时还要自动加一个\n        if (x != null || x != undefined) this.x = x;\n        if (y != null || y != undefined) this.y = y;\n        this[_value][2] = 1;\n    }\n\n    _createClass(Vector2, [{\n        key: \"add\",\n        value: function add(vector) {\n            this.x += vector.x;\n            this.y += vector.y;\n            return this;\n        }\n    }, {\n        key: \"subtract\",\n        value: function subtract(vector) {\n            this.x -= vector.x;\n            this.y -= vector.y;\n            return this;\n        }\n    }, {\n        key: \"multiply\",\n        value: function multiply(value) {\n            this.x *= value;\n            this.y *= value;\n            return this;\n        }\n    }, {\n        key: \"split\",\n        value: function split(radian1, radian2) {\n            var maxRadian = Math.max(radian1, radian2);\n            var minRadian = Math.min(radian1, radian2);\n            console.log(maxRadian, minRadian);\n            var nr = Math.PI - (maxRadian - minRadian);\n            var d = this.magnitude / Math.sin(nr);\n            var nr2 = maxRadian - this.radian;\n            var nr1 = Math.PI - nr2 - nr;\n            var value1 = d * Math.sin(nr1);\n            var value2 = d * Math.sin(nr2);\n            var vectorMax = Vector2.createVector(value2, minRadian);\n            var vectorMin = Vector2.createVector(value1, maxRadian);\n            vectorMax.add(vectorMin);\n        }\n    }, {\n        key: \"splitWithRightAngle\",\n        value: function splitWithRightAngle(horizontalRadian) {\n            this.rotate(-horizontalRadian);\n            var hVector = new Vector2(this.x, 0);\n            var vVector = new Vector2(0, this.y);\n            hVector.rotate(horizontalRadian);\n            vVector.rotate(horizontalRadian);\n            this.rotate(horizontalRadian);\n            return { hVector: hVector, vVector: vVector };\n        }\n    }, {\n        key: \"reverse\",\n        value: function reverse() {\n            this.x = -this.x;\n            this.y = -this.y;\n            return this;\n        }\n    }, {\n        key: \"rotate\",\n        value: function rotate(radian) {\n            var nradian = this.radian + radian;\n            var value = this.magnitude;\n            this.x = Math.abs(value) * Math.cos(nradian);\n            this.y = Math.abs(value) * Math.sin(nradian);\n        }\n    }, {\n        key: \"clone\",\n        value: function clone() {\n            return new Vector2(this.x, this.y);\n        }\n    }], [{\n        key: \"createVector\",\n        value: function createVector(value, radian) {\n            var x = Math.abs(value) * Math.cos(radian);\n            if (Math.abs(x) < _Tools2.default.EPSILON) {\n                x = 0;\n            }\n            var y = Math.abs(value) * Math.sin(radian);\n            if (Math.abs(y) < _Tools2.default.EPSILON) {\n                y = 0;\n            }\n            return new Vector2(x, y);\n        }\n    }]);\n\n    return Vector2;\n}();\n\nexports.default = Vector2;\n\n//# sourceURL=webpack://tielifa/./build/math/Vector2.js?");

/***/ }),

/***/ "./build/math/Vector3.js":
/*!*******************************!*\
  !*** ./build/math/Vector3.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar temp = undefined;\n\nvar Vector3 = function () {\n    function Vector3(x, y, z) {\n        _classCallCheck(this, Vector3);\n\n        this.value = new Float32Array(4);\n        // this.value = [0, 0, 0, 1];//多一位是免得和mat计算时还要自动加一个\n        this.x = x || 0;\n        this.y = y || 0;\n        this.z = z || 0;\n        this.value[3] = 1;\n    }\n\n    _createClass(Vector3, [{\n        key: \"x\",\n        get: function get() {\n            return this.value[0];\n        },\n        set: function set(v) {\n            this.value[0] = v;\n        }\n    }, {\n        key: \"y\",\n        get: function get() {\n            return this.value[1];\n        },\n        set: function set(v) {\n            this.value[1] = v;\n        }\n    }, {\n        key: \"z\",\n        get: function get() {\n            return this.value[2];\n        },\n        set: function set(v) {\n            this.value[2] = v;\n        }\n    }, {\n        key: \"magnitude\",\n        get: function get() {\n            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n        }\n    }], [{\n        key: \"dot\",\n        value: function dot(v1, v2) {\n            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n        }\n    }, {\n        key: \"normalize\",\n        value: function normalize(out, v) {\n            var length = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n            if (_Tools2.default.equals(0, length)) {\n                out.x = 0;\n                out.y = 0;\n                out.z = 0;\n            } else {\n                out.x = v.x / length;\n                out.y = v.y / length;\n                out.z = v.z / length;\n                // if(Tools.equals(out.x , 0))out.x = 0;\n                // if(Tools.equals(out.y , 0))out.y = 0;\n                // if(Tools.equals(out.z , 0))out.z = 0;\n            }\n        }\n    }, {\n        key: \"plus\",\n        value: function plus(out, v1, v2) {\n            out.x = v1.x + v2.x;\n            out.y = v1.y + v2.y;\n            out.z = v1.z + v2.z;\n            return out;\n        }\n    }, {\n        key: \"sub\",\n        value: function sub(out, v1, v2) {\n            out.x = v1.x - v2.x;\n            out.y = v1.y - v2.y;\n            out.z = v1.z - v2.z;\n            return out;\n        }\n    }, {\n        key: \"multiplyValue\",\n        value: function multiplyValue(out, v, value) {\n            out.x = v.x * value;\n            out.y = v.y * value;\n            out.z = v.z * value;\n            return out;\n        }\n    }, {\n        key: \"copy\",\n        value: function copy(from, to) {\n            to.x = from.x;\n            to.y = from.y;\n            to.z = from.z;\n        }\n    }, {\n        key: \"cross\",\n        value: function cross(out, v1, v) {\n            out.x = v1.y * v.z - v1.z * v.y;\n            out.y = v1.z * v.x - v1.x * v.z;\n            out.z = v1.x * v.y - v1.y * v.x;\n            return out;\n        }\n    }, {\n        key: \"TEMP_VECTORS\",\n        get: function get() {\n            if (temp == undefined) {\n                temp = [new Vector3(), new Vector3(), new Vector3(), new Vector3()];\n            }\n            return temp;\n        }\n    }]);\n\n    return Vector3;\n}();\n\nexports.default = Vector3;\n\n//# sourceURL=webpack://tielifa/./build/math/Vector3.js?");

/***/ }),

/***/ "./build/text/TextTools.js":
/*!*********************************!*\
  !*** ./build/text/TextTools.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _fontMetricsCatch = {};\nvar METRICS_STRING = '|Éq';\nvar BASELINE_SYMBOL = 'M';\nvar BASELINE_MULTIPLIER = 1.4;\nvar _newlines = [0x000A, // line feed\n0x000D];\nvar _breakingSpaces = [0x0009, // character tabulation\n0x0020, // space\n0x2000, // en quad\n0x2001, // em quad\n0x2002, // en space\n0x2003, // em space\n0x2004, // three-per-em space\n0x2005, // four-per-em space\n0x2006, // six-per-em space\n0x2008, // punctuation space\n0x2009, // thin space\n0x200A, // hair space\n0x205F, // medium mathematical space\n0x3000];\n\nvar SPACE_CHAR_CODE = 0x0020;\n\nvar BASELINE_ALPHABETIC = \"alphabetic\";\nvar BASELINE_TOP = \"top\";\nvar BASELINE_MIDDLE = \"middle\";\nvar BASELINE_HANGING = \"hanging\";\nvar BASELINE_IDEOGRAPHICS = \"ideographic\";\nvar BASELINE_BOTTOM = \"bottom\";\n\nvar ALIGN_START = \"start\";\nvar ALIGN_END = \"end\";\nvar ALIGN_LEFT = \"left\";\nvar ALIGN_RIGHT = \"right\";\nvar ALIGN_CENTER = \"center\";\n\nvar TextTools = function () {\n    function TextTools() {\n        _classCallCheck(this, TextTools);\n    }\n\n    _createClass(TextTools, null, [{\n        key: 'isNewLineChar',\n        value: function isNewLineChar(char) {\n            return _newlines.indexOf(char) != -1;\n        }\n    }, {\n        key: 'isSpacesChar',\n        value: function isSpacesChar(char) {\n            return _breakingSpaces.indexOf(char) != -1;\n        }\n    }, {\n        key: 'getFontString',\n        value: function getFontString(fontSize, fontFamily, fontWeight, fontStyle) {\n            fontSize = fontSize != null ? fontSize : 32;\n\n            fontFamily = fontFamily || \"arial\";\n            fontFamily = fontFamily.trim().toLocaleLowerCase();\n\n            fontWeight = fontWeight || \"\";\n            fontWeight = fontWeight.trim().toLocaleLowerCase();\n\n            fontStyle = fontStyle || \"\";\n            fontStyle = fontStyle.trim().toLocaleLowerCase();\n\n            var font = \"\";\n            if (fontStyle !== \"\") {\n                font = font + fontStyle + \" \";\n            }\n            if (fontWeight !== \"\") {\n                font = font + fontWeight + \" \";\n            }\n            font = font + fontSize.toString() + \"px \";\n            if (fontFamily !== \"\") {\n                font = font + fontFamily;\n            }\n            return font;\n        }\n    }, {\n        key: 'getStartPointOffset',\n        value: function getStartPointOffset(baseLine, textAlign, fontSize, textMetric, width) {\n            baseLine = baseLine.toLowerCase().trim();\n            textAlign = textAlign.toLowerCase().trim();\n            var offset = { x: 0, y: 0 };\n            if (textAlign === ALIGN_LEFT || textAlign === ALIGN_START) {}\n            if (textAlign === ALIGN_END || textAlign === ALIGN_RIGHT) {\n                offset.x = -width;\n            }\n            if (textAlign === ALIGN_CENTER) {\n                offset.x = -width / 2;\n            }\n            if (baseLine === BASELINE_ALPHABETIC) {\n                offset.y -= textMetric.ascent * fontSize;\n            }\n            if (baseLine === BASELINE_ALPHABETIC) {\n                offset.y -= textMetric.ascent * fontSize;\n            }\n            if (baseLine === BASELINE_HANGING) {\n                offset.y -= textMetric.headOffset2 * fontSize;\n            }\n            if (baseLine === BASELINE_TOP) {\n                offset.y -= textMetric.headOffset * fontSize;\n            }\n            if (baseLine === BASELINE_BOTTOM) {\n                offset.y -= textMetric.fontSize * fontSize;\n            }\n            if (baseLine === BASELINE_IDEOGRAPHICS) {\n                offset.y -= textMetric.fontSize * fontSize;\n            }\n\n            if (baseLine === BASELINE_MIDDLE) {\n                offset.y -= textMetric.middle * fontSize;\n            }\n            return offset;\n        }\n    }, {\n        key: 'splitTextWithNewlineChar',\n        value: function splitTextWithNewlineChar(string) {\n            return string.split('\\n');\n        }\n    }, {\n        key: 'draw2dText',\n        value: function draw2dText(canvas, text, fontSize, fontFamily, fontWeight, fontStyle) {\n            var textMetrics = TextTools.measureText(canvas, text, fontSize, fontFamily, fontWeight, fontStyle);\n            var width = textMetrics.width;\n            canvas.width = Math.ceil(width);\n            canvas.height = Math.ceil(textMetrics.fontSize * fontSize);\n            if (canvas.width === 0 || canvas.height === 0) return;\n            var ctx = canvas.getContext('2d');\n            ctx.clearRect(0, 0, canvas.width, canvas.height);\n            ctx.save();\n            ctx.fillStyle = \"#FFFFFF\"; //必须白色\n            ctx.font = textMetrics.font;\n            ctx.textAlign = ALIGN_LEFT;\n            ctx.textBaseline = BASELINE_ALPHABETIC;\n            ctx.fillText(text, 0, textMetrics.ascent * fontSize);\n            ctx.restore();\n            return canvas;\n        }\n    }, {\n        key: 'measureText',\n        value: function measureText(canvas, text, fontSize, fontFamily, fontWeight, fontStyle) {\n            var font = this.getFontString(fontSize, fontFamily, fontWeight, fontStyle);\n            var fontProperties = this.measureFont(canvas, fontFamily, fontWeight, fontStyle);\n            var copyProperties = {};\n            for (var p in fontProperties) {\n                copyProperties[p] = fontProperties[p];\n            }\n            var ctx = canvas.getContext('2d');\n            ctx.font = font;\n            copyProperties.width = ctx.measureText(text).width;\n            copyProperties.font = font;\n            return copyProperties;\n        }\n    }, {\n        key: 'measureFont',\n        value: function measureFont(canvas, fontFamily, fontWeight, fontStyle) {\n\n            var fontSize = 100;\n\n            fontFamily = fontFamily || \"arial\";\n            fontFamily = fontFamily.trim().toLocaleLowerCase();\n\n            fontWeight = fontWeight || \"\";\n            fontWeight = fontWeight.trim().toLocaleLowerCase();\n\n            fontStyle = fontStyle || \"\";\n            fontStyle = fontStyle.trim().toLocaleLowerCase();\n\n            var font = \"\";\n            if (fontStyle !== \"\") {\n                font = font + fontStyle + \" \";\n            }\n            if (fontWeight !== \"\") {\n                font = font + fontWeight + \" \";\n            }\n            var fontKey = font;\n            font = font + fontSize.toString() + \"px \";\n            if (fontFamily !== \"\") {\n                font = font + fontFamily;\n                fontKey = fontKey + fontFamily;\n            }\n\n            var properties = _fontMetricsCatch[fontKey];\n            if (properties != null) return properties;\n            properties = {};\n            var ctx = canvas.getContext('2d');\n            ctx.save();\n            ctx.font = font;\n\n            var metricsString = METRICS_STRING + BASELINE_SYMBOL;\n\n            var spaceCharWidthMap = {};\n            for (var _i = 0; _i < _breakingSpaces.length; _i++) {\n                var spaceChar = String.fromCharCode(_breakingSpaces[_i]);\n                spaceCharWidthMap[_breakingSpaces[_i]] = ctx.measureText(spaceChar).width / 100;\n            }\n            properties.spaceCharWidthCent = spaceCharWidthMap;\n\n            var width = Math.ceil(ctx.measureText(metricsString).width);\n            var baseline = Math.ceil(ctx.measureText(BASELINE_SYMBOL).width);\n            var height = 2 * baseline;\n            baseline = baseline * BASELINE_MULTIPLIER | 0;\n            canvas.width = width;\n            canvas.height = height;\n            ctx.font = font;\n\n            ctx.fillStyle = '#FF0000';\n            ctx.fillRect(0, 0, width, height);\n\n            ctx.textBaseline = BASELINE_ALPHABETIC;\n            ctx.fillStyle = '#000000';\n            ctx.fillText(metricsString, 0, baseline);\n\n            var imagedata = ctx.getImageData(0, 0, width, height).backMapData;\n            var pixels = imagedata.length;\n            var line = width * 4;\n\n            var i = 0;\n            var idx = 0;\n            var stop = false;\n\n            // ascent. scan from top to bottom until we find a non red pixel\n            for (i = 0; i < baseline; ++i) {\n                for (var j = 0; j < line; j += 4) {\n                    if (imagedata[idx + j] !== 255) {\n                        stop = true;\n                        break;\n                    }\n                }\n                if (!stop) {\n                    idx += line;\n                } else {\n                    break;\n                }\n            }\n\n            properties.ascent = baseline - i;\n\n            idx = pixels - line;\n            stop = false;\n\n            // descent. scan from bottom to top until we find a non red pixel\n            for (i = height; i > baseline; --i) {\n                for (var _j = 0; _j < line; _j += 4) {\n                    if (imagedata[idx + _j] !== 255) {\n                        stop = true;\n                        break;\n                    }\n                }\n\n                if (!stop) {\n                    idx -= line;\n                } else {\n                    break;\n                }\n            }\n\n            properties.descent = i - baseline;\n            properties.fontSize = properties.ascent + properties.descent;\n\n            metricsString = \"|\";\n            var w = Math.ceil(ctx.measureText(metricsString).width);\n            var h = properties.fontSize;\n            canvas.width = w;\n            canvas.height = h;\n            // canvas.style.width = w +\"px\";\n            // canvas.style.height = h +\"px\";\n\n            ctx.fillStyle = '#FF0000';\n            ctx.fillRect(0, 0, w, h);\n            ctx.font = font;\n            ctx.textBaseline = BASELINE_BOTTOM;\n            ctx.fillStyle = '#000000';\n            ctx.fillText(metricsString, 0, h);\n\n            imagedata = ctx.getImageData(0, 0, w, h).backMapData;\n            var offset = -1;\n            for (var _i2 = 0; _i2 < h; _i2++) {\n                for (var _j2 = 0; _j2 < w; _j2++) {\n                    var index = _i2 * w + _j2;\n                    index *= 4;\n                    if (imagedata[index] !== 255) {\n                        offset = _i2 - 2;\n                        break;\n                    }\n                }\n                if (offset !== -1) {\n                    break;\n                }\n            }\n            properties.headOffset2 = offset;\n\n            metricsString = \"E\";\n            ctx.fillStyle = '#FF0000';\n            ctx.fillRect(0, 0, w, h);\n\n            // w = Math.ceil(ctx.measureBMText(metricsString).width);\n\n            // ctx.font = font;\n            ctx.textBaseline = BASELINE_BOTTOM;\n            ctx.fillStyle = '#000000';\n            ctx.fillText(metricsString, 0, h);\n\n            imagedata = ctx.getImageData(0, 0, w, h).backMapData;\n            offset = -1;\n            for (var _i3 = 0; _i3 < h; _i3++) {\n                for (var _j3 = 0; _j3 < w; _j3++) {\n                    var _index = _i3 * w + _j3;\n                    _index *= 4;\n                    if (imagedata[_index] !== 255) {\n                        offset = _i3;\n                        break;\n                    }\n                }\n                if (offset !== -1) {\n                    break;\n                }\n            }\n            properties.headOffset = offset;\n            properties.middle = Math.ceil(offset + (properties.fontSize - offset) / 2);\n            properties.fontSize = properties.fontSize / fontSize;\n            properties.headOffset = properties.headOffset / fontSize;\n            properties.headOffset2 = properties.headOffset2 / fontSize;\n            properties.middle = properties.middle / fontSize;\n            properties.ascent = properties.ascent / fontSize;\n            properties.descent = properties.descent / fontSize;\n            properties.id = fontKey;\n\n            ctx.restore();\n            _fontMetricsCatch[fontKey] = properties;\n            return properties;\n        }\n    }, {\n        key: 'SPACE_CHAR_CODE',\n        get: function get() {\n            return SPACE_CHAR_CODE;\n        }\n    }, {\n        key: 'BASELINE_ALPHABETIC',\n        get: function get() {\n            return BASELINE_ALPHABETIC;\n        }\n    }, {\n        key: 'BASELINE_TOP',\n        get: function get() {\n            return BASELINE_TOP;\n        }\n    }, {\n        key: 'ALIGN_CENTER',\n        get: function get() {\n            return ALIGN_CENTER;\n        }\n    }]);\n\n    return TextTools;\n}();\n\nexports.default = TextTools;\n\n//# sourceURL=webpack://tielifa/./build/text/TextTools.js?");

/***/ }),

/***/ "./build/texture/MainTexture.js":
/*!**************************************!*\
  !*** ./build/texture/MainTexture.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nvar _Texture = __webpack_require__(/*! ./Texture.js */ \"./build/texture/Texture.js\");\n\nvar _Texture2 = _interopRequireDefault(_Texture);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SINGLE_TYPE = 'single';\nvar H_TYPE = 'h_t';\nvar V_TYPE = 'v_t';\n\nvar MainTexture = function () {\n    function MainTexture(p) {\n        _classCallCheck(this, MainTexture);\n\n        this.index = p['index'];\n        if (this.index == null) this.index = -1;\n        this.width = p['width'] || 1024;\n        this.height = p['height'] || 1024;\n        this.textures = [];\n        this.constId = 0;\n        this.regions = [];\n        this.space = p['space'] || 1;\n        this.glTexture = null;\n        this.regions.push({ id: this.constId, width: this.width, height: this.height, x: 0, y: 1, type: SINGLE_TYPE });\n    }\n\n    _createClass(MainTexture, [{\n        key: \"park\",\n\n\n        /**\r\n         * @deprecated\r\n         * @param tiledImages\r\n         * @returns {{remainImages: Array, parkedInfo: Array}}\r\n         */\n        value: function park(tiledImages) {\n            var image = tiledImages;\n            if (!(image instanceof Array)) {\n                var im = image;\n                image = [];\n                image.push(im);\n            }\n            var parkedImage = [];\n            var infos = [];\n            // let max = this.maxPage;\n            // let count = 0;\n            while (parkedImage.length !== image.length) {\n                var info = this.parkImages(tiledImages, parkedImage);\n                if (info.paredInfo.length === 0) break;\n                _Tools2.default.addAllInArray(infos, info.textures);\n                parkedImage = info.parkedImages;\n                // count++;\n                // if (count >= max) break;\n            }\n            var remained = [];\n            if (parkedImage.length !== image.length) {\n                for (var i = 0; i < image.length; i++) {\n                    var img = image[i];\n                    if (parkedImage.indexOf(img) === -1) {\n                        remained.push(img);\n                    }\n                }\n            }\n            return { parkedInfo: infos, remainImages: remained };\n        }\n\n        /**\r\n         * @deprecated\r\n         * @param tiledImages\r\n         * @param parkedImages\r\n         * @returns {{textures: Array, parkedImages: (*|Array)}}\r\n         */\n\n    }, {\n        key: \"parkImages\",\n        value: function parkImages(tiledImages, parkedImages) {\n            parkedImages = parkedImages || [];\n            // let initRegion = {id: constId, width: this.width, height: this.height, x: 0, y: 0, type: SINGLE_TYPE};\n            var regions = this.regions;\n            // regions.push(initRegion);\n            var textures = [];\n            // let tiledImages = [];\n            // for (let i = 0; i < this.image.length; i++) {\n            //     tiledImages.push(this.image[i]);\n            // }\n            for (var i = 0; i < tiledImages.length; i++) {\n                var mostFit = { value: -1, img: null, region: null };\n                for (var _i = 0; _i < regions.length; _i++) {\n                    var region = regions[_i];\n                    var fit = this.getFitImage(region, tiledImages, parkedImages);\n                    if (fit.img != null) {\n                        if (fit.value > mostFit.value) {\n                            mostFit.value = fit.value;\n                            mostFit.img = fit.img;\n                            mostFit.region = region;\n                        }\n                    }\n                }\n                if (mostFit.region != null) {\n                    this.constId++;\n                    var img = mostFit.img;\n                    var re = mostFit.region;\n                    var texture = new _Texture2.default({\n                        id: img.id,\n                        img: img,\n                        x: re.x,\n                        y: re.y,\n                        width: img.width,\n                        height: img.height\n                    });\n                    // let parkInfo = {\n                    //     id: img.id,\n                    //     img: img,\n                    //     x: re.x,\n                    //     y: re.y,\n                    //     width: img.width,\n                    //     height: img.height\n                    // };\n                    textures.push(texture);\n                    this.splitRegion(img, this.constId, re, regions);\n                    parkedImages.push(img);\n                }\n            }\n            // return parkedInformation;\n            return { textures: textures, parkedImages: parkedImages };\n        }\n    }, {\n        key: \"splitRegion\",\n        value: function splitRegion(img, newRegionId, region, regions) {\n            // 横向分：\n            var hRegion1 = {\n                id: newRegionId,\n                x: img.width + this.space + region.x,\n                y: region.y,\n                width: region.width - img.width - this.space,\n                height: img.height,\n                type: H_TYPE\n            };\n            var hRegion2 = {\n                id: newRegionId,\n                x: region.x,\n                y: region.y + img.height + this.space,\n                width: region.width,\n                height: region.height - img.height - this.space,\n                type: H_TYPE\n            };\n\n            //纵向分：\n            var vRegion1 = {\n                id: newRegionId,\n                x: img.width + this.space + region.x,\n                y: region.y,\n                width: region.width - img.width - this.space,\n                height: region.height,\n                type: V_TYPE\n            };\n            var vRegion2 = {\n                id: newRegionId,\n                x: region.x,\n                y: region.y + img.height + this.space,\n                width: img.width,\n                height: region.height - img.height - this.space,\n                type: V_TYPE\n            };\n\n            this.deleteRegion(region, regions);\n            _Tools2.default.removeObjFromArray(region, regions);\n            regions.push(hRegion1);\n            regions.push(hRegion2);\n            regions.push(vRegion1);\n            regions.push(vRegion2);\n        }\n    }, {\n        key: \"deleteRegion\",\n        value: function deleteRegion(region, regions) {\n            var type = region.type;\n            var id = region.id;\n            var deleteType = V_TYPE;\n            if (type === V_TYPE) deleteType = H_TYPE;\n            //删除以前的横向区域，并把另外一个纵向区域改成独立区域\n            var del = [];\n            var complete = 0;\n            var total = 3;\n            for (var i = 0; i < regions.length; i++) {\n                var r = regions[i];\n                if (r === region) continue;\n                if (r.id === id) {\n                    if (r.type === type) {\n                        r.type = SINGLE_TYPE;\n                        complete++;\n                    } else if (r.type === deleteType) {\n                        del.push(r);\n                        complete++;\n                    }\n                }\n                if (complete === total) {\n                    break;\n                }\n            }\n            for (var _i2 = 0; _i2 < del.length; _i2++) {\n                _Tools2.default.removeObjFromArray(del[_i2], regions);\n                // regions.remove(del[i]);\n            }\n        }\n    }, {\n        key: \"parkImageInRegion\",\n        value: function parkImageInRegion(image, region) {\n            this.constId++;\n            var img = image;\n            var re = region;\n            var texture = new _Texture2.default({\n                // id: img.src,\n                img: img,\n                x: re.x,\n                y: re.y,\n                width: img.width,\n                height: img.height,\n                page: this.index\n            });\n            this.textures.push(texture);\n            this.splitRegion(img, this.constId, re, this.regions);\n            return texture;\n        }\n    }, {\n        key: \"getFitRegion\",\n        value: function getFitRegion(image) {\n            var fit = { value: -2, region: null, index: this.index };\n            for (var i = 0; i < this.regions.length; i++) {\n                var region = this.regions[i];\n                if (image.width <= region.width && image.height <= region.height) {\n                    var f = image.width / region.width + image.height / region.height;\n                    if (f > fit.value) {\n                        fit.value = f;\n                        fit.region = region;\n                    }\n                }\n            }\n            return fit;\n        }\n\n        /**\r\n         * @deprecated\r\n         * @param region\r\n         * @param tiledImages\r\n         * @param parkedImages\r\n         * @returns {{img: null, value: number}}\r\n         */\n\n    }, {\n        key: \"getFitImage\",\n        value: function getFitImage(region, tiledImages, parkedImages) {\n            var fit = { value: -1, img: null };\n            for (var i = 0; i < tiledImages.length; i++) {\n                var img = tiledImages[i];\n                // let img = image.img;\n                if (parkedImages.indexOf(img) !== -1) continue;\n                if (img.width <= region.width && img.height <= region.height) {\n                    var f = img.width / region.width + img.height / region.height;\n                    if (f > fit.value) {\n                        fit.value = f;\n                        fit.img = img;\n                    }\n                }\n            }\n            return fit;\n        }\n    }], [{\n        key: \"SINGLE_TYPE\",\n        get: function get() {\n            return SINGLE_TYPE;\n        }\n    }]);\n\n    return MainTexture;\n}();\n\nexports.default = MainTexture;\n\n//# sourceURL=webpack://tielifa/./build/texture/MainTexture.js?");

/***/ }),

/***/ "./build/texture/TempCanvas.js":
/*!*************************************!*\
  !*** ./build/texture/TempCanvas.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TempCanvas = function TempCanvas() {\n    _classCallCheck(this, TempCanvas);\n\n    if (typeof wx !== 'undefined') {\n        return wx.createCanvas();\n    }\n    var element = document.createElement('canvas');\n    return element;\n};\n\nexports.default = TempCanvas;\n\n//# sourceURL=webpack://tielifa/./build/texture/TempCanvas.js?");

/***/ }),

/***/ "./build/texture/Texture.js":
/*!**********************************!*\
  !*** ./build/texture/Texture.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Texture = function () {\n    function Texture(p) {\n        _classCallCheck(this, Texture);\n\n        p = p || {};\n        this.opacity = p['opacity'];\n        if (this.opacity == null) this.opacity = true;\n        this.id = p['id'];\n        if (p['x'] != null) {\n            this.x = p['x'];\n        } else {\n            this.x = -1;\n        }\n\n        if (p['y'] != null) {\n            this.y = p['y'];\n        } else {\n            this.y = -1;\n        }\n\n        if (p['width'] != null) {\n            this.width = p['width'];\n        } else {\n            this.width = -1;\n        }\n\n        if (p['height'] != null) {\n            this.height = p['height'];\n        } else {\n            this.height = -1;\n        }\n\n        this.page = p['page'] || 0;\n        this.index = this.page;\n        this.splitedTextures = [];\n    }\n\n    _createClass(Texture, [{\n        key: 'index',\n        get: function get() {\n            return this.page;\n        },\n        set: function set(index) {\n            this.page = index;\n        }\n    }]);\n\n    return Texture;\n}();\n\nexports.default = Texture;\n\n//# sourceURL=webpack://tielifa/./build/texture/Texture.js?");

/***/ }),

/***/ "./build/texture/TextureManager.js":
/*!*****************************************!*\
  !*** ./build/texture/TextureManager.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TempCanvas = __webpack_require__(/*! ./TempCanvas.js */ \"./build/texture/TempCanvas.js\");\n\nvar _TempCanvas2 = _interopRequireDefault(_TempCanvas);\n\nvar _MainTexture = __webpack_require__(/*! ./MainTexture.js */ \"./build/texture/MainTexture.js\");\n\nvar _MainTexture2 = _interopRequireDefault(_MainTexture);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _textureMap = Symbol('贴图表');\n\nvar TextureManager = function () {\n    function TextureManager(maxSize, gl, maxTextureNum, space, tempCanvas) {\n        _classCallCheck(this, TextureManager);\n\n        if (gl == null) throw new Error('GL context can\\'t be null');\n        this.gl = gl;\n        this.space = space || 3;\n        // 一个离屏的canvas\n        this.canvas = tempCanvas || new _TempCanvas2.default();\n        this.ctx = this.canvas.getContext('2d');\n\n        this.maxWidth = maxSize || 1;\n        this.maxHeight = maxSize || 1;\n        this.maxTextureNum = maxTextureNum || 1;\n        this[_textureMap] = {};\n        this.textureArray = new Array(this.maxTextureNum);\n        //动态贴图占总贴图的1/3\n        this.dynamicIndex = this.maxTextureNum - Math.floor(this.maxTextureNum / 3);\n        for (var i = 0; i < this.textureArray.length; i++) {\n            var mainTexture = new _MainTexture2.default({\n                width: this.maxWidth,\n                height: this.maxHeight,\n                space: this.space,\n                index: i\n            });\n            this._initMainTexture(mainTexture);\n            this.textureArray[i] = mainTexture;\n        }\n    }\n\n    _createClass(TextureManager, [{\n        key: \"_initMainTexture\",\n        value: function _initMainTexture(texture) {\n            var canvas = this.canvas;\n            var ctx = this.ctx;\n            var gl = this.gl;\n            canvas.width = texture.width;\n            canvas.height = texture.height;\n            ctx.clearRect(0, 0, texture.width, texture.height);\n            ctx.fillStyle = \"#ffffff\";\n            ctx.fillRect(0, 0, 1, 1); // 这个像素点是给一般fill用的texture颜色\n            // let backMapData = ctx.getImageData(0, 0, texture.width, texture.height);\n            var glTexture = gl.createTexture();\n            texture.glTexture = glTexture;\n            gl.bindTexture(gl.TEXTURE_2D, glTexture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, canvas);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            if (TextureManager.isPOT(canvas.width) && TextureManager.isPOT(canvas.height)) {\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n                gl.generateMipmap(gl.TEXTURE_2D);\n            } else {\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            }\n            gl.bindTexture(gl.TEXTURE_2D, null);\n        }\n    }, {\n        key: \"loadImage\",\n        value: function loadImage(src, gl) {}\n    }, {\n        key: \"getMapLength\",\n        value: function getMapLength(backgroundMap) {\n            var size = 0,\n                key = void 0;\n            for (key in backgroundMap) {\n                if (backgroundMap.hasOwnProperty(key)) size++;\n            }\n            return size;\n        }\n    }, {\n        key: \"getTexture\",\n        value: function getTexture(image, id, dynamic) {\n            if (id == null) id = image.src;\n            var texture = this[_textureMap][id];\n            if (texture == null) {\n                texture = this.createTexture(image, id, dynamic);\n            }\n            return texture;\n        }\n    }, {\n        key: \"getTextureById\",\n        value: function getTextureById(id, index) {\n            var t = this[_textureMap][id];\n            if (index != null && t != null) {\n                return t.splitedTextures[index];\n            }\n            return t;\n        }\n    }, {\n        key: \"clean\",\n        value: function clean(clearAll) {\n            if (clearAll == null) clearAll = false;\n            var startIndex = this.dynamicIndex;\n            var endIndex = this.textureArray.length;\n            if (clearAll) {\n                startIndex = 0;\n            }\n            for (var i = startIndex; i < endIndex; i++) {\n                var mainTexture = this.textureArray[i];\n                mainTexture.regions.length = 0;\n                mainTexture.constId = 0;\n                mainTexture.regions.push({\n                    id: mainTexture.constId,\n                    width: mainTexture.width,\n                    height: mainTexture.height,\n                    x: 0,\n                    y: 1,\n                    type: _MainTexture2.default.SINGLE_TYPE\n                });\n                if (!clearAll) {\n                    for (var k = 0; k < mainTexture.textures.length; k++) {\n                        var t = mainTexture.textures[k];\n                        delete this[_textureMap][t.id];\n                    }\n                }\n                mainTexture.textures = [];\n            }\n            if (clearAll) this[_textureMap] = {};\n        }\n    }, {\n        key: \"createTexture\",\n        value: function createTexture(drawable, id, dynamic) {\n            if (id == null) id = drawable.src;\n            if (id == null) throw new Error('ID can not be null');\n            var gl = this.gl;\n            if (dynamic == null) dynamic = false;\n            var startTextureIndex = 0;\n            var endTextureIndex = this.dynamicIndex;\n            if (dynamic) {\n                startTextureIndex = this.dynamicIndex;\n                endTextureIndex = this.textureArray.length;\n            }\n            var mostFit = { value: -2, index: -1, region: null };\n            for (var i = startTextureIndex; i < endTextureIndex; i++) {\n                var _mainTexture = this.textureArray[i];\n                var fitInfo = _mainTexture.getFitRegion(drawable);\n                if (fitInfo.value > mostFit.value) {\n                    mostFit = fitInfo;\n                }\n            }\n            if (mostFit.index === -1) throw new Error('cannot find fit texture for this image, you can increase maxTextureNum to fix this issue');\n            var mainTexture = this.textureArray[mostFit.index];\n            var imgData = null;\n            if (drawable.getContext != null) {\n                // 说明drawable就是一个canvas\n                imgData = drawable;\n            } else {\n                var canvas = this.canvas;\n                var ctx = this.ctx;\n                canvas.width = drawable.width;\n                canvas.height = drawable.height;\n                ctx.clearRect(0, 0, drawable.width, drawable.height);\n                ctx.drawImage(drawable, 0, 0);\n                imgData = canvas;\n            }\n\n            var region = mostFit.region;\n            gl.bindTexture(gl.TEXTURE_2D, mainTexture.glTexture);\n            // target, level, xoffset, yoffset, format, type, ImageData? pixels\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, region.x, region.y, gl.RGBA, gl.UNSIGNED_BYTE, imgData);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n\n            var texture = mainTexture.parkImageInRegion(drawable, mostFit.region);\n            texture.id = id;\n\n            this[_textureMap][id] = texture;\n            return texture;\n        }\n    }], [{\n        key: \"isPOT\",\n        value: function isPOT(value) {\n            return value > 0 && (value - 1 & value) === 0;\n        }\n    }]);\n\n    return TextureManager;\n}();\n\nexports.default = TextureManager;\n\n//# sourceURL=webpack://tielifa/./build/texture/TextureManager.js?");

/***/ }),

/***/ "./build/utils/Color.js":
/*!******************************!*\
  !*** ./build/utils/Color.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _W3Color = __webpack_require__(/*! ./W3Color.js */ \"./build/utils/W3Color.js\");\n\nvar _W3Color2 = _interopRequireDefault(_W3Color);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _instance = void 0;\n\nvar Color = function () {\n    function Color() {\n        _classCallCheck(this, Color);\n\n        if (_instance) {\n            return _instance;\n        }\n        _instance = this;\n        this.colorMap = {};\n    }\n\n    _createClass(Color, [{\n        key: 'convertStringToColor',\n        value: function convertStringToColor(string) {\n            var vec3 = this.colorMap[string];\n            if (vec3 != undefined) return vec3;\n            string = string.toLowerCase();\n            if (Color.isRGBAString(string)) {\n                return this.rgba2vec(string);\n            }\n            if (Color.isHSLAString(string)) {\n                return this.hsla2vet3(string);\n            }\n            return this.getVec(string, string, 1);\n        }\n    }, {\n        key: 'hsla2vet3',\n        value: function hsla2vet3(hsl) {\n            var temp = hsl;\n            var vec3 = this.colorMap[temp];\n            if (vec3 != undefined) return vec3;\n            hsl = hsl.match(new RegExp(\",\", \"g\"));\n            hsl = hsl || [];\n            var a = 1.0;\n            if (hsl.length == 3) {\n                hsl = temp;\n                var i = hsl.lastIndexOf(',');\n                var i1 = hsl.lastIndexOf(')');\n                var as = hsl.substring(i + 1, i1);\n                a = parseFloat(as);\n                hsl = hsl.substring(0, i);\n                hsl += ')';\n            } else {\n                hsl = temp;\n            }\n            hsl = hsl.replace('a', '');\n            var v = w3color(hsl);\n            if (v.valid) {\n                vec3 = [v.r, v.g, v.b, a];\n                this.colorMap[temp] = vec3;\n                return vec3;\n            } else {\n                return [0, 0, 0, 1];\n            }\n        }\n    }, {\n        key: 'rgba2vec',\n        value: function rgba2vec(rgb) {\n            var temp = rgb;\n            var vec3 = this.colorMap[temp];\n            if (vec3 != undefined) return vec3;\n            rgb = rgb.match(new RegExp(\",\", \"g\"));\n            rgb = rgb || [];\n            var a = 1.0;\n            if (rgb.length == 3) {\n                rgb = temp;\n                var i = rgb.lastIndexOf(',');\n                var i1 = rgb.lastIndexOf(')');\n                var as = rgb.substring(i + 1, i1);\n                a = parseFloat(as);\n                rgb = rgb.substring(0, i);\n                rgb += ')';\n            } else {\n                rgb = temp;\n            }\n            rgb = rgb.replace('a', '');\n            return this.getVec(rgb, temp, a);\n        }\n    }, {\n        key: 'getVec',\n        value: function getVec(string, key, alpha) {\n            var vec3 = this.colorMap[key];\n            if (vec3 != undefined) return vec3;\n            var v = new _W3Color2.default(string);\n            if (v.valid) {\n                var v1 = v.toRgb();\n                var _vec = [v1.r, v1.g, v1.b, alpha];\n                if (this.colorMap[key] == undefined) this.colorMap[key] = _vec;\n                return _vec;\n            } else {\n                return [0, 0, 0, 1];\n            }\n        }\n    }], [{\n        key: 'getInstance',\n        value: function getInstance() {\n            if (!_instance) {\n                _instance = new Color();\n            }\n            return _instance;\n        }\n    }, {\n        key: 'isRGBAString',\n        value: function isRGBAString(string) {\n            if (string) {\n                if (string.indexOf('rgba') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }, {\n        key: 'isHSLAString',\n        value: function isHSLAString(string) {\n            if (string) {\n                if (string.indexOf('hsla') == 0) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }]);\n\n    return Color;\n}();\n\nexports.default = Color;\n\n//# sourceURL=webpack://tielifa/./build/utils/Color.js?");

/***/ }),

/***/ "./build/utils/Tools.js":
/*!******************************!*\
  !*** ./build/utils/Tools.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar EPSILON = 0.00001;\nvar PI2 = Math.PI * 2;\nvar HALFPI = Math.PI / 2;\nvar PIDIV180 = Math.PI / 180;\nvar ONE80DIVPI = 180 / Math.PI;\nvar littleEndian = undefined;\n\nvar Tools = function () {\n    function Tools() {\n        _classCallCheck(this, Tools);\n\n        this.instance = null;\n    }\n\n    _createClass(Tools, null, [{\n        key: \"equals\",\n        value: function equals(a, b) {\n            // return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\n            return Math.abs(a - b) <= EPSILON;\n        }\n    }, {\n        key: \"insertSort\",\n        value: function insertSort(array) {\n            var n = array.length;\n            if (n <= 1) {\n                return array;\n            }\n            for (var i = 1; i < n; i++) {\n                var temp = array[i];\n                var j = i - 1;\n                for (; j >= 0; j--) {\n                    if (array[j] > temp) {\n                        array[j + 1] = array[j]; // 比temp 大的已排序数据后移一位\n                    } else {\n                        break;\n                    }\n                }\n                array[j + 1] = temp; // 空出来的位置，把temp放进去\n            }\n            return array;\n        }\n    }, {\n        key: \"removeObjFromArray\",\n        value: function removeObjFromArray(obj, array) {\n            for (var i = 0; i < array.length; i++) {\n                if (obj === array[i]) {\n                    array.splice(i, 1);\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    }, {\n        key: \"addAllInArray\",\n        value: function addAllInArray(array, array2) {\n            for (var i = 0; i < array2.length; i++) {\n                array.push(array2[i]);\n            }\n        }\n    }, {\n        key: \"getDistance\",\n        value: function getDistance(point1, point2) {\n            var dx = point1.x - point2.x;\n            var dy = point1.y - point2.y;\n            var dz = 0;\n            if (point1.z != undefined && point2.z != undefined) {\n                dz = point1.z - point2.z;\n            }\n            return Math.sqrt(dx * dx + dy * dy + dz * dz);\n        }\n\n        // static collisionResponse(v1, m1, v2, m2, n, e) {\n        //     if (e == undefined) e = 1; // 恢复系数默认为1\n        //     let m1d = undefined;\n        //     let m2d = undefined;\n        //     if (m1 == Infinity) {\n        //         m2d = 1;\n        //         m1d = 0;\n        //     }\n        //     if (m2 == Infinity) {\n        //         m2d = 0;\n        //         m1d = 1;\n        //     }\n        //     if (m1d == undefined && m2d == undefined) {\n        //         m1d = 1 / m1;\n        //         m2d = 1 / m2;\n        //     }\n        //     let up = 0 - (1 + e);\n        //     let v12 = Vector2.TEMP_VECTORS[0];\n        //     v12.x = v1.x - v2.x;\n        //     v12.y = v1.y - v2.y;\n        //     up = up * Vector2.dot(v12, n);\n        //     let tempVector = v12;// {x: n.x, y: n.y};\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, (m1d + m2d));\n        //     let down = Vector2.dot(n, tempVector);\n        //     let j = up / down;\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m1d);\n        //     let newV1 = {x: 0, y: 0};\n        //     Vector2.add(newV1, v1, tempVector);\n        //\n        //     tempVector.x = n.x;\n        //     tempVector.y = n.y;\n        //     Vector2.multiplyValue(tempVector, tempVector, j * m2d);\n        //     let newV2 = {x: 0, y: 0};\n        //     Vector2.sub(newV2, v2, tempVector);\n        //\n        //     return {newV1: newV1, newV2: newV2};\n        // }\n        //\n        //\n        // getProjectionPointOnLine(point, linePoint1, linePoint2) {\n        //     let p = point; // 线外一点p\n        //     let a = linePoint1; // 线上端点a\n        //     let b = linePoint2; // 线上端点b\n        //     let ap = new Vector2(p.x - a.x, p.y - a.y);\n        //     let ab = new Vector2(b.x - a.x, b.y - a.y);\n        //     let abN = Vector2.normalize(ab, ab);//计算出ab的单位向量\n        //     let compAP = Vector2.dot(ap, abN);//ap在ab上分量\n        //     abN.multiply(compAP); //ap在ab上的投影,返回值就是abN\n        //     let p0 = {x: 0, y: 0};\n        //     Vector2.plus(p0, a, abN);\n        //     return p0;\n        // }\n\n    }, {\n        key: \"clamp\",\n        value: function clamp(value, min, max) {\n            if (value > max) {\n                return max;\n            }\n            if (value < min) {\n                return min;\n            }\n            return value;\n        }\n    }, {\n        key: \"getInsance\",\n        value: function getInsance() {\n            if (this.instance == null) {\n                this.instance = new Tools();\n            }\n            return this.instance;\n        }\n    }, {\n        key: \"overlaps\",\n        value: function overlaps(bounds1, bounds2) {\n            var a = bounds1;\n            var b = bounds2;\n            return a.left <= b.right && a.right >= b.left && a.bottom >= b.top && a.top <= b.bottom;\n        }\n    }, {\n        key: \"isHit\",\n        value: function isHit(rect1, rect2) {\n            var result = false;\n            var x = rect1.left;\n            var y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            x = rect1.left + rect1.width;\n            y = rect1.top;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n\n            x = rect1.left + rect1.width;\n            y = rect1.top + rect1.height;\n            if (Tools.isInTheRect(x, y, rect2)) {\n                result = true;\n            }\n            if (!result) {\n                x = rect2.left;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n                x = rect2.left + rect2.width;\n                y = rect2.top;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n\n                x = rect2.left + rect2.width;\n                y = rect2.top + rect2.height;\n                if (Tools.isInTheRect(x, y, rect1)) {\n                    result = true;\n                }\n            }\n            return result;\n        }\n    }, {\n        key: \"isInTheRect\",\n        value: function isInTheRect(x, y, rect) {\n            var fx = rect.left;\n            var fy = rect.top;\n            var currentWidth = rect.width;\n            var currentHeight = rect.height;\n            if (x > fx && x < fx + currentWidth && y > fy && y < fy + currentHeight) {\n                return true;\n            }\n            return false;\n        }\n    }, {\n        key: \"HALFPI\",\n        get: function get() {\n            return HALFPI;\n        }\n    }, {\n        key: \"ONE80DIVPI\",\n        get: function get() {\n            return ONE80DIVPI;\n        }\n    }, {\n        key: \"PIDIV180\",\n        get: function get() {\n            return PIDIV180;\n        }\n    }, {\n        key: \"PI2\",\n        get: function get() {\n            return PI2;\n        }\n    }, {\n        key: \"EPSILON\",\n        get: function get() {\n            return EPSILON;\n        }\n    }, {\n        key: \"littleEndian\",\n        get: function get() {\n            if (littleEndian === undefined) {\n                // DataView是默认按照高位存放，这里要做判断，更改存放顺序\n                var arrayBuffer = new ArrayBuffer(2);\n                var uint8Array = new Uint8Array(arrayBuffer);\n                var uint16array = new Uint16Array(arrayBuffer);\n                uint8Array[0] = 0xAA; // 第一位是AA\n                uint8Array[1] = 0xBB; // 第二位是BB\n                // 如果从16的view中读取数据，按照其排序就能得出高低位，以便DataView在设置值的时候能正确\n                if (uint16array[0] === 0xBBAA) littleEndian = true;\n                if (uint16array[0] === 0xAABB) littleEndian = false;\n            }\n            return littleEndian;\n        }\n    }]);\n\n    return Tools;\n}();\n\nexports.default = Tools;\n\n//# sourceURL=webpack://tielifa/./build/utils/Tools.js?");

/***/ }),

/***/ "./build/utils/W3Color.js":
/*!********************************!*\
  !*** ./build/utils/W3Color.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* w3color.js ver.1.11 by w3schools.com (Do not remove this line)*/\n/*用es6 class重构一下*/\nvar W3Color = function () {\n    function W3Color(color, elmnt) {\n        _classCallCheck(this, W3Color);\n\n        if (!(this instanceof W3Color)) {\n            return new W3Color(color, elmnt);\n        }\n        if ((typeof color === \"undefined\" ? \"undefined\" : _typeof(color)) == \"object\") {\n            return color;\n        }\n        this.attachValues(W3Color.toColorObject(color));\n        if (elmnt) {\n            elmnt.style.backgroundColor = this.toRgbString();\n        }\n    }\n\n    _createClass(W3Color, [{\n        key: \"attachValues\",\n        value: function attachValues(color) {\n            this.red = color.red;\n            this.green = color.green;\n            this.blue = color.blue;\n            this.hue = color.hue;\n            this.sat = color.sat;\n            this.lightness = color.lightness;\n            this.whiteness = color.whiteness;\n            this.blackness = color.blackness;\n            this.cyan = color.cyan;\n            this.magenta = color.magenta;\n            this.yellow = color.yellow;\n            this.black = color.black;\n            this.ncol = color.ncol;\n            this.opacity = color.opacity;\n            this.valid = color.valid;\n        }\n    }, {\n        key: \"toRgbString\",\n        value: function toRgbString() {\n            return \"rgb(\" + this.red + \", \" + this.green + \", \" + this.blue + \")\";\n        }\n    }, {\n        key: \"toRgbaString\",\n        value: function toRgbaString() {\n            return \"rgba(\" + this.red + \", \" + this.green + \", \" + this.blue + \", \" + this.opacity + \")\";\n        }\n    }, {\n        key: \"toHwbString\",\n        value: function toHwbString() {\n            return \"hwb(\" + this.hue + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%)\";\n        }\n    }, {\n        key: \"toHwbStringDecimal\",\n        value: function toHwbStringDecimal() {\n            return \"hwb(\" + this.hue + \", \" + this.whiteness + \", \" + this.blackness + \")\";\n        }\n    }, {\n        key: \"toHwbaString\",\n        value: function toHwbaString() {\n            return \"hwba(\" + this.hue + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%, \" + this.opacity + \")\";\n        }\n    }, {\n        key: \"toHslString\",\n        value: function toHslString() {\n            return \"hsl(\" + this.hue + \", \" + Math.round(this.sat * 100) + \"%, \" + Math.round(this.lightness * 100) + \"%)\";\n        }\n    }, {\n        key: \"toHslStringDecimal\",\n        value: function toHslStringDecimal() {\n            return \"hsl(\" + this.hue + \", \" + this.sat + \", \" + this.lightness + \")\";\n        }\n    }, {\n        key: \"toHslaString\",\n        value: function toHslaString() {\n            return \"hsla(\" + this.hue + \", \" + Math.round(this.sat * 100) + \"%, \" + Math.round(this.lightness * 100) + \"%, \" + this.opacity + \")\";\n        }\n    }, {\n        key: \"toCmykString\",\n        value: function toCmykString() {\n            return \"cmyk(\" + Math.round(this.cyan * 100) + \"%, \" + Math.round(this.magenta * 100) + \"%, \" + Math.round(this.yellow * 100) + \"%, \" + Math.round(this.black * 100) + \"%)\";\n        }\n    }, {\n        key: \"toCmykStringDecimal\",\n        value: function toCmykStringDecimal() {\n            return \"cmyk(\" + this.cyan + \", \" + this.magenta + \", \" + this.yellow + \", \" + this.black + \")\";\n        }\n    }, {\n        key: \"toNcolString\",\n        value: function toNcolString() {\n            return this.ncol + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%\";\n        }\n    }, {\n        key: \"toNcolStringDecimal\",\n        value: function toNcolStringDecimal() {\n            return this.ncol + \", \" + this.whiteness + \", \" + this.blackness;\n        }\n    }, {\n        key: \"toNcolaString\",\n        value: function toNcolaString() {\n            return this.ncol + \", \" + Math.round(this.whiteness * 100) + \"%, \" + Math.round(this.blackness * 100) + \"%, \" + this.opacity;\n        }\n    }, {\n        key: \"toName\",\n        value: function toName() {\n            var r,\n                g,\n                b,\n                colorhexs = getColorArr('hexs');\n            for (i = 0; i < colorhexs.length; i++) {\n                r = parseInt(colorhexs[i].substr(0, 2), 16);\n                g = parseInt(colorhexs[i].substr(2, 2), 16);\n                b = parseInt(colorhexs[i].substr(4, 2), 16);\n                if (this.red == r && this.green == g && this.blue == b) {\n                    return getColorArr('names')[i];\n                }\n            }\n            return \"\";\n        }\n    }, {\n        key: \"toHexString\",\n        value: function toHexString() {\n            var r = toHex(this.red);\n            var g = toHex(this.green);\n            var b = toHex(this.blue);\n            return \"#\" + r + g + b;\n        }\n    }, {\n        key: \"toRgb\",\n        value: function toRgb() {\n            return { r: this.red, g: this.green, b: this.blue, a: this.opacity };\n        }\n    }, {\n        key: \"toHsl\",\n        value: function toHsl() {\n            return { h: this.hue, s: this.sat, l: this.lightness, a: this.opacity };\n        }\n    }, {\n        key: \"toHwb\",\n        value: function toHwb() {\n            return { h: this.hue, w: this.whiteness, b: this.blackness, a: this.opacity };\n        }\n    }, {\n        key: \"toCmyk\",\n        value: function toCmyk() {\n            return { c: this.cyan, m: this.magenta, y: this.yellow, k: this.black, a: this.opacity };\n        }\n    }, {\n        key: \"toNcol\",\n        value: function toNcol() {\n            return { ncol: this.ncol, w: this.whiteness, b: this.blackness, a: this.opacity };\n        }\n    }, {\n        key: \"isDark\",\n        value: function isDark(n) {\n            var m = n || 128;\n            return (this.red * 299 + this.green * 587 + this.blue * 114) / 1000 < m;\n        }\n    }, {\n        key: \"saturate\",\n        value: function saturate(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.sat += x;\n            if (this.sat > 1) {\n                this.sat = 1;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n    }, {\n        key: \"desaturate\",\n        value: function desaturate(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.sat -= x;\n            if (this.sat < 0) {\n                this.sat = 0;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n    }, {\n        key: \"lighter\",\n        value: function lighter(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.lightness += x;\n            if (this.lightness > 1) {\n                this.lightness = 1;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n    }, {\n        key: \"darker\",\n        value: function darker(n) {\n            var x, rgb, color;\n            x = n / 100 || 0.1;\n            this.lightness -= x;\n            if (this.lightness < 0) {\n                this.lightness = 0;\n            }\n            rgb = hslToRgb(this.hue, this.sat, this.lightness);\n            color = colorObject(rgb, this.opacity, this.hue, this.sat);\n            this.attachValues(color);\n        }\n\n        // (function () {\n\n    }], [{\n        key: \"w3color\",\n        value: function (_w3color) {\n            function w3color(_x, _x2) {\n                return _w3color.apply(this, arguments);\n            }\n\n            w3color.toString = function () {\n                return _w3color.toString();\n            };\n\n            return w3color;\n        }(function (color, elmnt) {\n            if (!(this instanceof w3color)) {\n                return new w3color(color, elmnt);\n            }\n            if ((typeof color === \"undefined\" ? \"undefined\" : _typeof(color)) == \"object\") {\n                return color;\n            }\n            this.attachValues(toColorObject(color));\n            if (elmnt) {\n                elmnt.style.backgroundColor = this.toRgbString();\n            }\n        })\n    }, {\n        key: \"toColorObject\",\n        value: function toColorObject(c) {\n            var x,\n                y,\n                typ,\n                arr = [],\n                arrlength,\n                i,\n                opacity,\n                match,\n                a,\n                hue,\n                sat,\n                rgb,\n                colornames = [],\n                colorhexs = [];\n            c = this.w3trim(c.toLowerCase());\n            x = c.substr(0, 1).toUpperCase();\n            y = c.substr(1);\n            a = 1;\n            if ((x == \"R\" || x == \"Y\" || x == \"G\" || x == \"C\" || x == \"B\" || x == \"M\" || x == \"W\") && !isNaN(y)) {\n                if (c.length == 6 && c.indexOf(\",\") == -1) {} else {\n                    c = \"ncol(\" + c + \")\";\n                }\n            }\n            if (c.length != 3 && c.length != 6 && !isNaN(c)) {\n                c = \"ncol(\" + c + \")\";\n            }\n            if (c.indexOf(\",\") > 0 && c.indexOf(\"(\") == -1) {\n                c = \"ncol(\" + c + \")\";\n            }\n            if (c.substr(0, 3) == \"rgb\" || c.substr(0, 3) == \"hsl\" || c.substr(0, 3) == \"hwb\" || c.substr(0, 4) == \"ncol\" || c.substr(0, 4) == \"cmyk\") {\n                if (c.substr(0, 4) == \"ncol\") {\n                    if (c.split(\",\").length == 4 && c.indexOf(\"ncola\") == -1) {\n                        c = c.replace(\"ncol\", \"ncola\");\n                    }\n                    typ = \"ncol\";\n                    c = c.substr(4);\n                } else if (c.substr(0, 4) == \"cmyk\") {\n                    typ = \"cmyk\";\n                    c = c.substr(4);\n                } else {\n                    typ = c.substr(0, 3);\n                    c = c.substr(3);\n                }\n                arrlength = 3;\n                opacity = false;\n                if (c.substr(0, 1).toLowerCase() == \"a\") {\n                    arrlength = 4;\n                    opacity = true;\n                    c = c.substr(1);\n                } else if (typ == \"cmyk\") {\n                    arrlength = 4;\n                    if (c.split(\",\").length == 5) {\n                        arrlength = 5;\n                        opacity = true;\n                    }\n                }\n                c = c.replace(\"(\", \"\");\n                c = c.replace(\")\", \"\");\n                arr = c.split(\",\");\n                if (typ == \"rgb\") {\n                    if (arr.length != arrlength) {\n                        return this.emptyObject();\n                    }\n                    for (i = 0; i < arrlength; i++) {\n                        if (arr[i] == \"\" || arr[i] == \" \") {\n                            arr[i] = \"0\";\n                        }\n                        if (arr[i].indexOf(\"%\") > -1) {\n                            arr[i] = arr[i].replace(\"%\", \"\");\n                            arr[i] = Number(arr[i] / 100);\n                            if (i < 3) {\n                                arr[i] = Math.round(arr[i] * 255);\n                            }\n                        }\n                        if (isNaN(arr[i])) {\n                            return this.emptyObject();\n                        }\n                        if (parseInt(arr[i]) > 255) {\n                            arr[i] = 255;\n                        }\n                        if (i < 3) {\n                            arr[i] = parseInt(arr[i]);\n                        }\n                        if (i == 3 && Number(arr[i]) > 1) {\n                            arr[i] = 1;\n                        }\n                    }\n                    rgb = { r: arr[0], g: arr[1], b: arr[2] };\n                    if (opacity == true) {\n                        a = Number(arr[3]);\n                    }\n                }\n                if (typ == \"hsl\" || typ == \"hwb\" || typ == \"ncol\") {\n                    while (arr.length < arrlength) {\n                        arr.push(\"0\");\n                    }\n                    if (typ == \"hsl\" || typ == \"hwb\") {\n                        if (parseInt(arr[0]) >= 360) {\n                            arr[0] = 0;\n                        }\n                    }\n                    for (i = 1; i < arrlength; i++) {\n                        if (arr[i].indexOf(\"%\") > -1) {\n                            arr[i] = arr[i].replace(\"%\", \"\");\n                            arr[i] = Number(arr[i]);\n                            if (isNaN(arr[i])) {\n                                return this.emptyObject();\n                            }\n                            arr[i] = arr[i] / 100;\n                        } else {\n                            arr[i] = Number(arr[i]);\n                        }\n                        if (Number(arr[i]) > 1) {\n                            arr[i] = 1;\n                        }\n                        if (Number(arr[i]) < 0) {\n                            arr[i] = 0;\n                        }\n                    }\n                    if (typ == \"hsl\") {\n                        rgb = this.hslToRgb(arr[0], arr[1], arr[2]);\n                        hue = Number(arr[0]);\n                        sat = Number(arr[1]);\n                    }\n                    if (typ == \"hwb\") {\n                        rgb = this.hwbToRgb(arr[0], arr[1], arr[2]);\n                    }\n                    if (typ == \"ncol\") {\n                        rgb = this.ncolToRgb(arr[0], arr[1], arr[2]);\n                    }\n                    if (opacity == true) {\n                        a = Number(arr[3]);\n                    }\n                }\n                if (typ == \"cmyk\") {\n                    while (arr.length < arrlength) {\n                        arr.push(\"0\");\n                    }\n                    for (i = 0; i < arrlength; i++) {\n                        if (arr[i].indexOf(\"%\") > -1) {\n                            arr[i] = arr[i].replace(\"%\", \"\");\n                            arr[i] = Number(arr[i]);\n                            if (isNaN(arr[i])) {\n                                return this.emptyObject();\n                            }\n                            arr[i] = arr[i] / 100;\n                        } else {\n                            arr[i] = Number(arr[i]);\n                        }\n                        if (Number(arr[i]) > 1) {\n                            arr[i] = 1;\n                        }\n                        if (Number(arr[i]) < 0) {\n                            arr[i] = 0;\n                        }\n                    }\n                    rgb = this.cmykToRgb(arr[0], arr[1], arr[2], arr[3]);\n                    if (opacity == true) {\n                        a = Number(arr[4]);\n                    }\n                }\n            } else if (c.substr(0, 3) == \"ncs\") {\n                rgb = this.ncsToRgb(c);\n            } else {\n                match = false;\n                colornames = this.getColorArr('names');\n                for (i = 0; i < colornames.length; i++) {\n                    if (c.toLowerCase() == colornames[i].toLowerCase()) {\n                        colorhexs = this.getColorArr('hexs');\n                        match = true;\n                        rgb = {\n                            r: parseInt(colorhexs[i].substr(0, 2), 16),\n                            g: parseInt(colorhexs[i].substr(2, 2), 16),\n                            b: parseInt(colorhexs[i].substr(4, 2), 16)\n                        };\n                        break;\n                    }\n                }\n                if (match == false) {\n                    c = c.replace(\"#\", \"\");\n                    if (c.length == 3) {\n                        c = c.substr(0, 1) + c.substr(0, 1) + c.substr(1, 1) + c.substr(1, 1) + c.substr(2, 1) + c.substr(2, 1);\n                    }\n                    for (i = 0; i < c.length; i++) {\n                        if (!this.isHex(c.substr(i, 1))) {\n                            return this.emptyObject();\n                        }\n                    }\n                    arr[0] = parseInt(c.substr(0, 2), 16);\n                    arr[1] = parseInt(c.substr(2, 2), 16);\n                    arr[2] = parseInt(c.substr(4, 2), 16);\n                    for (i = 0; i < 3; i++) {\n                        if (isNaN(arr[i])) {\n                            return this.emptyObject();\n                        }\n                    }\n                    rgb = {\n                        r: arr[0],\n                        g: arr[1],\n                        b: arr[2]\n                    };\n                }\n            }\n            return this.colorObject(rgb, a, hue, sat);\n        }\n    }, {\n        key: \"colorObject\",\n        value: function colorObject(rgb, a, h, s) {\n            var hsl, hwb, cmyk, ncol, color, hue, sat;\n            if (!rgb) {\n                return this.emptyObject();\n            }\n            if (!a) {\n                a = 1;\n            }\n            hsl = this.rgbToHsl(rgb.r, rgb.g, rgb.b);\n            hwb = this.rgbToHwb(rgb.r, rgb.g, rgb.b);\n            cmyk = this.rgbToCmyk(rgb.r, rgb.g, rgb.b);\n            hue = h || hsl.h;\n            sat = s || hsl.s;\n            ncol = this.hueToNcol(hue);\n            color = {\n                red: rgb.r,\n                green: rgb.g,\n                blue: rgb.b,\n                hue: hue,\n                sat: sat,\n                lightness: hsl.l,\n                whiteness: hwb.w,\n                blackness: hwb.b,\n                cyan: cmyk.c,\n                magenta: cmyk.m,\n                yellow: cmyk.y,\n                black: cmyk.k,\n                ncol: ncol,\n                opacity: a,\n                valid: true\n            };\n            color = this.roundDecimals(color);\n            return color;\n        }\n    }, {\n        key: \"emptyObject\",\n        value: function emptyObject() {\n            return {\n                red: 0,\n                green: 0,\n                blue: 0,\n                hue: 0,\n                sat: 0,\n                lightness: 0,\n                whiteness: 0,\n                blackness: 0,\n                cyan: 0,\n                magenta: 0,\n                yellow: 0,\n                black: 0,\n                ncol: \"R\",\n                opacity: 1,\n                valid: false\n            };\n        }\n    }, {\n        key: \"getColorArr\",\n        value: function getColorArr(x) {\n            if (x == \"names\") {\n                return ['AliceBlue', 'AntiqueWhite', 'Aqua', 'Aquamarine', 'Azure', 'Beige', 'Bisque', 'Black', 'BlanchedAlmond', 'Blue', 'BlueViolet', 'Brown', 'BurlyWood', 'CadetBlue', 'Chartreuse', 'Chocolate', 'Coral', 'CornflowerBlue', 'Cornsilk', 'Crimson', 'Cyan', 'DarkBlue', 'DarkCyan', 'DarkGoldenRod', 'DarkGray', 'DarkGrey', 'DarkGreen', 'DarkKhaki', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrange', 'DarkOrchid', 'DarkRed', 'DarkSalmon', 'DarkSeaGreen', 'DarkSlateBlue', 'DarkSlateGray', 'DarkSlateGrey', 'DarkTurquoise', 'DarkViolet', 'DeepPink', 'DeepSkyBlue', 'DimGray', 'DimGrey', 'DodgerBlue', 'FireBrick', 'FloralWhite', 'ForestGreen', 'Fuchsia', 'Gainsboro', 'GhostWhite', 'Gold', 'GoldenRod', 'Gray', 'Grey', 'Green', 'GreenYellow', 'HoneyDew', 'HotPink', 'IndianRed', 'Indigo', 'Ivory', 'Khaki', 'Lavender', 'LavenderBlush', 'LawnGreen', 'LemonChiffon', 'LightBlue', 'LightCoral', 'LightCyan', 'LightGoldenRodYellow', 'LightGray', 'LightGrey', 'LightGreen', 'LightPink', 'LightSalmon', 'LightSeaGreen', 'LightSkyBlue', 'LightSlateGray', 'LightSlateGrey', 'LightSteelBlue', 'LightYellow', 'Lime', 'LimeGreen', 'Linen', 'Magenta', 'Maroon', 'MediumAquaMarine', 'MediumBlue', 'MediumOrchid', 'MediumPurple', 'MediumSeaGreen', 'MediumSlateBlue', 'MediumSpringGreen', 'MediumTurquoise', 'MediumVioletRed', 'MidnightBlue', 'MintCream', 'MistyRose', 'Moccasin', 'NavajoWhite', 'Navy', 'OldLace', 'Olive', 'OliveDrab', 'Orange', 'OrangeRed', 'Orchid', 'PaleGoldenRod', 'PaleGreen', 'PaleTurquoise', 'PaleVioletRed', 'PapayaWhip', 'PeachPuff', 'Peru', 'Pink', 'Plum', 'PowderBlue', 'Purple', 'RebeccaPurple', 'Red', 'RosyBrown', 'RoyalBlue', 'SaddleBrown', 'Salmon', 'SandyBrown', 'SeaGreen', 'SeaShell', 'Sienna', 'Silver', 'SkyBlue', 'SlateBlue', 'SlateGray', 'SlateGrey', 'Snow', 'SpringGreen', 'SteelBlue', 'Tan', 'Teal', 'Thistle', 'Tomato', 'Turquoise', 'Violet', 'Wheat', 'White', 'WhiteSmoke', 'Yellow', 'YellowGreen'];\n            }\n            if (x == \"hexs\") {\n                return ['f0f8ff', 'faebd7', '00ffff', '7fffd4', 'f0ffff', 'f5f5dc', 'ffe4c4', '000000', 'ffebcd', '0000ff', '8a2be2', 'a52a2a', 'deb887', '5f9ea0', '7fff00', 'd2691e', 'ff7f50', '6495ed', 'fff8dc', 'dc143c', '00ffff', '00008b', '008b8b', 'b8860b', 'a9a9a9', 'a9a9a9', '006400', 'bdb76b', '8b008b', '556b2f', 'ff8c00', '9932cc', '8b0000', 'e9967a', '8fbc8f', '483d8b', '2f4f4f', '2f4f4f', '00ced1', '9400d3', 'ff1493', '00bfff', '696969', '696969', '1e90ff', 'b22222', 'fffaf0', '228b22', 'ff00ff', 'dcdcdc', 'f8f8ff', 'ffd700', 'daa520', '808080', '808080', '008000', 'adff2f', 'f0fff0', 'ff69b4', 'cd5c5c', '4b0082', 'fffff0', 'f0e68c', 'e6e6fa', 'fff0f5', '7cfc00', 'fffacd', 'add8e6', 'f08080', 'e0ffff', 'fafad2', 'd3d3d3', 'd3d3d3', '90ee90', 'ffb6c1', 'ffa07a', '20b2aa', '87cefa', '778899', '778899', 'b0c4de', 'ffffe0', '00ff00', '32cd32', 'faf0e6', 'ff00ff', '800000', '66cdaa', '0000cd', 'ba55d3', '9370db', '3cb371', '7b68ee', '00fa9a', '48d1cc', 'c71585', '191970', 'f5fffa', 'ffe4e1', 'ffe4b5', 'ffdead', '000080', 'fdf5e6', '808000', '6b8e23', 'ffa500', 'ff4500', 'da70d6', 'eee8aa', '98fb98', 'afeeee', 'db7093', 'ffefd5', 'ffdab9', 'cd853f', 'ffc0cb', 'dda0dd', 'b0e0e6', '800080', '663399', 'ff0000', 'bc8f8f', '4169e1', '8b4513', 'fa8072', 'f4a460', '2e8b57', 'fff5ee', 'a0522d', 'c0c0c0', '87ceeb', '6a5acd', '708090', '708090', 'fffafa', '00ff7f', '4682b4', 'd2b48c', '008080', 'd8bfd8', 'ff6347', '40e0d0', 'ee82ee', 'f5deb3', 'ffffff', 'f5f5f5', 'ffff00', '9acd32'];\n            }\n        }\n    }, {\n        key: \"roundDecimals\",\n        value: function roundDecimals(c) {\n            c.red = Number(c.red.toFixed(0));\n            c.green = Number(c.green.toFixed(0));\n            c.blue = Number(c.blue.toFixed(0));\n            c.hue = Number(c.hue.toFixed(0));\n            c.sat = Number(c.sat.toFixed(2));\n            c.lightness = Number(c.lightness.toFixed(2));\n            c.whiteness = Number(c.whiteness.toFixed(2));\n            c.blackness = Number(c.blackness.toFixed(2));\n            c.cyan = Number(c.cyan.toFixed(2));\n            c.magenta = Number(c.magenta.toFixed(2));\n            c.yellow = Number(c.yellow.toFixed(2));\n            c.black = Number(c.black.toFixed(2));\n            c.ncol = c.ncol.substr(0, 1) + Math.round(Number(c.ncol.substr(1)));\n            c.opacity = Number(c.opacity.toFixed(2));\n            return c;\n        }\n    }, {\n        key: \"hslToRgb\",\n        value: function hslToRgb(hue, sat, light) {\n            var t1, t2, r, g, b;\n            hue = hue / 60;\n            if (light <= 0.5) {\n                t2 = light * (sat + 1);\n            } else {\n                t2 = light + sat - light * sat;\n            }\n            t1 = light * 2 - t2;\n            r = hueToRgb(t1, t2, hue + 2) * 255;\n            g = hueToRgb(t1, t2, hue) * 255;\n            b = hueToRgb(t1, t2, hue - 2) * 255;\n            return { r: r, g: g, b: b };\n        }\n    }, {\n        key: \"hueToRgb\",\n        value: function hueToRgb(t1, t2, hue) {\n            if (hue < 0) hue += 6;\n            if (hue >= 6) hue -= 6;\n            if (hue < 1) return (t2 - t1) * hue + t1;else if (hue < 3) return t2;else if (hue < 4) return (t2 - t1) * (4 - hue) + t1;else return t1;\n        }\n    }, {\n        key: \"hwbToRgb\",\n        value: function hwbToRgb(hue, white, black) {\n            var i,\n                rgb,\n                rgbArr = [],\n                tot;\n            rgb = hslToRgb(hue, 1, 0.50);\n            rgbArr[0] = rgb.r / 255;\n            rgbArr[1] = rgb.g / 255;\n            rgbArr[2] = rgb.b / 255;\n            tot = white + black;\n            if (tot > 1) {\n                white = Number((white / tot).toFixed(2));\n                black = Number((black / tot).toFixed(2));\n            }\n            for (i = 0; i < 3; i++) {\n                rgbArr[i] *= 1 - white - black;\n                rgbArr[i] += white;\n                rgbArr[i] = Number(rgbArr[i] * 255);\n            }\n            return { r: rgbArr[0], g: rgbArr[1], b: rgbArr[2] };\n        }\n    }, {\n        key: \"cmykToRgb\",\n        value: function cmykToRgb(c, m, y, k) {\n            var r, g, b;\n            r = 255 - Math.min(1, c * (1 - k) + k) * 255;\n            g = 255 - Math.min(1, m * (1 - k) + k) * 255;\n            b = 255 - Math.min(1, y * (1 - k) + k) * 255;\n            return { r: r, g: g, b: b };\n        }\n    }, {\n        key: \"ncolToRgb\",\n        value: function ncolToRgb(ncol, white, black) {\n            var letter, percent, h, w, b;\n            h = ncol;\n            if (isNaN(ncol.substr(0, 1))) {\n                letter = ncol.substr(0, 1).toUpperCase();\n                percent = ncol.substr(1);\n                if (percent == \"\") {\n                    percent = 0;\n                }\n                percent = Number(percent);\n                if (isNaN(percent)) {\n                    return false;\n                }\n                if (letter == \"R\") {\n                    h = 0 + percent * 0.6;\n                }\n                if (letter == \"Y\") {\n                    h = 60 + percent * 0.6;\n                }\n                if (letter == \"G\") {\n                    h = 120 + percent * 0.6;\n                }\n                if (letter == \"C\") {\n                    h = 180 + percent * 0.6;\n                }\n                if (letter == \"B\") {\n                    h = 240 + percent * 0.6;\n                }\n                if (letter == \"M\") {\n                    h = 300 + percent * 0.6;\n                }\n                if (letter == \"W\") {\n                    h = 0;\n                    white = 1 - percent / 100;\n                    black = percent / 100;\n                }\n            }\n            return hwbToRgb(h, white, black);\n        }\n    }, {\n        key: \"hueToNcol\",\n        value: function hueToNcol(hue) {\n            while (hue >= 360) {\n                hue = hue - 360;\n            }\n            if (hue < 60) {\n                return \"R\" + hue / 0.6;\n            }\n            if (hue < 120) {\n                return \"Y\" + (hue - 60) / 0.6;\n            }\n            if (hue < 180) {\n                return \"G\" + (hue - 120) / 0.6;\n            }\n            if (hue < 240) {\n                return \"C\" + (hue - 180) / 0.6;\n            }\n            if (hue < 300) {\n                return \"B\" + (hue - 240) / 0.6;\n            }\n            if (hue < 360) {\n                return \"M\" + (hue - 300) / 0.6;\n            }\n        }\n    }, {\n        key: \"ncsToRgb\",\n        value: function ncsToRgb(ncs) {\n            var black, chroma, bc, percent, black1, chroma1, red1, factor1, blue1, red1, red2, green2, blue2, max, factor2, grey, r, g, b;\n            ncs = w3trim(ncs).toUpperCase();\n            ncs = ncs.replace(\"(\", \"\");\n            ncs = ncs.replace(\")\", \"\");\n            ncs = ncs.replace(\"NCS\", \"NCS \");\n            ncs = ncs.replace(/  /g, \" \");\n            if (ncs.indexOf(\"NCS\") == -1) {\n                ncs = \"NCS \" + ncs;\n            }\n            ncs = ncs.match(/^(?:NCS|NCS\\sS)\\s(\\d{2})(\\d{2})-(N|[A-Z])(\\d{2})?([A-Z])?$/);\n            if (ncs === null) return false;\n            black = parseInt(ncs[1], 10);\n            chroma = parseInt(ncs[2], 10);\n            bc = ncs[3];\n            if (bc != \"N\" && bc != \"Y\" && bc != \"R\" && bc != \"B\" && bc != \"G\") {\n                return false;\n            }\n            percent = parseInt(ncs[4], 10) || 0;\n            if (bc !== 'N') {\n                black1 = 1.05 * black - 5.25;\n                chroma1 = chroma;\n                if (bc === 'Y' && percent <= 60) {\n                    red1 = 1;\n                } else if (bc === 'Y' && percent > 60 || bc === 'R' && percent <= 80) {\n                    if (bc === 'Y') {\n                        factor1 = percent - 60;\n                    } else {\n                        factor1 = percent + 40;\n                    }\n                    red1 = (Math.sqrt(14884 - Math.pow(factor1, 2)) - 22) / 100;\n                } else if (bc === 'R' && percent > 80 || bc === 'B') {\n                    red1 = 0;\n                } else if (bc === 'G') {\n                    factor1 = percent - 170;\n                    red1 = (Math.sqrt(33800 - Math.pow(factor1, 2)) - 70) / 100;\n                }\n                if (bc === 'Y' && percent <= 80) {\n                    blue1 = 0;\n                } else if (bc === 'Y' && percent > 80 || bc === 'R' && percent <= 60) {\n                    if (bc === 'Y') {\n                        factor1 = percent - 80 + 20.5;\n                    } else {\n                        factor1 = percent + 20 + 20.5;\n                    }\n                    blue1 = (104 - Math.sqrt(11236 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'R' && percent > 60 || bc === 'B' && percent <= 80) {\n                    if (bc === 'R') {\n                        factor1 = percent - 60 - 60;\n                    } else {\n                        factor1 = percent + 40 - 60;\n                    }\n                    blue1 = (Math.sqrt(10000 - Math.pow(factor1, 2)) - 10) / 100;\n                } else if (bc === 'B' && percent > 80 || bc === 'G' && percent <= 40) {\n                    if (bc === 'B') {\n                        factor1 = percent - 80 - 131;\n                    } else {\n                        factor1 = percent + 20 - 131;\n                    }\n                    blue1 = (122 - Math.sqrt(19881 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'G' && percent > 40) {\n                    blue1 = 0;\n                }\n                var green1 = void 0;\n                if (bc === 'Y') {\n                    green1 = (85 - 17 / 20 * percent) / 100;\n                } else if (bc === 'R' && percent <= 60) {\n                    green1 = 0;\n                } else if (bc === 'R' && percent > 60) {\n                    factor1 = percent - 60 + 35;\n                    green1 = (67.5 - Math.sqrt(5776 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'B' && percent <= 60) {\n                    factor1 = 1 * percent - 68.5;\n                    green1 = (6.5 + Math.sqrt(7044.5 - Math.pow(factor1, 2))) / 100;\n                } else if (bc === 'B' && percent > 60 || bc === 'G' && percent <= 60) {\n                    green1 = 0.9;\n                } else if (bc === 'G' && percent > 60) {\n                    factor1 = percent - 60;\n                    green1 = (90 - 1 / 8 * factor1) / 100;\n                }\n                factor1 = (red1 + green1 + blue1) / 3;\n                red2 = (factor1 - red1) * (100 - chroma1) / 100 + red1;\n                green2 = (factor1 - green1) * (100 - chroma1) / 100 + green1;\n                blue2 = (factor1 - blue1) * (100 - chroma1) / 100 + blue1;\n                if (red2 > green2 && red2 > blue2) {\n                    max = red2;\n                } else if (green2 > red2 && green2 > blue2) {\n                    max = green2;\n                } else if (blue2 > red2 && blue2 > green2) {\n                    max = blue2;\n                } else {\n                    max = (red2 + green2 + blue2) / 3;\n                }\n                factor2 = 1 / max;\n                r = parseInt(red2 * factor2 * (100 - black1) / 100 * 255, 10);\n                g = parseInt(green2 * factor2 * (100 - black1) / 100 * 255, 10);\n                b = parseInt(blue2 * factor2 * (100 - black1) / 100 * 255, 10);\n                if (r > 255) {\n                    r = 255;\n                }\n                if (g > 255) {\n                    g = 255;\n                }\n                if (b > 255) {\n                    b = 255;\n                }\n                if (r < 0) {\n                    r = 0;\n                }\n                if (g < 0) {\n                    g = 0;\n                }\n                if (b < 0) {\n                    b = 0;\n                }\n            } else {\n                grey = parseInt((1 - black / 100) * 255, 10);\n                if (grey > 255) {\n                    grey = 255;\n                }\n                if (grey < 0) {\n                    grey = 0;\n                }\n                r = grey;\n                g = grey;\n                b = grey;\n            }\n            return {\n                r: r,\n                g: g,\n                b: b\n            };\n        }\n    }, {\n        key: \"rgbToHsl\",\n        value: function rgbToHsl(r, g, b) {\n            var min,\n                max,\n                i,\n                l,\n                s,\n                maxcolor,\n                h,\n                rgb = [];\n            rgb[0] = r / 255;\n            rgb[1] = g / 255;\n            rgb[2] = b / 255;\n            min = rgb[0];\n            max = rgb[0];\n            maxcolor = 0;\n            for (i = 0; i < rgb.length - 1; i++) {\n                if (rgb[i + 1] <= min) {\n                    min = rgb[i + 1];\n                }\n                if (rgb[i + 1] >= max) {\n                    max = rgb[i + 1];\n                    maxcolor = i + 1;\n                }\n            }\n            if (maxcolor == 0) {\n                h = (rgb[1] - rgb[2]) / (max - min);\n            }\n            if (maxcolor == 1) {\n                h = 2 + (rgb[2] - rgb[0]) / (max - min);\n            }\n            if (maxcolor == 2) {\n                h = 4 + (rgb[0] - rgb[1]) / (max - min);\n            }\n            if (isNaN(h)) {\n                h = 0;\n            }\n            h = h * 60;\n            if (h < 0) {\n                h = h + 360;\n            }\n            l = (min + max) / 2;\n            if (min == max) {\n                s = 0;\n            } else {\n                if (l < 0.5) {\n                    s = (max - min) / (max + min);\n                } else {\n                    s = (max - min) / (2 - max - min);\n                }\n            }\n            s = s;\n            return { h: h, s: s, l: l };\n        }\n    }, {\n        key: \"rgbToHwb\",\n        value: function rgbToHwb(r, g, b) {\n            var h, w, bl;\n            r = r / 255;\n            g = g / 255;\n            b = b / 255;\n            var max = Math.max(r, g, b);\n            var min = Math.min(r, g, b);\n            var chroma = max - min;\n            if (chroma == 0) {\n                h = 0;\n            } else if (r == max) {\n                h = (g - b) / chroma % 6 * 360;\n            } else if (g == max) {\n                h = ((b - r) / chroma + 2) % 6 * 360;\n            } else {\n                h = ((r - g) / chroma + 4) % 6 * 360;\n            }\n            w = min;\n            bl = 1 - max;\n            return { h: h, w: w, b: bl };\n        }\n    }, {\n        key: \"rgbToCmyk\",\n        value: function rgbToCmyk(r, g, b) {\n            var c, m, y, k;\n            r = r / 255;\n            g = g / 255;\n            b = b / 255;\n            var max = Math.max(r, g, b);\n            k = 1 - max;\n            if (k == 1) {\n                c = 0;\n                m = 0;\n                y = 0;\n            } else {\n                c = (1 - r - k) / (1 - k);\n                m = (1 - g - k) / (1 - k);\n                y = (1 - b - k) / (1 - k);\n            }\n            return { c: c, m: m, y: y, k: k };\n        }\n    }, {\n        key: \"toHex\",\n        value: function toHex(n) {\n            var hex = n.toString(16);\n            while (hex.length < 2) {\n                hex = \"0\" + hex;\n            }\n            return hex;\n        }\n    }, {\n        key: \"cl\",\n        value: function cl(x) {\n            console.log(x);\n        }\n    }, {\n        key: \"w3trim\",\n        value: function w3trim(x) {\n            return x.replace(/^\\s+|\\s+$/g, '');\n        }\n    }, {\n        key: \"isHex\",\n        value: function isHex(x) {\n            return '0123456789ABCDEFabcdef'.indexOf(x) > -1;\n        }\n    }]);\n\n    return W3Color;\n}();\n\nexports.default = W3Color;\n\n//# sourceURL=webpack://tielifa/./build/utils/W3Color.js?");

/***/ }),

/***/ "./build/webgl/BaseBufferData.js":
/*!***************************************!*\
  !*** ./build/webgl/BaseBufferData.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar TYPE_FLOAT32 = 4;\nvar TYPE_FLOAT64 = 8;\nvar TYPE_UINT8 = 2;\nvar TYPE_UINT16 = 3;\nvar TYPE_UINT32 = 0;\nvar TYPE_INT8 = 5;\nvar TYPE_INT16 = 6;\nvar TYPE_INT32 = 7;\nvar TYPE_UINT8CLAMPED = 1;\n\nvar _littleEndian = undefined;\n\nvar BaseBufferData = function () {\n    function BaseBufferData(dataNum, singleDataByteLength) {\n        _classCallCheck(this, BaseBufferData);\n\n        this.singleDataByteLength = singleDataByteLength;\n        this.buffer = new ArrayBuffer(dataNum * singleDataByteLength);\n        this.dv = new DataView(this.buffer);\n        this.currentIndex = 0;\n        this.isLittleEndian = BaseBufferData.littleEndian();\n    }\n\n    _createClass(BaseBufferData, [{\n        key: 'init',\n        value: function init() {\n            this.currentIndex = 0;\n        }\n    }, {\n        key: 'getData',\n        value: function getData(index, type, offset) {\n            index = index * this.singleDataByteLength;\n            if (type == undefined) type = TYPE_FLOAT32;\n            if (offset == undefined) offset = 0;\n            index += offset;\n            var littleEndian = this.isLittleEndian;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    return this.dv.getFloat64(index, littleEndian);\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    return this.dv.getUint8(index);\n                    break;\n                case TYPE_INT8:\n                    return this.dv.getInt8(index);\n                    break;\n                case TYPE_UINT8:\n                    return this.dv.getUint8(index);\n                    break;\n                case TYPE_INT16:\n                    return this.dv.getInt16(index, littleEndian);\n                    break;\n                case TYPE_UINT16:\n                    return this.dv.getUint16(index, littleEndian);\n                    break;\n                case TYPE_FLOAT32:\n                    return this.dv.getFloat32(index, littleEndian);\n                    break;\n                case TYPE_INT32:\n                    return this.dv.getInt32(index, littleEndian);\n                    break;\n                case TYPE_UINT32:\n                    return this.dv.getUint32(index, littleEndian);\n                    break;\n            }\n        }\n    }, {\n        key: 'setData',\n        value: function setData(value, index, type, offset) {\n            var littleEndian = this.isLittleEndian;\n            if (offset == undefined) offset = 0;\n            if (type == undefined) type = TYPE_FLOAT32;\n            index = index * this.singleDataByteLength;\n            index += offset;\n            switch (type) {\n                case TYPE_FLOAT64:\n                    this.dv.setFloat64(index, value, littleEndian);\n                    break;\n                case TYPE_UINT8CLAMPED:\n                    this.dv.setUint8(index, value);\n                    break;\n                case TYPE_INT8:\n                    this.dv.setInt8(index, value);\n                    break;\n                case TYPE_UINT8:\n                    this.dv.setUint8(index, value);\n                    break;\n                case TYPE_INT16:\n                    this.dv.setInt16(index, value, littleEndian);\n                    break;\n                case TYPE_UINT16:\n                    this.dv.setUint16(index, value, littleEndian);\n                    break;\n                case TYPE_FLOAT32:\n                    this.dv.setFloat32(index, value, littleEndian);\n                    break;\n                case TYPE_INT32:\n                    this.dv.setInt32(index, value, littleEndian);\n                    break;\n                case TYPE_UINT32:\n                    this.dv.setUint32(index, value, littleEndian);\n                    break;\n            }\n        }\n    }, {\n        key: 'resize',\n        value: function resize(length) {\n            if (length < this.totalByteLength) throw Error('new length should not less than old length');\n            var oldBuffer = this.buffer;\n            this.buffer = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this.buffer);\n            ndv.set(dv1, 0);\n            this.dv = new DataView(this.buffer);\n        }\n    }, {\n        key: 'totalByteLength',\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }], [{\n        key: 'littleEndian',\n        value: function littleEndian() {\n            if (_littleEndian == undefined) {\n                var arrayBuffer = new ArrayBuffer(2);\n                var uint8Array = new Uint8Array(arrayBuffer);\n                var uint16array = new Uint16Array(arrayBuffer);\n                uint8Array[0] = 0xAA; // 第一位是AA\n                uint8Array[1] = 0xBB; // 第二位是BB\n                // 如果从16的view中读取数据，按照其排序就能得出高低位，以便DataView在设置值的时候能正确\n                if (uint16array[0] === 0xBBAA) _littleEndian = true;\n                if (uint16array[0] === 0xAABB) _littleEndian = false;\n                return _littleEndian;\n            } else {\n                return _littleEndian;\n            }\n        }\n    }, {\n        key: 'TYPE_FLOAT32',\n        get: function get() {\n            return TYPE_FLOAT32;\n        }\n    }, {\n        key: 'TYPE_FLOAT64',\n        get: function get() {\n            return TYPE_FLOAT64;\n        }\n    }, {\n        key: 'TYPE_UINT8',\n        get: function get() {\n            return TYPE_UINT8;\n        }\n    }, {\n        key: 'TYPE_UINT16',\n        get: function get() {\n            return TYPE_UINT16;\n        }\n    }, {\n        key: 'TYPE_UINT32',\n        get: function get() {\n            return TYPE_UINT32;\n        }\n    }, {\n        key: 'TYPE_INT8',\n        get: function get() {\n            return TYPE_INT8;\n        }\n    }, {\n        key: 'TYPE_INT16',\n        get: function get() {\n            return TYPE_INT16;\n        }\n    }, {\n        key: 'TYPE_INT32',\n        get: function get() {\n            return TYPE_INT32;\n        }\n    }, {\n        key: 'TYPE_UINT8CLAMPED',\n        get: function get() {\n            return TYPE_UINT8CLAMPED;\n        }\n    }]);\n\n    return BaseBufferData;\n}();\n\nexports.default = BaseBufferData;\n\n//# sourceURL=webpack://tielifa/./build/webgl/BaseBufferData.js?");

/***/ }),

/***/ "./build/webgl/CanvasDrawingStylesWebgl2D.js":
/*!***************************************************!*\
  !*** ./build/webgl/CanvasDrawingStylesWebgl2D.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _lineWidth = Symbol('线宽度,默认1');\nvar _lineCap = Symbol('线连接样式，\"butt\", \"round\", \"square\" (默认: \"butt\")');\nvar _lineJoin = Symbol('线连接样式，\"round\", \"bevel\", \"miter\" (默认: \"miter\")');\nvar _miterLimit = Symbol('默认10');\n\nvar _font = Symbol('文字字体大小等，默认\"10px sans-serif\"');\nvar _textAlign = Symbol('文字对齐,\"start\", \"end\", \"left\", \"right\", \"center\" (默认: \"start\")');\nvar _textBaseline = Symbol('文字纵向对齐，\"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\" (默认: \"alphabetic\")');\n\nvar CanvasDrawingStylesWebgl2D = function () {\n    function CanvasDrawingStylesWebgl2D() {\n        _classCallCheck(this, CanvasDrawingStylesWebgl2D);\n\n        this[_lineWidth] = 1;\n        this[_lineCap] = \"butt\";\n        this[_lineJoin] = \"miter\";\n        this[_miterLimit] = 10;\n        this.font = '10px sans-serif';\n        this.textAlign = 'start';\n        this.textBaseline = 'alphabetic';\n        this.fontFamily = 'Arial';\n        this.fontSize = 32;\n        this.fontWeight = null;\n        this.fontStyle = null;\n    }\n\n    _createClass(CanvasDrawingStylesWebgl2D, [{\n        key: 'clone',\n        value: function clone() {\n            var c = new CanvasDrawingStylesWebgl2D();\n            c.textBaseline = this.textBaseline;\n            c.textAlign = this.textAlign;\n            c.font = this.font;\n            c.lineCap = this.lineCap;\n            c.lineJoin = this.lineJoin;\n            c.lineWidth = this.lineWidth;\n            c.fontFamily = this.fontFamily;\n            c.fontSize = this.fontSize;\n            c.fontStyle = this.fontStyle;\n            c.fontWeight = this.fontWeight;\n            return c;\n        }\n    }, {\n        key: 'lineCap',\n        get: function get() {\n            return this[_lineCap];\n        },\n        set: function set(lineCap) {\n            this[_lineCap] = lineCap;\n        }\n\n        // line caps/joins\n\n    }, {\n        key: 'lineWidth',\n        get: function get() {\n            return this[_lineWidth];\n        },\n        set: function set(lineWidth) {\n            this[_lineWidth] = lineWidth;\n        }\n    }, {\n        key: 'lineJoin',\n        get: function get() {\n            return this[_lineJoin];\n        },\n        set: function set(lineJoin) {\n            this[_lineJoin] = lineJoin;\n        }\n    }, {\n        key: 'miterLimit',\n        get: function get() {\n            return this[_miterLimit];\n        },\n        set: function set(miterLimit) {\n            this[_miterLimit] = miterLimit;\n        }\n\n        // 没有实现的：\n        // dashed lines\n        // void setLineDash(sequence<unrestricted double> segments); // (default: empty)\n        // sequence<unrestricted double> getLineDash();\n        // attribute unrestricted double lineDashOffset;\n\n\n        // text\n\n    }, {\n        key: 'font',\n        get: function get() {\n            return this[_font];\n        },\n        set: function set(font) {\n            this[_font] = font;\n        }\n    }, {\n        key: 'textAlign',\n        get: function get() {\n            return this[_textAlign];\n        },\n        set: function set(textAlign) {\n            this[_textAlign] = textAlign;\n        }\n    }, {\n        key: 'textBaseline',\n        get: function get() {\n            return this[_textBaseline];\n        },\n        set: function set(textBaseline) {\n            this[_textBaseline] = textBaseline;\n        }\n    }]);\n\n    return CanvasDrawingStylesWebgl2D;\n}();\n\nexports.default = CanvasDrawingStylesWebgl2D;\n\n//# sourceURL=webpack://tielifa/./build/webgl/CanvasDrawingStylesWebgl2D.js?");

/***/ }),

/***/ "./build/webgl/CanvasRenderingContextWebgl2D.js":
/*!******************************************************!*\
  !*** ./build/webgl/CanvasRenderingContextWebgl2D.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _ContextState = __webpack_require__(/*! ./ContextState.js */ \"./build/webgl/ContextState.js\");\n\nvar _ContextState2 = _interopRequireDefault(_ContextState);\n\nvar _CanvasDrawingStylesWebgl2D = __webpack_require__(/*! ./CanvasDrawingStylesWebgl2D.js */ \"./build/webgl/CanvasDrawingStylesWebgl2D.js\");\n\nvar _CanvasDrawingStylesWebgl2D2 = _interopRequireDefault(_CanvasDrawingStylesWebgl2D);\n\nvar _Path3D = __webpack_require__(/*! ./Path3D.js */ \"./build/webgl/Path3D.js\");\n\nvar _Path3D2 = _interopRequireDefault(_Path3D);\n\nvar _SubPath3D = __webpack_require__(/*! ./SubPath3D.js */ \"./build/webgl/SubPath3D.js\");\n\nvar _SubPath3D2 = _interopRequireDefault(_SubPath3D);\n\nvar _Color = __webpack_require__(/*! ../utils/Color.js */ \"./build/utils/Color.js\");\n\nvar _Color2 = _interopRequireDefault(_Color);\n\nvar _RenderAction = __webpack_require__(/*! ./RenderAction.js */ \"./build/webgl/RenderAction.js\");\n\nvar _RenderAction2 = _interopRequireDefault(_RenderAction);\n\nvar _WebGLRender = __webpack_require__(/*! ./WebGLRender.js */ \"./build/webgl/WebGLRender.js\");\n\nvar _WebGLRender2 = _interopRequireDefault(_WebGLRender);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./build/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Vector = __webpack_require__(/*! ../math/Vector3.js */ \"./build/math/Vector3.js\");\n\nvar _Vector2 = _interopRequireDefault(_Vector);\n\nvar _GeometryTools = __webpack_require__(/*! ../geometry/GeometryTools.js */ \"./build/geometry/GeometryTools.js\");\n\nvar _GeometryTools2 = _interopRequireDefault(_GeometryTools);\n\nvar _Vector3 = __webpack_require__(/*! ../math/Vector2.js */ \"./build/math/Vector2.js\");\n\nvar _Vector4 = _interopRequireDefault(_Vector3);\n\nvar _BMFontManager = __webpack_require__(/*! ../font/BMFontManager.js */ \"./build/font/BMFontManager.js\");\n\nvar _BMFontManager2 = _interopRequireDefault(_BMFontManager);\n\nvar _LineToRectangle = __webpack_require__(/*! ../geometry/LineToRectangle.js */ \"./build/geometry/LineToRectangle.js\");\n\nvar _LineToRectangle2 = _interopRequireDefault(_LineToRectangle);\n\nvar _Texture = __webpack_require__(/*! ../texture/Texture.js */ \"./build/texture/Texture.js\");\n\nvar _Texture2 = _interopRequireDefault(_Texture);\n\nvar _Mat3 = __webpack_require__(/*! ../math/Mat3.js */ \"./build/math/Mat3.js\");\n\nvar _Mat4 = _interopRequireDefault(_Mat3);\n\nvar _VDO = __webpack_require__(/*! ./VDO.js */ \"./build/webgl/VDO.js\");\n\nvar _VDO2 = _interopRequireDefault(_VDO);\n\nvar _TempCanvas = __webpack_require__(/*! ../texture/TempCanvas.js */ \"./build/texture/TempCanvas.js\");\n\nvar _TempCanvas2 = _interopRequireDefault(_TempCanvas);\n\nvar _TextTools = __webpack_require__(/*! ../text/TextTools.js */ \"./build/text/TextTools.js\");\n\nvar _TextTools2 = _interopRequireDefault(_TextTools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _canvas = Symbol('对应的Canvas');\nvar _stateStack = Symbol('状态栈');\nvar _pathList = Symbol('路径列表');\nvar _renderActionList = Symbol('绘制动作List');\nvar _subpathCatch = Symbol('子Path缓存');\n\nvar TEMP_TRANFORM_MAT3 = _Mat4.default.identity();\n\nvar SPACE_CHAR_ID = \" \".charCodeAt(0);\nvar FACE_NORMAL4 = new Float32Array(4);\nvar ORI_NORMAL4 = new Float32Array(4);\nvar WHITE_COLOR = [255, 255, 255];\n// let TEMP_VERTEX_COORD4DIM_ARRAY = [[0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1], [0, 0, 0, 1]];\nvar TEMP_VERTEX_COORD4DIM_ARRAY = [new Float32Array(4), new Float32Array(4), new Float32Array(4), new Float32Array(4)];\n\nvar CanvasRenderingContextWebgl2D = function () {\n    function CanvasRenderingContextWebgl2D(canvas, properties) {\n        _classCallCheck(this, CanvasRenderingContextWebgl2D);\n\n        properties = properties || [];\n        for (var i = 0; i < TEMP_VERTEX_COORD4DIM_ARRAY.length; i++) {\n            // w要设为1\n            TEMP_VERTEX_COORD4DIM_ARRAY[i][3] = 1;\n        }\n        FACE_NORMAL4[2] = 1;\n        FACE_NORMAL4[3] = 1;\n        ORI_NORMAL4[3] = 1;\n        this[_canvas] = canvas;\n        if (canvas == null) throw new Error('canvas can not be undefined or null');\n        this.gl = canvas.getContext('webgl');\n        if (this.gl == null) throw new Error('Current canvas doesnt support WebGL');\n        this.maxBufferByteLength = properties['maxMemorySize'] || 1024 * 1024;\n        this[_stateStack] = [];\n        this[_pathList] = [];\n        this[_renderActionList] = [];\n        this[_subpathCatch] = [];\n        this._tempCanvas = new _TempCanvas2.default();\n        properties.tempCanvas = this._tempCanvas;\n        this.webglRender = new _WebGLRender2.default(this.gl, properties);\n        var maxVertexNumber = this.maxBufferByteLength / 32;\n        this._mixOpacity = properties['mixOpacity']; // 这个属性是规定是否要让vdo对象将透明和不透明分开\n        if (this._mixOpacity == null) this._mixOpacity = false;\n\n        this.vdo = new _VDO2.default(maxVertexNumber, maxVertexNumber, this._mixOpacity);\n\n        this.webglRender.vdo = this.vdo;\n        this.currentFaceNormal = new Float32Array(4);\n        this.originalFaceNormal = new Float32Array(3);\n        this.originalFaceNormal[2] = 1;\n        this.currentFaceNormal[2] = 1;\n        this._tempPathArray = null;\n        this._tempActionList = null;\n        this._tempGraphics = null;\n        this._painedGraphicsMap = {};\n        this.fontManager = new _BMFontManager2.default();\n\n        this._tempVDO = null;\n    }\n\n    _createClass(CanvasRenderingContextWebgl2D, [{\n        key: \"clean\",\n\n\n        /**\r\n         * clean all the path content and clear webgl depth buffer/color buffer\r\n         */\n        value: function clean(clearAllTexture) {\n            this[_pathList].length = 0;\n            this.webglRender.clean(clearAllTexture);\n        }\n\n        /**\r\n         * didn't implement , just clear whole canvas\r\n         * 没有实现,只能全部清空\r\n         * @param left\r\n         * @param top\r\n         * @param width\r\n         * @param height\r\n         */\n\n    }, {\n        key: \"clearRect\",\n        value: function clearRect(left, top, width, height) {\n            this.clean();\n        }\n\n        /************** CanvasPathMethods ************************/\n\n    }, {\n        key: \"beginPath\",\n        value: function beginPath() {\n            this.currentPath.clean();\n        }\n    }, {\n        key: \"closePath\",\n        value: function closePath() {\n            var path = this.currentPath;\n            if (path.subPathNumber == 0) return;\n            var lastSubPath = path.lastSubPath;\n            lastSubPath.close();\n            var x = lastSubPath.getPointX(0);\n            var y = lastSubPath.getPointX(0);\n            var z = lastSubPath.getPointX(0);\n            var sid = lastSubPath.getPointStateId(0);\n            // let mid = lastSubPath.getPointMatrixId(0);\n            var newSubPath = new _SubPath3D2.default();\n            newSubPath.addPoint(x, y, z, sid);\n            path.addSubPath(newSubPath);\n        }\n    }, {\n        key: \"lineTo\",\n        value: function lineTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentSubPath = this.currentPath;\n            var lastSubPath = currentSubPath.lastSubPath;\n            if (lastSubPath == undefined) {\n                var subPath = new _SubPath3D2.default();\n                currentSubPath.addSubPath(subPath);\n                this.addPointInLastSubPath(x, y, z, true);\n                return;\n            }\n            this.addPointInLastSubPath(x, y, z, true);\n        }\n    }, {\n        key: \"addPointInPath\",\n        value: function addPointInPath(x, y, z, path, applyTransform) {\n            var currentState = this.currentContextState;\n            var m = currentState.transformMatrix;\n            if (applyTransform && !_Mat2.default.isIdentity(m)) {\n                var tempVector = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n                tempVector[0] = x;\n                tempVector[1] = y;\n                tempVector[2] = z;\n                tempVector[3] = 1;\n                _Mat2.default.multiplyWithVertex(m, tempVector, tempVector);\n                x = tempVector[0];\n                y = tempVector[1];\n                z = tempVector[2];\n                // currentState.fireDirty();\n            }\n            path.addPoint(x, y, z, currentState.id);\n        }\n    }, {\n        key: \"addPointInLastSubPath\",\n        value: function addPointInLastSubPath(x, y, z, applyTransform) {\n            this.addPointInPath(x, y, z, this.currentPath.lastSubPath, applyTransform);\n        }\n    }, {\n        key: \"moveTo\",\n        value: function moveTo(x, y, z) {\n            if (z == undefined) z = 0;\n            var currentState = this.currentContextState;\n            var currentSubPath = this.currentPath;\n            var lastSubPath = currentSubPath.lastSubPath;\n            if (lastSubPath != undefined && lastSubPath.pointsNumber < 2) {\n                //这个subpath只要一个点，就用它作为新的subpath\n                var m = currentState.transformMatrix;\n                var tempVector = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n                tempVector[0] = x;\n                tempVector[1] = y;\n                tempVector[2] = z;\n                tempVector[3] = 1;\n                var temp = _Mat2.default.multiplyWithVertex(m, tempVector, tempVector);\n                if (lastSubPath.pointsNumber != 0) {\n                    lastSubPath.setPoint(0, temp[0], temp[1], temp[2], currentState.id);\n                } else {\n                    lastSubPath.addPoint(temp[0], temp[1], temp[2], currentState.id);\n                }\n            } else {\n                var subPath = new _SubPath3D2.default();\n                currentSubPath.addSubPath(subPath);\n                this.addPointInLastSubPath(x, y, z, true);\n            }\n        }\n    }, {\n        key: \"rect\",\n        value: function rect(x, y, w, h, depth) {\n            if (depth == undefined) depth = 0;\n            this.moveTo(x, y, depth);\n            this.lineTo(x + w, y, depth);\n            this.lineTo(x + w, y + h, depth);\n            this.lineTo(x, y + h, depth);\n            this.closePath();\n        }\n\n        /**\r\n         * 绘制cubic贝塞尔曲线，4个控制点\r\n         * @param cp1x\r\n         * @param cp1y\r\n         * @param cp2x\r\n         * @param cp2y\r\n         * @param x\r\n         * @param y\r\n         */\n\n    }, {\n        key: \"bezierCurveTo\",\n        value: function bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n            var oldx = cp1x;\n            var oldy = cp1y;\n            var currentPath = this.currentPath;\n            var currentState = this.currentContextState;\n            var lastSubPath = currentPath.lastSubPath;\n            var tempVector = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n            var defaultZ = 0;\n\n            tempVector[0] = cp1x;\n            tempVector[1] = cp1y;\n            tempVector[2] = 0;\n            tempVector[3] = 1;\n            var m1 = this.currentContextState.transformMatrix;\n            _Mat2.default.multiplyWithVertex(m1, tempVector, tempVector);\n            cp1x = tempVector[0];\n            cp1y = tempVector[1];\n            defaultZ = tempVector[2];\n\n            tempVector[0] = cp2x;\n            tempVector[1] = cp2y;\n            tempVector[2] = 0;\n            tempVector[3] = 1;\n            _Mat2.default.multiplyWithVertex(m1, tempVector, tempVector);\n            cp2x = tempVector[0];\n            cp2y = tempVector[1];\n\n            tempVector[0] = x;\n            tempVector[1] = y;\n            tempVector[2] = 0;\n            tempVector[3] = 1;\n            _Mat2.default.multiplyWithVertex(m1, tempVector, tempVector);\n            x = tempVector[0];\n            y = tempVector[1];\n\n            var cp0x = cp1x;\n            var cp0y = cp1y;\n\n            if (lastSubPath == undefined) {\n                this.moveTo(oldx, oldy);\n            } else {\n                var lastIndex = lastSubPath.pointsNumber - 1;\n                var x0 = lastSubPath.getPointX(lastIndex);\n                var y0 = lastSubPath.getPointY(lastIndex);\n                if (x0 != cp1x && y0 != cp1y) {\n                    cp0x = x0;\n                    cp0y = y0;\n                }\n            }\n            // 一阶导数：3(1-t)^2(p1-p0) + 6t(1-t)(p2-p1)+3t^2(p3-p2)\n            var minLength = 1;\n            var delta = 9 * (cp1x - cp0x) * (cp1x - cp0x) + 9 * (cp1y - cp0y) * (cp1y - cp0y);\n            delta = Math.sqrt(minLength / delta);\n            if (delta === Infinity) delta = 0.01;\n            var temp = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n            var segment = delta;\n            for (; segment <= 1; segment += delta) {\n                _GeometryTools2.default.cubicBezier(segment, cp0x, cp0y, cp1x, cp1y, cp2x, cp2y, x, y, temp);\n                this.addPointInLastSubPath(temp[0], temp[1], defaultZ, false);\n                var c = 1 - segment;\n                var p1 = 3 * c * c;\n                var p2 = 6 * segment * c;\n                var p3 = 3 * segment * segment;\n                var a = p1 * (cp1x - cp0x) + p2 * (cp2x - cp1x) + p3 * (x - cp2x);\n                var b = p1 * (cp1y - cp0y) + p2 * (cp2y - cp1y) + p3 * (y - cp2y);\n                delta = minLength / (a * a + b * b);\n                delta = Math.sqrt(delta);\n            }\n            this.addPointInLastSubPath(x, y, defaultZ, false);\n            // currentState.fireDirty();\n        }\n\n        /**\r\n         * 绘制Quadratice贝塞尔，3个控制点\r\n         * @param cpx\r\n         * @param cpy\r\n         * @param x\r\n         * @param y\r\n         */\n\n    }, {\n        key: \"quadraticCurveTo\",\n        value: function quadraticCurveTo(cpx, cpy, x, y) {\n            var currentPath = this.currentPath;\n            var currentState = this.currentContextState;\n            var lastSubPath = currentPath.lastSubPath;\n            var m = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n            m[0] = cpx;\n            m[1] = cpy;\n            m[2] = 0;\n            m[3] = 1;\n            var m1 = this.currentContextState.transformMatrix;\n            _Mat2.default.multiplyWithVertex(m1, m, m);\n            cpx = m[0];\n            cpy = m[1];\n            var cpz = m[2];\n            m[0] = x;\n            m[1] = y;\n            m[2] = 0;\n            m[3] = 1;\n            _Mat2.default.multiplyWithVertex(m1, m, m);\n            x = m[0];\n            y = m[1];\n            var z = m[2];\n\n            var cp0x = cpx;\n            var cp0y = cpy;\n\n            if (lastSubPath == undefined) {\n                var subPath = new _SubPath3D2.default();\n                currentPath.addSubPath(subPath);\n                this.addPointInLastSubPath(cpx, cpy, cpz, false);\n            } else {\n                var lastIndex = lastSubPath.pointsNumber - 1;\n                var x0 = lastSubPath.getPointX(lastIndex);\n                var y0 = lastSubPath.getPointY(lastIndex);\n                if (x0 != cpx && y0 != cpy) {\n                    cp0x = x0;\n                    cp0y = y0;\n                }\n            }\n            if (cp0x == cpx && cp0y == cpy) {\n                this.addPointInLastSubPath(x, y, z, false);\n                return;\n            }\n            // 一阶导数：2(1-t)(p1-p0) + 2t(p2-p1)\n            var minLength = 1;\n            var delta = minLength / (4 * (cpx - cp0x) * (cpx - cp0x) + 4 * (cpy - cp0y) * (cpy - cp0y));\n            delta = Math.sqrt(delta);\n            if (delta === Infinity) delta = 0.01;\n            var temp = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n            var segment = delta;\n            for (; segment <= 1; segment += delta) {\n                _GeometryTools2.default.quadraticBezier(segment, cp0x, cp0y, cpx, cpy, x, y, temp);\n                this.addPointInLastSubPath(temp[0], temp[1], cpz, false);\n                var p1 = 2 * (1 - segment);\n                var p2 = 2 * segment;\n                var a = p1 * (cpx - cp0x) + p2 * (x - cpx);\n                var b = p1 * (cpy - cp0y) + p2 * (y - cpy);\n                delta = minLength / (a * a + b * b);\n                delta = Math.sqrt(delta);\n            }\n            this.addPointInLastSubPath(x, y, z, false);\n            // currentState.fireDirty();\n        }\n\n        // 没有实现这个椭圆的：arcTo(x1: number, y1: number, x2: number, y2: number, radiusX: number, radiusY: number, rotation: number): void;\n        /**\r\n         * FIXME 这个方法有个bug，path中的最后一个点所应用的转换矩阵不一定就是当前矩阵\r\n         * @param x1\r\n         * @param y1\r\n         * @param x2\r\n         * @param y2\r\n         * @param radius\r\n         */\n\n    }, {\n        key: \"arcTo\",\n        value: function arcTo(x1, y1, x2, y2, radius) {\n            if (radius < 0) throw new Error('IndexError: Radius value wrong');\n            var subpath = this.currentPath.lastSubPath;\n            var startx = 0;\n            var starty = 0;\n            if (subpath == undefined) {\n                subpath = new _SubPath3D2.default();\n                this.currentPath.addSubPath(subpath);\n                this.moveTo(x1, y1);\n                return;\n            } else {\n                var sx = subpath.getPointX(subpath.pointsNumber - 1);\n                var sy = subpath.getPointY(subpath.pointsNumber - 1);\n                var sz = subpath.getPointZ(subpath.pointsNumber - 1);\n                var testVertex = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n                testVertex[0] = sx;\n                testVertex[1] = sy;\n                testVertex[2] = sz;\n                testVertex[3] = 1;\n                var tm = this.currentContextState.transformMatrix;\n                var tempM = _Mat2.default.TEMP_MAT4[0];\n                _Mat2.default.copy(tm, tempM);\n                _Mat2.default.inverse(tempM, tempM);\n                _Mat2.default.multiplyWithVertex(tempM, testVertex, testVertex);\n                if (_Tools2.default.equals(sx, x1) && _Tools2.default.equals(sy, y1) || _Tools2.default.equals(x1, x2) && _Tools2.default.equals(y1, y2) || radius == 0) {\n                    this.lineTo(x1, y1);\n                    return;\n                }\n                startx = testVertex[0];\n                starty = testVertex[1];\n            }\n\n            var vector1 = new _Vector4.default(startx - x1, starty - y1);\n            var vector2 = new _Vector4.default(x2 - x1, y2 - y1);\n\n            _Vector4.default.normalize(vector1, vector1);\n            _Vector4.default.normalize(vector2, vector2);\n\n            var vector3 = new _Vector4.default();\n            _Vector4.default.plus(vector3, vector1, vector2);\n            _Vector4.default.normalize(vector3, vector3);\n            var radian1 = Math.acos(_Vector4.default.dot(vector1, vector3));\n            if (_Tools2.default.equals(radian1 * 2 % Math.PI, 0)) {\n                this.lineTo(x1, y1);\n                return;\n            }\n            var sin = Math.sin(radian1);\n            var length2 = radius / sin;\n\n            var rx = vector3.x * length2 + x1;\n            var ry = vector3.y * length2 + y1;\n\n            var center = { x: rx, y: ry };\n            var linep1 = { x: x1, y: y1 };\n            var linep2 = { x: startx, y: starty };\n            var linep3 = { x: x2, y: y2 };\n            var tangenp1 = _GeometryTools2.default.getProjectionPointOnLine(center, linep1, linep2);\n            var tangenp2 = _GeometryTools2.default.getProjectionPointOnLine(center, linep1, linep3);\n            var tv1 = new _Vector4.default(tangenp1.x - rx, tangenp1.y - ry);\n            var tv2 = new _Vector4.default(tangenp2.x - rx, tangenp2.y - ry);\n            _Vector4.default.normalize(tv1, tv1);\n            _Vector4.default.normalize(tv2, tv2);\n\n            function adjustAngle(angle) {\n                var PI2 = 2 * Math.PI;\n                var beishu = Math.floor(Math.abs(angle / PI2));\n                // if (Math.abs(angle) > PI2) beishu++;\n                if (angle < 0) {\n                    angle += beishu * PI2;\n                }\n                if (angle >= PI2) {\n                    angle -= beishu * PI2;\n                }\n                return angle;\n            }\n\n            var startTheta = Math.atan2(tv1.y, tv1.x);\n            var testst = startTheta;\n            testst = adjustAngle(testst);\n            var endTheta = Math.atan2(tv2.y, tv2.x);\n            var testet = endTheta;\n            testet = adjustAngle(testet);\n            var flag = false;\n            if (Math.abs(testst - testet) > Math.PI) {\n                flag = true;\n            }\n            this.arc(rx, ry, radius, startTheta, endTheta, flag);\n        }\n    }, {\n        key: \"getEllipseCalculateTempMatrix\",\n        value: function getEllipseCalculateTempMatrix(x, y, z, radiusX, radiusY, rotation, tm) {\n            var currentMatrix = _Mat2.default.identity();\n            _Mat2.default.translationMatrix(currentMatrix, x, y, z);\n            _Mat2.default.multiply(currentMatrix, tm, currentMatrix);\n            var transformMatrix = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationZMatrix(transformMatrix, rotation);\n            _Mat2.default.multiply(currentMatrix, currentMatrix, transformMatrix);\n            /*\r\n            * 设一个矩阵：\r\n            * [ radiusX,0,0,0\r\n            *  0, radiusY,0,0\r\n            *  0,0,1,0\r\n            *  0,0,0,1]\r\n            */\n            _Mat2.default.identityMatrix(transformMatrix);\n            transformMatrix[0] = radiusX;\n            transformMatrix[5] = radiusY;\n            _Mat2.default.multiply(currentMatrix, currentMatrix, transformMatrix);\n            return currentMatrix;\n        }\n    }, {\n        key: \"ellipse\",\n        value: function ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {\n            if (radiusX < 0 || radiusY < 0) throw new Error('IndexError.半径必须不小于0. Radius should not be smaller than zero. BanJing BiXu BuXiaoYu Ling');\n            if (radiusX == 0 || radiusY == 0) return;\n            if (anticlockwise == null) anticlockwise = false;\n\n            var subpath = this.currentPath.lastSubPath;\n            if (subpath == null) {\n                subpath = new _SubPath3D2.default();\n                this.currentPath.addSubPath(subpath);\n            }\n            var tm = this.currentContextState.transformMatrix;\n            var currentMatrix = this.getEllipseCalculateTempMatrix(x, y, 0, radiusX, radiusY, rotation, tm); //Mat4.TEMP_MAT4[0];\n\n            var realRadius1 = Math.max(radiusX * this.currentContextState.scaleValue.x, radiusY * this.currentContextState.scaleValue.y); // 这个值要根据当前缩放算一下\n            var deltaTheta = Math.asin(1 / realRadius1) * 2;\n\n            var thetaVector = new _Vector2.default();\n\n            startAngle = this.adjustEllipseAngle(startAngle, anticlockwise);\n            endAngle = this.adjustEllipseAngle(endAngle, anticlockwise);\n\n            if (startAngle > endAngle && !anticlockwise || startAngle < endAngle && anticlockwise) {\n                if (startAngle < 0 || endAngle < 0) {\n                    endAngle -= 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle -= 2 * Math.PI;\n                }\n                if (startAngle > 0 || endAngle > 0) {\n                    endAngle += 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle += 2 * Math.PI;\n                }\n            }\n            /**\r\n             * 把椭圆点的计算抽取出来，形成了几个矩阵，然后先让这些矩阵和当前变换矩阵相乘\r\n             * 再通过已经应用了变换后的矩阵计算坐标点，这样省去了用lineTo一个一个点和矩阵相乘\r\n             */\n            if (anticlockwise) {\n                for (var theta = startAngle; theta > endAngle; theta -= deltaTheta) {\n                    if (Math.abs(theta - startAngle) >= _Tools2.default.PI2) {\n                        return;\n                    }\n                    var _s = Math.sin(theta);\n                    var _c = Math.cos(theta);\n                    thetaVector.x = _c;\n                    thetaVector.y = _s;\n                    thetaVector.z = 0;\n                    _Mat2.default.multiplyWithVertex(currentMatrix, thetaVector.value, thetaVector.value);\n                    this.addPointInLastSubPath(thetaVector.x, thetaVector.y, thetaVector.z, false);\n                }\n            } else {\n                for (var _theta = startAngle; _theta < endAngle; _theta += deltaTheta) {\n                    if (Math.abs(_theta - startAngle) >= _Tools2.default.PI2) {\n                        return;\n                    }\n\n                    var _s2 = Math.sin(_theta);\n                    var _c2 = Math.cos(_theta);\n                    thetaVector.x = _c2;\n                    thetaVector.y = _s2;\n                    thetaVector.z = 0;\n                    _Mat2.default.multiplyWithVertex(currentMatrix, thetaVector.value, thetaVector.value);\n                    this.addPointInLastSubPath(thetaVector.x, thetaVector.y, thetaVector.z, false);\n                    // 老的计算方法是先计算坐标后再进行变换：(lineTo会自动将点进行变换)\n                    // GeometryTools.getEllipsePointWithRadian(x, y, radiusX, radiusY, theta, rotation, nextPoint);\n                    // this.lineTo(nextPoint[0], nextPoint[1]);\n                }\n            }\n\n            var s = Math.sin(endAngle);\n            var c = Math.cos(endAngle);\n            thetaVector.x = c;\n            thetaVector.y = s;\n            thetaVector.z = 0;\n            _Mat2.default.multiplyWithVertex(currentMatrix, thetaVector.value, thetaVector.value);\n            this.addPointInLastSubPath(thetaVector.x, thetaVector.y, thetaVector.z, false);\n        }\n    }, {\n        key: \"adjustEllipseAngle\",\n        value: function adjustEllipseAngle(angle, anticlockwise) {\n            var PI2 = _Tools2.default.PI2; //2 * Math.PI;\n            var beishu = Math.floor(Math.abs(angle / PI2)) + 1;\n            // if (Math.abs(angle) > PI2) beishu++;\n            if (angle < 0 && !anticlockwise) {\n                angle += beishu * PI2;\n            }\n            if (angle > 0 && anticlockwise) {\n                angle -= beishu * PI2;\n            }\n            return angle;\n        }\n    }, {\n        key: \"arc\",\n        value: function arc(x, y, radius, startAngle, endAngle, anticlockwise) {\n            this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);\n        }\n\n        /*************************** sate **************************/\n\n        /**\r\n         * push state on state stack\r\n         * 将当前状态放入状态栈中\r\n         */\n\n    }, {\n        key: \"save\",\n        value: function save() {\n            // 取出最后一个状态，克隆一个新状态，然后把新状态加入到栈内\n            var currentState = this.currentContextState;\n            var stateClone = currentState.clone();\n            this[_stateStack].push(stateClone);\n        }\n\n        /**\r\n         * pop state stack and restore state\r\n         * 将当前状态弹出栈，即恢复之前的状态\r\n         */\n\n    }, {\n        key: \"restore\",\n        value: function restore() {\n            // 弹出栈底状态\n            if (this[_stateStack].length != 0) {\n                this[_stateStack].pop();\n            }\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            this.currentContextState.translate(x, y, z);\n        }\n\n        /**\r\n         * 默认2D是按照Z轴旋转\r\n         * @param radian\r\n         */\n\n    }, {\n        key: \"rotate\",\n        value: function rotate(radian) {\n            this.currentContextState.rotateZ(radian);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            this.currentContextState.rotateX(radian);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            this.currentContextState.rotateY(radian);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            this.currentContextState.scale(scaleX, scaleY, scaleZ);\n        }\n\n        /**\r\n         *\r\n         * @param scaleX :number\r\n         * @param skewY:number\r\n         * @param skewX:number\r\n         * @param scaleY:number\r\n         * @param tx:number\r\n         * @param ty:number\r\n         */\n\n    }, {\n        key: \"setTransform\",\n        value: function setTransform(scaleX, skewY, skewX, scaleY, tx, ty) {\n            _Mat2.default.identityMatrix(this.currentContextState.transformMatrix);\n            var m = this.currentContextState.transformMatrix;\n            m[0] = scaleX;\n            m[1] = skewY;\n            m[4] = skewX;\n            m[5] = scaleY;\n            m[12] = tx;\n            m[13] = ty;\n            m[14] = 0;\n        }\n\n        /**\r\n         * 给出一个转换矩阵数据，可以执行：拉伸，倾斜，移动\r\n         * @param scaleX 横向拉伸 :number\r\n         * @param skewY 纵向倾斜 :number\r\n         * @param skewX 横向倾斜:number\r\n         * @param scaleY 纵向拉伸:number\r\n         * @param tx 横向移动:number\r\n         * @param ty 纵向移动:number\r\n         */\n\n    }, {\n        key: \"transform\",\n        value: function transform(scaleX, skewY, skewX, scaleY, tx, ty) {\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.identityMatrix(m);\n            /* 矩阵是这样的：\r\n              [ a,c,e\r\n                b,d,f,\r\n                0,0,1 ]\r\n                对应我自己的4x4矩阵是：\r\n                a,b,0,0\r\n                c,d,0,0\r\n                0,0,1,0\r\n                e,f,0,1\r\n             */\n            m[0] = scaleX;\n            m[1] = skewY;\n            m[4] = skewX;\n            m[5] = scaleY;\n            m[12] = tx;\n            m[13] = ty;\n            this.currentContextState.applyTransform(m);\n        }\n    }, {\n        key: \"applyTransformMatrix\",\n        value: function applyTransformMatrix(matrix) {\n            this.currentContextState.applyTransform(matrix);\n        }\n\n        /*********************** 绘制 */ //////////////\n\n\n    }, {\n        key: \"drawDynamicImage\",\n        value: function drawDynamicImage(image, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, depth, color) {\n            depth = depth || 0;\n            var texture = void 0;\n            if (image instanceof _Texture2.default) {\n                texture = image;\n            } else {\n                texture = this.webglRender.textureManager.getTexture(image, null, true);\n            }\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.textureIndex = texture.index;\n            var left = void 0,\n                top = void 0,\n                right = void 0,\n                bottom = void 0; // 图形对应矩形的四个点\n            var tx = void 0,\n                ty = void 0,\n                tr = void 0,\n                tb = void 0; // 贴图对应的四个点\n            // 只有x,y传入的调用\n            if (arguments.length === 3) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            if (arguments.length === 4) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = srcWidth;\n            }\n            // 有x,y,width,height传入的调用\n            if (arguments.length === 5) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n            }\n            if (arguments.length === 6) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = dstX;\n            }\n            // 有9或10个参数传入的调用，即要调整贴图坐标\n            if (arguments.length === 9 || arguments.length === 10 || arguments.length === 11) {\n                left = dstX;\n                top = dstY;\n                right = dstX + dstWidth;\n                bottom = dstY + dstHeight;\n                tx = texture.x + srcX;\n                tr = texture.x + srcX + srcWidth;\n                ty = texture.y + srcY;\n                tb = texture.y + srcY + srcHeight;\n            }\n\n            this.beginPath();\n            this.rect(left, top, right - left, bottom - top, depth);\n            this.currentPath.subPathArray[this.currentPath.subPathNumber - 2].isRegularRect = true;\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            this[_renderActionList].push(action);\n            var texCoordArray = new Array(4);\n            texCoordArray[0] = [tx, ty]; // 左上角\n            texCoordArray[1] = [tr, ty]; // 右上角\n            texCoordArray[2] = [tr, tb]; // 右下角\n            texCoordArray[3] = [tx, tb]; // 左下角\n            color = color || WHITE_COLOR; //白色，在glsl里会成为一个1,1,1的向量，这样就不会改变贴图数据了\n            action.vdo = this.vdo;\n            action.collectVertexDataForFill(pathList, color, opacity, texCoordArray, this.currentContextState.filterType, this.currentFaceVector, texture.opacity);\n        }\n    }, {\n        key: \"drawImage\",\n        value: function drawImage(image, srcX, srcY, srcWidth, srcHeight, dstX, dstY, dstWidth, dstHeight, depth, color) {\n\n            var texture = void 0;\n            if (image instanceof _Texture2.default) {\n                texture = image;\n            } else {\n                texture = this.webglRender.textureManager.getTexture(image);\n            }\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.textureIndex = texture.index;\n            var left = void 0,\n                top = void 0,\n                right = void 0,\n                bottom = void 0; // 图形对应矩形的四个点\n            var tx = void 0,\n                ty = void 0,\n                tr = void 0,\n                tb = void 0; // 贴图对应的四个点\n            // 只有x,y传入的调用\n            if (arguments.length === 3 || arguments.length === 4) {\n                left = srcX;\n                top = srcY;\n                right = srcX + image.width;\n                bottom = srcY + image.height;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = srcWidth;\n            }\n            // 有x,y,width,height传入的调用\n            if (arguments.length === 5 || arguments.length === 6) {\n                left = srcX;\n                top = srcY;\n                right = srcX + srcWidth;\n                bottom = srcY + srcHeight;\n                tx = texture.x;\n                tr = texture.x + texture.width;\n                ty = texture.y;\n                tb = texture.y + texture.height;\n                depth = dstX;\n            }\n            // 有9或10个参数传入的调用，即要调整贴图坐标\n            if (arguments.length >= 9) {\n                left = dstX;\n                top = dstY;\n                right = dstX + dstWidth;\n                bottom = dstY + dstHeight;\n                tx = texture.x + srcX;\n                tr = texture.x + srcX + srcWidth;\n                ty = texture.y + srcY;\n                tb = texture.y + srcY + srcHeight;\n            }\n\n            depth = depth || 0;\n\n            this.beginPath();\n            this.rect(left, top, right - left, bottom - top, depth);\n            this.currentPath.subPathArray[this.currentPath.subPathNumber - 2].isRegularRect = true;\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            this[_renderActionList].push(action);\n            var texCoordArray = new Array(4);\n            texCoordArray[0] = [tx, ty]; // 左上角\n            texCoordArray[1] = [tr, ty]; // 右上角\n            texCoordArray[2] = [tr, tb]; // 右下角\n            texCoordArray[3] = [tx, tb]; // 左下角\n            color = color || WHITE_COLOR; //白色，在glsl里会成为一个1,1,1的向量，这样就不会改变贴图数据了\n            action.vdo = this.vdo;\n            if (color != WHITE_COLOR) {\n                color = _Color2.default.getInstance().convertStringToColor(color);\n            }\n            action.collectVertexDataForFill(pathList, color, opacity, texCoordArray, this.currentContextState.filterType, this.currentFaceVector, texture.opacity);\n        }\n    }, {\n        key: \"fill\",\n        value: function fill() {\n            var fillColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.vdo = this.vdo;\n            // let vdo = this.getVDOArrays();\n            // action.verticesData = vdo.verticesData;\n            // action.fragmentData = vdo.fragmentData;\n            // action.indexData = vdo.indexData;\n            this[_renderActionList].push(action);\n            action.collectVertexDataForFill(pathList, fillColor, opacity * fillColor[3], [0, 0], this.currentContextState.filterType, this.currentFaceVector);\n        }\n    }, {\n        key: \"measureBMText\",\n        value: function measureBMText(text, bmfont) {\n            if (bmfont == null) {\n                var _font = this.fontFamily;\n                _font = _font.trim().toLocaleLowerCase();\n                bmfont = this.fontManager.getBMFont(_font);\n                if (bmfont == null) {\n                    throw new Error('TieLiFa can not find the font:' + _font + ',you can register the BM Font with API');\n                }\n            }\n            var string = text;\n            var width = 0;\n            var fontSize = this.fontSize;\n            var scale = fontSize / bmfont.size;\n            var spaceChar = bmfont.chars[\" \".charCodeAt(0)];\n            for (var i = 0; i < string.length; i++) {\n                var id = string.charCodeAt(i);\n                var c = bmfont.chars[id];\n                if (c == undefined) {\n                    width += spaceChar.xadvance;\n                    continue;\n                }\n                width += c.xadvance;\n            }\n            return { width: width * scale };\n        }\n\n        /**\r\n         * FIXME 测量结果和实际生成的texture宽度总和是有误差的，这个要改改\r\n         * @param text\r\n         * @returns {{}}\r\n         */\n\n    }, {\n        key: \"measureText\",\n        value: function measureText(text) {\n            var canvas = this._tempCanvas;\n            return _TextTools2.default.measureText(canvas, text, this.fontSize, this.fontFamily, this.fontWeight, this.fontStyle);\n        }\n    }, {\n        key: \"fillTextWithBMFont\",\n        value: function fillTextWithBMFont(text, x, y, maxWidth, depth, bmfont) {\n            if (bmfont == null) {\n                var _font2 = this.fontFamily;\n                _font2 = _font2.trim().toLocaleLowerCase();\n                bmfont = this.fontManager.getBMFont(_font2);\n            }\n\n            var string = text;\n            var fontSize = this.fontSize;\n            var scale = fontSize / bmfont.size;\n            var base = bmfont.common.base;\n            this.save();\n            this.translate(x, y);\n            this.scale(scale, scale);\n            this.translate(-x, -y);\n            var fillColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var textBase = this.textBaseline;\n            var textAlign = this.textAlign;\n            var totalWidth = this.measureBMText(text, bmfont);\n            var sw = 1;\n            var realWidth = totalWidth.width;\n            if (maxWidth != null && maxWidth < totalWidth.width) {\n                if (maxWidth == 0) return;\n                sw = maxWidth / totalWidth.width;\n                realWidth = maxWidth;\n            }\n            if (textAlign == 'end' || textAlign == 'right') {\n                x -= realWidth / scale;\n            }\n            if (textAlign == 'center') {\n                x -= realWidth / scale / 2;\n            }\n            if (textBase == 'top') {}\n            if (textBase == 'bottom') {\n                y -= fontSize / scale;\n            }\n            if (textBase == 'middle') {\n                y -= fontSize / 2 / scale;\n            }\n\n            var spaceChar = bmfont.chars[SPACE_CHAR_ID];\n            for (var i = 0; i < string.length; i++) {\n                var id = string.charCodeAt(i);\n                var c = bmfont.chars[id];\n                if (c == undefined) {\n                    x += spaceChar.xadvance * sw;\n                    continue;\n                }\n                var h = c.height;\n                var w = c.width;\n                w *= sw;\n                var img = this.fontManager.getFontImage(font, c.page);\n                if (img == null || img == undefined) continue;\n                if (id != SPACE_CHAR_ID) {\n                    this.drawImage(img, c.x, c.y, c.width, c.height, x + c.xoffset * sw, y + c.yoffset, w, h, depth, fillColor);\n                }\n                x += c.xadvance * sw;\n            }\n            this.restore();\n        }\n    }, {\n        key: \"createTextlines\",\n        value: function createTextlines(text, fontMetrics, textureManager) {\n            var stringArray = _TextTools2.default.splitTextWithNewlineChar(text);\n            var lineArray = [];\n            var lineMaxWidth = 0;\n            for (var i = 0; i < stringArray.length; i++) {\n                var line = { lineWidth: 0, textures: [], scale: 1 };\n                lineArray.push(line);\n                var s = stringArray[i];\n                for (var j = 0; j < s.length; j++) {\n                    var code = s.charCodeAt(j);\n\n                    if (_TextTools2.default.isNewLineChar(code)) {\n                        code = _TextTools2.default.SPACE_CHAR_CODE;\n                    }\n                    if (_TextTools2.default.isSpacesChar(code)) {\n                        var spaceWidth = fontMetrics.spaceCharWidthCent[code] * this.fontSize;\n                        line.lineWidth += Math.floor(spaceWidth); //之前的计算都是四舍五入，这里截断，有可能会缩小误差哟\n                        line.textures.push(spaceWidth);\n                        continue;\n                    }\n\n                    var char = String.fromCharCode(code);\n                    var textureId = char + \"@\" + fontMetrics.id + \"_\" + this.fontSize.toString();\n                    var texture = textureManager.getTextureById(textureId);\n                    if (texture == null) {\n                        var canvas = this._tempCanvas;\n                        _TextTools2.default.draw2dText(canvas, char, this.fontSize, this.fontFamily, this.fontWeight, this.fontStyle);\n                        texture = textureManager.createTexture(canvas, textureId);\n                    }\n                    line.textures.push(texture);\n                    line.lineWidth += texture.width;\n                }\n                lineMaxWidth = Math.max(lineMaxWidth, line.lineWidth);\n            }\n            return { lineMaxWidth: lineMaxWidth, lineArray: lineArray };\n        }\n\n        /**\r\n         * FIXME italic类型的字符绘制会出现显示不全，这是因为生成的texture宽度没有计算正确。就算计算正确了也没有解决每个字符之间的间距问题\r\n         * @param text\r\n         * @param x\r\n         * @param y\r\n         * @param maxWidth\r\n         * @param depth\r\n         */\n\n    }, {\n        key: \"fillText\",\n        value: function fillText(text, x, y, maxWidth, depth, textLines) {\n            if (depth == null) depth = 0;\n            var textureManager = this.webglRender.textureManager;\n            var string = text;\n            var fontMetrics = _TextTools2.default.measureFont(this._tempCanvas, this.fontFamily, this.fontWeight, this.fontStyle);\n            if (textLines == null) textLines = this.createTextlines(string, fontMetrics, textureManager);\n            var lineArray = textLines.lineArray;\n\n            var lineHeight = Math.ceil(fontMetrics.fontSize * this.fontSize);\n            var baseLine = this.textBaseline;\n            var textAlign = this.textAlign;\n            var totalHeight = lineArray.length * lineHeight;\n\n            var startX = x;\n            var startY = y;\n            var sx = startX;\n            var sy = startY;\n            for (var i = 0; i < lineArray.length; i++) {\n                var line = lineArray[i];\n                var lineWidth = line.lineWidth;\n                if (maxWidth != null) {\n                    if (maxWidth < lineWidth) {\n                        line.scale = maxWidth / lineWidth;\n                        lineWidth = maxWidth;\n                    }\n                }\n                sx = startX;\n                sy = y + lineHeight * i;\n                var offset = _TextTools2.default.getStartPointOffset(baseLine, textAlign, this.fontSize, fontMetrics, lineWidth);\n                sx += offset.x;\n                sy += offset.y;\n                for (var k = 0; k < line.textures.length; k++) {\n                    var t = line.textures[k];\n                    if (t instanceof _Texture2.default) {\n                        var w = t.width * line.scale;\n                        this.drawImage(t, 0, 0, t.width, t.height, sx, sy, w, t.height, depth, this.fillStyle);\n                        sx += w;\n                    } else {\n                        sx += t * line.scale;\n                    }\n                }\n            }\n        }\n    }, {\n        key: \"fillRect\",\n        value: function fillRect(x, y, w, h, depth) {\n            depth = depth || 0;\n            this.beginPath();\n            this.rect(x, y, w, h, depth);\n            this.currentPath.subPathArray[this.currentPath.subPathNumber - 2].isRegularRect = true;\n            this.fill();\n        }\n    }, {\n        key: \"strokeRect\",\n        value: function strokeRect(x, y, w, h, depth) {\n            depth = depth || 0;\n            this.beginPath();\n            this.rect(x, y, w, h, depth);\n            this.stroke();\n        }\n    }, {\n        key: \"stroke\",\n        value: function stroke() {\n            var strokeColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.strokeStyle);\n            var opacity = this.currentContextState.globalAlpha;\n            var pathList = this[_pathList];\n            var lineWidth = this.currentContextState.lineWidth;\n            var filterType = this.currentContextState.filterType;\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.vdo = this.vdo;\n            // let vdo = this.getVDOArrays();\n            // action.verticesData = vdo.verticesData;\n            // action.fragmentData = vdo.fragmentData;\n            // action.indexData = vdo.indexData;\n            this[_renderActionList].push(action);\n            action.collectVertexDataForStroke(pathList, strokeColor, opacity * strokeColor[3], [0, 0], lineWidth, filterType, this.currentFaceVector);\n        }\n\n        //////////////////// ImageData相关 /////////////////////////////\n\n    }, {\n        key: \"createImageData\",\n        value: function createImageData(width, height) {\n            if (arguments.length == 1) {\n                var imgData = width;\n                width = imgData.width;\n                height = imgData.height;\n            }\n            var array = new Uint8ClampedArray(width * height * 4);\n            var backMapData = new ImageData(array, width, height);\n            return backMapData;\n        }\n\n        //******************** 扩展接口 *****************************//\n\n    }, {\n        key: \"applyCurrentTransform\",\n        value: function applyCurrentTransform(point) {\n            var m = this.currentContextState.transformMatrix;\n            var temp = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n            temp[0] = point.x;\n            temp[1] = point.y;\n            temp[2] = point.z;\n            temp[3] = 1;\n            _Mat2.default.multiplyWithVertex(m, temp, temp);\n            return { x: temp[0], y: temp[1], z: temp[2] };\n        }\n\n        /**\r\n         * 绘制一个定义好的graphics，但性能还不如直接画，慎用\r\n         * @param graphics\r\n         * @param x\r\n         * @param y\r\n         */\n\n    }, {\n        key: \"drawGraphics\",\n        value: function drawGraphics(graphics, applyCurrentTransform) {\n            if (this._tempGraphics != null) return;\n            if (applyCurrentTransform == null) applyCurrentTransform = false;\n            if (applyCurrentTransform) this.applyTransformForVDO(this.currentContextState.matrix, graphics.vdo, graphics.vdo);\n            for (var i = 0; i < graphics.actionList.length; i++) {\n                var action = graphics.actionList[i];\n                var newAction = new _RenderAction2.default(action.type);\n                newAction.textureIndex = action.textureIndex;\n                newAction.renderPointNumber = action.renderPointNumber;\n                newAction.opacityPointNumber = action.opacityPointNumber;\n                this[_renderActionList].push(newAction);\n            }\n            var vdo = this.vdo;\n            var offset = vdo.verticesData.currentIndex;\n            vdo.verticesData.append(graphics.vdo.verticesData);\n            vdo.fragmentData.append(graphics.vdo.fragmentData);\n            var indexData = graphics.vdo.indexData;\n            for (var _i = 0; _i < indexData.currentIndex; _i++) {\n                vdo.indexData.addIndex(indexData.getIndex(_i) + offset);\n            }\n            offset = vdo.opacityVerticesData.currentIndex;\n            vdo.opacityVerticesData.append(graphics.vdo.opacityVerticesData);\n            vdo.opacityFragmentData.append(graphics.vdo.opacityFragmentData);\n            var opIndexData = graphics.vdo.opacityIndexData;\n            for (var _i2 = 0; _i2 < opIndexData.currentIndex; _i2++) {\n                vdo.opacityIndexData.addIndex(opIndexData.getIndex(_i2) + offset);\n            }\n        }\n    }, {\n        key: \"copyGraphicsVDO\",\n        value: function copyGraphicsVDO(graphics, out) {\n            var vdo = graphics.vdo;\n            if (out == null) {\n                out = new _VDO2.default(vdo.verticesData.currentIndex, vdo.indexData.currentIndex, this._mixOpacity);\n            }\n            out.verticesData.copyFrom(vdo.verticesData);\n            out.fragmentData.copyFrom(vdo.fragmentData);\n            out.indexData.copyFrom(vdo.indexData);\n\n            out.opacityVerticesData.copyFrom(vdo.opacityVerticesData);\n            out.opacityFragmentData.copyFrom(vdo.opacityFragmentData);\n            out.opacityIndexData.copyFrom(vdo.opacityIndexData);\n            return out;\n        }\n    }, {\n        key: \"applyCurrentTransformForVDO\",\n        value: function applyCurrentTransformForVDO(vdo, out) {\n            this.applyTransformForVDO(this.currentContextState.matrix, vdo, out);\n        }\n    }, {\n        key: \"applyTransformForVDO\",\n        value: function applyTransformForVDO(matrix, vdo, out) {\n            if (out == null) out = vdo;\n            _Mat2.default.mat4ToMat3(matrix, TEMP_TRANFORM_MAT3);\n            var _normalTransformMatrix = TEMP_TRANFORM_MAT3;\n            //这里的数据需要从最开始记录的原始数据中进行计算：\n            var verticesData = vdo.verticesData;\n            var opacityVerticesData = vdo.opacityVerticesData;\n            var targetVerticesData = out.verticesData;\n            var targetOpaVerticesData = out.opacityVerticesData;\n            var _tempVertices = TEMP_VERTEX_COORD4DIM_ARRAY[0];\n            for (var i = 0; i < verticesData.currentIndex; i++) {\n                _tempVertices[0] = verticesData.getVerticesPositionXData(i);\n                _tempVertices[1] = verticesData.getVerticesPositionYData(i);\n                _tempVertices[2] = verticesData.getVerticesPositionZData(i);\n                _Mat2.default.multiplyWithVertex(matrix, _tempVertices, _tempVertices);\n                var x = _tempVertices[0];\n                var y = _tempVertices[1];\n                var z = _tempVertices[2];\n\n                _tempVertices[0] = verticesData.getVerticesNormalXData(i);\n                _tempVertices[1] = verticesData.getVerticesNormalYData(i);\n                _tempVertices[2] = verticesData.getVerticesNormalZData(i);\n                _Mat4.default.multiplyWithVertex(_tempVertices, _normalTransformMatrix, _tempVertices);\n                targetVerticesData.setVerticesData(x, y, z, _tempVertices[0], _tempVertices[1], _tempVertices[2], i);\n            }\n            for (var _i3 = 0; _i3 < opacityVerticesData.currentIndex; _i3++) {\n                _tempVertices[0] = opacityVerticesData.getVerticesPositionXData(_i3);\n                _tempVertices[1] = opacityVerticesData.getVerticesPositionYData(_i3);\n                _tempVertices[2] = opacityVerticesData.getVerticesPositionZData(_i3);\n                _Mat2.default.multiplyWithVertex(matrix, _tempVertices, _tempVertices);\n                var _x = _tempVertices[0];\n                var _y = _tempVertices[1];\n                var _z = _tempVertices[2];\n\n                _tempVertices[0] = opacityVerticesData.getVerticesNormalXData(_i3);\n                _tempVertices[1] = opacityVerticesData.getVerticesNormalYData(_i3);\n                _tempVertices[2] = opacityVerticesData.getVerticesNormalZData(_i3);\n                _Mat4.default.multiplyWithVertex(_tempVertices, _normalTransformMatrix, _tempVertices);\n                targetOpaVerticesData.setVerticesData(_x, _y, _z, _tempVertices[0], _tempVertices[1], _tempVertices[2], _i3);\n            }\n        }\n\n        /**\r\n         * 定义一个graphics\r\n         * @param graphics\r\n         * @param vertexNum\r\n         */\n\n    }, {\n        key: \"startGraphics\",\n        value: function startGraphics(graphics, vertexNum) {\n            if (this._tempGraphics != null) return;\n            vertexNum = vertexNum || 4;\n            this._tempPathArray = this[_pathList];\n            this[_pathList] = [];\n            this[_pathList].push(new _Path3D2.default());\n\n            var state = new _ContextState2.default(new _CanvasDrawingStylesWebgl2D2.default());\n            this[_stateStack].push(state);\n            if (graphics != null) {\n                graphics.vdo.init();\n                graphics.actionList.length = 0;\n            } else {\n                graphics = {\n                    vdo: new _VDO2.default(vertexNum, vertexNum, this._mixOpacity),\n                    transformMatrixData: null,\n                    actionList: []\n                };\n            }\n            this._tempVDO = this.vdo;\n            this.vdo = graphics.vdo;\n\n            this._tempGraphics = graphics;\n\n            this._tempActionList = this[_renderActionList];\n            this[_renderActionList] = graphics.actionList;\n        }\n    }, {\n        key: \"endGraphics\",\n        value: function endGraphics() {\n            this[_stateStack].pop();\n            this[_pathList] = this._tempPathArray;\n            this[_renderActionList] = this._tempActionList;\n            this.vdo = this._tempVDO;\n\n            this._tempPathArray = null;\n            this._tempActionList = null;\n            this._tempVDO = null;\n\n            var tf = this._tempGraphics;\n            this._tempGraphics = null;\n            return tf;\n        }\n    }, {\n        key: \"loadBMFont\",\n        value: function loadBMFont(fntUrl, callbacks) {\n            callbacks = callbacks || {};\n            this.fontManager.loadBMFont(fntUrl, this.webglRender.textureManager, this.gl, callbacks);\n        }\n    }, {\n        key: \"turnOnLight\",\n        value: function turnOnLight() {\n            this.webglRender.enableLight(true);\n        }\n    }, {\n        key: \"turnOffLight\",\n        value: function turnOffLight() {\n            this.webglRender.enableLight(false);\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(x, y, z) {\n            this.webglRender.setLightPosition(x, y, z);\n        }\n    }, {\n        key: \"fillOrStroke\",\n        value: function fillOrStroke(fillColor, strokeColor) {\n            if (fillColor != undefined) {\n                this.fillStyle = fillColor;\n                this.fill();\n            }\n            if (strokeColor != undefined) {\n                this.strokeStyle = strokeColor;\n                this.stroke();\n            }\n        }\n    }, {\n        key: \"fillStripe\",\n        value: function fillStripe(points, stripeWidth, color, opacity, image, applyTransform) {\n            if (applyTransform == undefined) applyTransform = true;\n            if (applyTransform) {\n                var tempPoints = [];\n                for (var i = 0; i < points.length; i++) {\n                    var p = this.applyCurrentTransform(points[i]);\n                    tempPoints.push(p);\n                }\n                points = tempPoints;\n            }\n            var inputInterface = {\n                getX: function getX(index) {\n                    return points[index].x;\n                },\n                getY: function getY(index) {\n                    return points[index].y;\n                },\n                getZ: function getZ(index) {\n                    var z = points[index].z;\n                    if (z == undefined) return 0;\n                    return z;\n                },\n                getPointsNum: function getPointsNum() {\n                    return points.length;\n                }\n            };\n            this._rawFillLine(inputInterface, stripeWidth, color, opacity, null, image);\n        }\n    }, {\n        key: \"_rawFillLine\",\n        value: function _rawFillLine(inputInterface, lineWidth, color, opacity, filterType, image) {\n            var pointsNum = inputInterface.getPointsNum();\n            if (pointsNum < 2) return;\n            if (opacity == null) opacity = 1;\n            opacity = opacity * this.currentContextState.globalAlpha;\n            var vod = this.vdo;\n            vod.switch(opacity < 1);\n            var faceDirection = this.currentFaceVector;\n            filterType = filterType || this.currentContextState.filterType;\n            color = color || this.currentContextState.fillStyle;\n            var colorValue = _Color2.default.getInstance().convertStringToColor(color);\n            var offset = vod.currentIndex;\n            var texture = null;\n            if (image) {\n                texture = this.webglRender.textureManager.getTexture(image);\n                vod.switch(opacity < 1 || texture.opacity);\n            }\n            var plusTextureWidth = 0;\n            var plusTextureHeight = 0;\n            if (texture != null) {\n                plusTextureWidth = texture.width / (pointsNum - 1);\n                plusTextureHeight = texture.height;\n            }\n\n            var outputInterface = {\n                setPoint: function setPoint(p, index) {\n                    vod.currentVerticesData.setVerticesCoor(p.x, p.y, p.z, index + offset);\n                },\n                addPoint: function addPoint(p, lineIndex, pointIndexInTheLine) {\n                    if (vod.currentVerticesData != null) {\n                        vod.currentVerticesData.addVerticesData(p.x, p.y, p.z, faceDirection[0], faceDirection[1], faceDirection[2]);\n                    }\n                    if (vod.fragmentData != null) {\n                        var uv = [0, 0];\n                        if (texture != null) {\n                            if (lineIndex == 0) {\n                                if (pointIndexInTheLine == 0) {\n                                    uv[0] = lineIndex * plusTextureWidth;\n                                    uv[1] = 0;\n                                }\n                                if (pointIndexInTheLine == 3) {\n                                    uv[0] = lineIndex * plusTextureWidth;\n                                    uv[1] = plusTextureHeight;\n                                }\n                            } else {\n                                if (pointIndexInTheLine == 0) {\n                                    uv[0] = (lineIndex - 1) * plusTextureWidth + plusTextureWidth;\n                                    uv[1] = 0;\n                                }\n                                if (pointIndexInTheLine == 3) {\n                                    uv[0] = (lineIndex - 1) * plusTextureWidth + plusTextureWidth;\n                                    uv[1] = plusTextureHeight;\n                                }\n                            }\n                            if (pointIndexInTheLine == 1) {\n                                uv[0] = lineIndex * plusTextureWidth + plusTextureWidth;\n                                uv[1] = 0;\n                            }\n\n                            if (pointIndexInTheLine == 2) {\n                                uv[0] = lineIndex * plusTextureWidth + plusTextureWidth;\n                                uv[1] = plusTextureHeight;\n                            }\n                        }\n                        vod.currentFragmentData.addFragmentData(colorValue[0], colorValue[1], colorValue[2], opacity, uv[0], uv[1], -1, filterType);\n                    }\n                }\n            };\n\n            var lineNum = _LineToRectangle2.default.generateRectanglesPoints(lineWidth, false, faceDirection, outputInterface, inputInterface);\n            for (var k = 0; k < lineNum; k++) {\n                var index = k * 4;\n                vod.currentIndexData.addIndex(offset + index);\n                vod.currentIndexData.addIndex(offset + index + 1);\n                vod.currentIndexData.addIndex(offset + index + 2);\n\n                vod.currentIndexData.addIndex(offset + index + 2);\n                vod.currentIndexData.addIndex(offset + index + 3);\n                vod.currentIndexData.addIndex(offset + index);\n            }\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            action.textureIndex = -1;\n            if (texture != null) action.textureIndex = texture.index;\n            action.renderPointNumber = lineNum * 6;\n            this[_renderActionList].push(action);\n\n            vod.switch(false);\n        }\n    }, {\n        key: \"drawRectangle\",\n        value: function drawRectangle(x, y, w, h, fillColor, strokeColor) {\n            this.save();\n            this.beginPath();\n            this.rect(x, y, w, h);\n            this.currentPath.subPathArray[this.currentPath.subPathNumber - 2].isRegularRect = true;\n            this.fillOrStroke(fillColor, strokeColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawEllipse\",\n        value: function drawEllipse(x, y, r1, r2, fillColor, strokeColor, rotation) {\n            rotation = rotation || 0;\n            this.save();\n            this.beginPath();\n            this.ellipse(x, y, r1, r2, rotation, 0, _Tools2.default.PI2, false);\n            this.closePath();\n            this.fillOrStroke(fillColor, strokeColor);\n            this.restore();\n        }\n    }, {\n        key: \"drawCircle\",\n        value: function drawCircle(x, y, r, fillColor, strokeColor) {\n            this.drawEllipse(x, y, r, r, fillColor, strokeColor, 0);\n        }\n    }, {\n        key: \"update\",\n        value: function update() {\n            this.draw();\n        }\n    }, {\n        key: \"draw\",\n        value: function draw() {\n            if (this._tempGraphics != null) return;\n            this.webglRender.initRending();\n            this.webglRender.executeRenderAction(this[_renderActionList]);\n            this[_renderActionList] = [];\n            this.vdo.init();\n            this.webglRender.textureManager.clean();\n            this._painedGraphicsMap = {};\n            // debug:\n            // console.log(\"绘制调用次数：\", this.webglRender.DEBUG_DRAW_COUNT);\n        }\n    }, {\n        key: \"loadImage\",\n        value: function loadImage(src, callbacks, split, id) {\n            throw new Error('this methods was not implemented');\n            // this.webglRender.textureManager.registerTexture(id, this.gl, null, src, callbacks, split);\n        }\n    }, {\n        key: \"getTexture\",\n        value: function getTexture(id, index) {\n            return this.webglRender.textureManager.getTextureById(id, index);\n        }\n\n        /**********************************************3d部分绘制*****************************************/\n\n    }, {\n        key: \"drawCube\",\n        value: function drawCube(x, y, z, width, height, depth, properties) {\n\n            var defaultColor = this.fillStyle;\n            var frontColor = defaultColor;\n            var backColor = defaultColor;\n            var rightColor = defaultColor;\n            var leftColor = defaultColor;\n            var bottomColor = defaultColor;\n            var topColor = defaultColor;\n            var defaultOpacity = this.globalAlpha;\n            var topOpa = defaultOpacity;\n            var bottomOpa = defaultOpacity;\n            var leftOpa = defaultOpacity;\n            var rightOpa = defaultOpacity;\n            var frontOpa = defaultOpacity;\n            var backOpa = defaultOpacity;\n            if (properties !== undefined) {\n                frontColor = properties.frontColor || defaultColor;\n                backColor = properties.backColor || defaultColor;\n                rightColor = properties.rightColor || defaultColor;\n                leftColor = properties.leftColor || defaultColor;\n                bottomColor = properties.bottomColor || defaultColor;\n                topColor = properties.topColor || defaultColor;\n                if (properties.topOpacity != null) topOpa *= properties.topOpacity;\n                if (properties.bottomOpacity != null) bottomOpa *= properties.bottomOpacity;\n                if (properties.rightOpacity != null) rightOpa *= properties.rightOpacity;\n                if (properties.leftOpacity != null) leftOpa *= properties.leftOpacity;\n                if (properties.frontOpacity != null) frontOpa *= properties.frontOpacity;\n                if (properties.backOpacity != null) backOpa *= properties.backOpacity;\n            }\n            //正面：\n            this.save();\n            this.globalAlpha = frontOpa;\n            this.fillStyle = frontColor;\n            this.translate(x, y, z);\n            this.fillRect(-width / 2, -height / 2, width, height, depth / 2);\n            this.restore();\n\n            //背面\n            this.save();\n            this.fillStyle = backColor;\n            this.globalAlpha = backOpa;\n            this.translate(x, y, z);\n            //这里是为了面的朝向发生改变，其实不考虑法向量的话直接画都行\n            this.rotateY(Math.PI);\n            this.fillRect(-width / 2, -height / 2, width, height, depth / 2);\n            this.restore();\n\n            //左侧：\n            this.save();\n            this.fillStyle = leftColor;\n            this.globalAlpha = leftOpa;\n            this.translate(x, y, z);\n            this.rotateY(-Math.PI / 2);\n            this.fillRect(-depth / 2, -height / 2, depth, height, width / 2);\n            this.restore();\n\n            //右侧：\n            this.save();\n            this.fillStyle = rightColor;\n            this.globalAlpha = rightOpa;\n            this.translate(x, y, z);\n            this.rotateY(Math.PI / 2);\n            this.fillRect(-depth / 2, -height / 2, depth, height, width / 2);\n            this.restore();\n\n            //底部：\n            this.save();\n            this.fillStyle = bottomColor;\n            this.globalAlpha = bottomOpa;\n            this.translate(x, y, z);\n            this.rotateX(-Math.PI / 2);\n            this.fillRect(-width / 2, -depth / 2, width, depth, height / 2);\n            this.restore();\n\n            //顶部：\n            this.save();\n            this.fillStyle = topColor;\n            this.globalAlpha = topOpa;\n            this.translate(x, y, z);\n            this.rotateX(Math.PI / 2);\n            this.fillRect(-width / 2, -depth / 2, width, depth, height / 2);\n            this.restore();\n        }\n    }, {\n        key: \"drawCylinder\",\n        value: function drawCylinder(x, y, z, height, radiusX, radiusY, startAngle, endAngle, properties) {\n            if (startAngle === endAngle) return;\n            if (radiusX < 0 || radiusY < 0) throw new Error('IndexError.半径必须不小于0. Radius should not be smaller than zero. BanJing BiXu BuXiaoYu Ling');\n            var anticlockwise = false;\n            if (radiusX == 0 || radiusY == 0) return;\n            var bottomColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var topColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n            var surfaceColor = _Color2.default.getInstance().convertStringToColor(this.currentContextState.fillStyle);\n\n            var opacity = this.globalAlpha;\n            var topOpa = opacity;\n            var bottomOpa = opacity;\n            var surfaceOpa = opacity;\n            if (properties !== undefined) {\n                if (properties.bottomColor !== undefined) {\n                    bottomColor = _Color2.default.getInstance().convertStringToColor(properties.bottomColor);\n                }\n                if (properties.topColor !== undefined) {\n                    topColor = _Color2.default.getInstance().convertStringToColor(properties.topColor);\n                }\n                if (properties.surfaceColor !== undefined) {\n                    surfaceColor = _Color2.default.getInstance().convertStringToColor(properties.surfaceColor);\n                }\n\n                if (properties.topOpacity != undefined) topOpa *= properties.topOpacity;\n                if (properties.bottomOpacity != undefined) bottomOpa *= properties.bottomOpacity;\n                if (properties.surfaceOpacity != undefined) surfaceOpa *= properties.surfaceOpacity;\n            }\n\n            var UV = [0, 0];\n            var action = new _RenderAction2.default(_RenderAction2.default.ACTION_FILL);\n            this.renderActionList.push(action);\n            //清空当前的路径坐标\n            this.beginPath();\n\n            // let vd = this.getVDOArrays().verticesData;\n            // let fd = this.getVDOArrays().fragmentData;\n            // let id = this.getVDOArrays().indexData;\n            var vdo = this.vdo;\n\n            var tempMat = _Mat2.default.identity();\n            var tempMat1 = _Mat2.default.TEMP_MAT4[0];\n            var currentMatrix = this.currentContextState.transformMatrix;\n\n            // 面朝下:\n            _Mat2.default.translationMatrix(tempMat1, x, y + height / 2, z);\n            _Mat2.default.multiply(tempMat, currentMatrix, tempMat1);\n            _Mat2.default.rotationXMatrix(tempMat1, -Math.PI / 2);\n            _Mat2.default.multiply(tempMat, tempMat, tempMat1);\n            var bottomEllipseMat = this.getEllipseCalculateTempMatrix(0, 0, 0, radiusX, radiusY, 0, tempMat);\n\n            //计算法向量：\n            var tempPoint = { x: 0, y: 0, z: 0 };\n            var tempPoint2 = { x: 0, y: 0, z: 1 };\n            _Mat2.default.multiplyWithVet3(tempMat, tempPoint, tempPoint);\n            _Mat2.default.multiplyWithVet3(tempMat, tempPoint2, tempPoint2);\n\n            var bottomNormal = { x: 0, y: 0, z: 0 };\n            _Vector2.default.sub(bottomNormal, tempPoint2, tempPoint);\n            _Vector2.default.normalize(bottomNormal, bottomNormal);\n            var topNormal = { x: -bottomNormal.x, y: -bottomNormal.y, z: -bottomNormal.z };\n\n            //添加圆心坐标点\n            var center1 = { x: 0, y: 0, z: 0 };\n            _Vector2.default.copy(tempPoint, center1);\n            var center2 = { x: 0, y: 0, z: 0 };\n            vdo.switch(bottomOpa < 1);\n            var bottomCenterIndex = vdo.currentIndex;\n            vdo.addVerticesData2(center1, bottomNormal, bottomColor, bottomOpa, UV, -1, 0);\n            vdo.switch(false);\n\n            var scaleVet = { x: 0, y: 0, z: 0 };\n            _Vector2.default.multiplyValue(scaleVet, topNormal, height);\n\n            _Vector2.default.plus(center2, center1, scaleVet);\n            vdo.switch(topOpa < 1);\n            var topCenterIndex = vdo.currentIndex;\n            vdo.addVerticesData2(center2, topNormal, topColor, topOpa, UV, -1, 0);\n            vdo.switch(false);\n\n            var realRadius1 = Math.max(radiusX * this.currentContextState.scaleValue.x, radiusY * this.currentContextState.scaleValue.y); // 这个值要根据当前缩放算一下\n            var deltaTheta = Math.asin(1 / realRadius1) * 2;\n            // deltaTheta = Math.PI/2;\n\n            startAngle = this.adjustEllipseAngle(startAngle, anticlockwise);\n            endAngle = this.adjustEllipseAngle(endAngle, anticlockwise);\n\n            if (startAngle > endAngle && !anticlockwise || startAngle < endAngle && anticlockwise) {\n                if (startAngle < 0 || endAngle < 0) {\n                    endAngle -= 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle -= 2 * Math.PI;\n                }\n                if (startAngle > 0 || endAngle > 0) {\n                    endAngle += 2 * Math.PI;\n                    if (endAngle == startAngle || Math.abs(endAngle - startAngle) <= _Tools2.default.EPSILON) endAngle += 2 * Math.PI;\n                }\n            }\n            var tempVet = { x: 0, y: 0, z: 0 };\n            var tempVet2 = { x: 0, y: 0, z: 0 };\n            var preBottomPoint = undefined;\n            var preTopPoint = undefined;\n\n            var currentBottomIndex = vdo.originalCurrentIndex;\n            if (bottomOpa < 1) currentBottomIndex = vdo.opacityCurrentIndex;\n            var currentTopIndex = vdo.originalCurrentIndex;\n            if (topOpa < 1) currentTopIndex = vdo.opacityCurrentIndex;\n            var preBottomIndex = -1;\n            var preTopIndex = -1;\n\n            var firstBottomIndex = -1;\n            var firstTopIndex = -1;\n            var tempNormal = { x: 0, y: 0, z: 0 };\n            var currentSurfaceIndex = -1;\n            var firstSurfacePoint1 = void 0;\n            var firstSurfacePoint2 = void 0;\n            var lastSurfacePoint1 = { x: 0, y: 0, z: 0 };\n            var lastSurfacePoint2 = { x: 0, y: 0, z: 0 };\n            var tempSurfaceNormal = { x: 0, y: 0, z: 0 };\n            var isFullEllipse = Math.abs(endAngle - startAngle) >= _Tools2.default.PI2;\n            var theta = 0;\n            var bottomCirclePoints = [];\n            var topCirclePoints = [];\n            for (theta = startAngle; theta < endAngle; theta += deltaTheta) {\n                if (Math.abs(theta - startAngle) >= _Tools2.default.PI2) {\n                    return;\n                }\n\n                var s = Math.sin(theta);\n                var c = Math.cos(theta);\n                tempVet.x = c;\n                tempVet.y = s;\n                tempVet.z = 0;\n                _Mat2.default.multiplyWithVet3(bottomEllipseMat, tempVet, tempVet);\n\n                bottomCirclePoints.push({ x: tempVet.x, y: tempVet.y, z: tempVet.z });\n                _Vector2.default.plus(tempVet2, tempVet, scaleVet);\n                topCirclePoints.push({ x: tempVet2.x, y: tempVet2.y, z: tempVet2.z });\n            }\n\n            //组织bottom面：\n            vdo.switch(bottomOpa < 1);\n            var bottomStartIndex = vdo.currentIndex;\n            for (var i = 0; i < bottomCirclePoints.length; i++) {\n                var p = bottomCirclePoints[i];\n                vdo.addVerticesData2(p, bottomNormal, bottomColor, bottomOpa, UV, -1, 0);\n                vdo.addIndex(bottomCenterIndex);\n                vdo.addIndex(bottomStartIndex + i);\n                var nextIndex = i + 1;\n                if (nextIndex >= bottomCirclePoints.length) nextIndex = 0;\n                vdo.addIndex(bottomStartIndex + nextIndex);\n            }\n            if (vdo.useOpacityBuffer) {\n                action.opacityPointNumber += bottomCirclePoints.length * 3;\n            } else {\n                action.renderPointNumber += bottomCirclePoints.length * 3;\n            }\n            vdo.switch(false);\n\n            //组织top面：\n            vdo.switch(topOpa < 1);\n            var topStartIndex = vdo.currentIndex;\n            for (var _i4 = 0; _i4 < topCirclePoints.length; _i4++) {\n                var _p = topCirclePoints[_i4];\n                vdo.addVerticesData2(_p, topNormal, topColor, topOpa, UV, -1, 0);\n                vdo.addIndex(topCenterIndex);\n                vdo.addIndex(topStartIndex + _i4);\n                var _nextIndex = _i4 + 1;\n                if (_nextIndex >= bottomCirclePoints.length) _nextIndex = 0;\n                vdo.addIndex(topStartIndex + _nextIndex);\n            }\n            if (vdo.useOpacityBuffer) {\n                action.opacityPointNumber += bottomCirclePoints.length * 3;\n            } else {\n                action.renderPointNumber += bottomCirclePoints.length * 3;\n            }\n            vdo.switch(false);\n\n            //组织侧面：\n            vdo.switch(surfaceOpa < 1);\n            for (var _i5 = 0; _i5 < topCirclePoints.length; _i5++) {\n\n                var _nextIndex2 = _i5 + 1;\n                if (_nextIndex2 >= bottomCirclePoints.length) {\n                    _nextIndex2 = 0;\n                }\n\n                var p1 = bottomCirclePoints[_i5];\n                var p2 = topCirclePoints[_i5];\n                var p3 = topCirclePoints[_nextIndex2];\n                var p4 = bottomCirclePoints[_nextIndex2];\n\n                _Vector2.default.sub(tempSurfaceNormal, p4, p1);\n                _Vector2.default.normalize(tempSurfaceNormal, tempSurfaceNormal);\n                _Vector2.default.cross(tempNormal, tempSurfaceNormal, bottomNormal);\n                var surfaceStartIndex = vdo.addVerticesData2(p1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n                vdo.addVerticesData2(p2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n                vdo.addVerticesData2(p3, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n                vdo.addVerticesData2(p4, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n\n                vdo.addIndex(surfaceStartIndex);\n                vdo.addIndex(surfaceStartIndex + 1);\n                vdo.addIndex(surfaceStartIndex + 2);\n\n                vdo.addIndex(surfaceStartIndex + 2);\n                vdo.addIndex(surfaceStartIndex + 3);\n                vdo.addIndex(surfaceStartIndex);\n            }\n            if (vdo.useOpacityBuffer) {\n                action.opacityPointNumber += bottomCirclePoints.length * 6;\n            } else {\n                action.renderPointNumber += bottomCirclePoints.length * 6;\n            }\n            vdo.switch(false);\n\n            /****下面的方法快，而且少耗内存，但是由于没有不透明的深度排序，会出问题，目前采用上面那种分别绘制底面、顶面和侧面****/\n            // for (theta = startAngle; theta < endAngle; theta += deltaTheta) {\n            //  if (Math.abs(theta - startAngle) >= Tools.PI2) {\n            //         return;\n            //     }\n            //\n            //  // 底面圆坐标计算：\n            //  let s = Math.sin(theta);\n            //  let c = Math.cos(theta);\n            //  tempVet.x = c;\n            //  tempVet.y = s;\n            //  tempVet.z = 0;\n            //  Mat4.multiplyWithVet3(bottomEllipseMat, tempVet, tempVet);\n            //  vdo.switch(bottomOpa < 1);\n            //  currentBottomIndex = vdo.currentIndex;\n            //  vdo.addVerticesData2(tempVet, bottomNormal, bottomColor, bottomOpa, UV, -1, 0);\n            //  vdo.switch(false);\n            //\n            //  //顶层圆坐标计算：\n            //  Vector3.plus(tempVet2, tempVet, scaleVet);\n            //  vdo.switch(topOpa < 1);\n            //  currentTopIndex = vdo.currentIndex;\n            //  vdo.addVerticesData2(tempVet2, topNormal, topColor, topOpa, UV, -1, 0);\n            //  vdo.switch(false);\n            //\n            //  if (preBottomPoint === undefined && preTopPoint === undefined) {\n            //         // 无法形成面,记录\n            //         firstBottomIndex = currentBottomIndex;\n            //         firstTopIndex = currentTopIndex;\n            //         preBottomIndex = currentBottomIndex;\n            //         preTopIndex = currentTopIndex;\n            //\n            //         preBottomPoint = {x: 0, y: 0, z: 0};\n            //         preTopPoint = {x: 0, y: 0, z: 0};\n            //         Vector3.copy(tempVet, preBottomPoint);\n            //         Vector3.copy(tempVet2, preTopPoint);\n            //         firstSurfacePoint1 = {x: 0, y: 0, z: 0};\n            //         firstSurfacePoint2 = {x: 0, y: 0, z: 0};\n            //         Vector3.copy(tempVet, firstSurfacePoint1);\n            //         Vector3.copy(tempVet2, firstSurfacePoint2);\n            //\n            //     } else {\n            //         //由于圆柱侧面的法线不同，需要重新添加坐标：\n            //\n            //         //计算面的法线：\n            //         Vector3.sub(tempSurfaceNormal, tempVet, preBottomPoint);\n            //         Vector3.normalize(tempSurfaceNormal, tempSurfaceNormal);\n            //         Vector3.cross(tempNormal, tempSurfaceNormal, bottomNormal);\n            //         currentSurfaceIndex = vdo.originalCurrentIndex;\n            //         vdo.switch(surfaceOpa < 1);\n            //         currentSurfaceIndex = vdo.currentIndex;\n            //         Vector3.copy(tempVet, lastSurfacePoint1);\n            //         Vector3.copy(tempVet2, lastSurfacePoint2);\n            //         vdo.addVerticesData2(preBottomPoint, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //         vdo.addVerticesData2(tempVet, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //         vdo.addVerticesData2(tempVet2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //         vdo.addVerticesData2(preTopPoint, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //\n            //\n            //         //建立侧面：\n            //         vdo.addIndex(currentSurfaceIndex);\n            //         vdo.addIndex(currentSurfaceIndex + 1);\n            //         vdo.addIndex(currentSurfaceIndex + 2);\n            //\n            //         vdo.addIndex(currentSurfaceIndex + 2);\n            //         vdo.addIndex(currentSurfaceIndex + 3);\n            //         vdo.addIndex(currentSurfaceIndex);\n            //         if (vdo.useOpacityBuffer) {\n            //             action.opacityPointNumber += 6;\n            //         } else {\n            //             action.renderPointNumber += 6;\n            //         }\n            //         vdo.switch(false);\n            //\n            //         vdo.switch(bottomOpa < 1);\n            //         //建立底层圆索引：\n            //         vdo.addIndex(bottomCenterIndex);\n            //         vdo.addIndex(preBottomIndex);\n            //         vdo.addIndex(currentBottomIndex);\n            //         if (vdo.useOpacityBuffer) {\n            //             action.opacityPointNumber += 3;\n            //         } else {\n            //             action.renderPointNumber += 3;\n            //         }\n            //         vdo.switch(false);\n            //\n            //         vdo.switch(topOpa < 1);\n            //         //建立顶层圆索引：\n            //         vdo.addIndex(topCenterIndex);\n            //         vdo.addIndex(preTopIndex);\n            //         vdo.addIndex(currentTopIndex);\n            //         if (vdo.useOpacityBuffer) {\n            //             action.opacityPointNumber += 3;\n            //         } else {\n            //             action.renderPointNumber += 3;\n            //         }\n            //         vdo.switch(false);\n            //\n            //         Vector3.copy(tempVet, preBottomPoint);\n            //         Vector3.copy(tempVet2, preTopPoint);\n            //         preBottomIndex = currentBottomIndex;\n            //         preTopIndex = currentTopIndex;\n            //     }\n            //  }\n            //  //封边：\n            //  if (isFullEllipse) {\n            //\n            //     // 完成圆形第一个点的底面/顶面\n            //     vdo.switch(bottomOpa < 1);\n            //     vdo.addIndex(bottomCenterIndex);\n            //     vdo.addIndex(currentBottomIndex);\n            //     vdo.addIndex(firstBottomIndex);\n            //     if (vdo.useOpacityBuffer) {\n            //         action.opacityPointNumber += 3;\n            //     } else {\n            //         action.renderPointNumber += 3;\n            //     }\n            //     vdo.switch(false);\n            //\n            //     vdo.switch(topOpa < 1);\n            //     vdo.addIndex(topCenterIndex);\n            //     vdo.addIndex(currentTopIndex);\n            //     vdo.addIndex(firstTopIndex);\n            //     if (vdo.useOpacityBuffer) {\n            //         action.opacityPointNumber += 3;\n            //     } else {\n            //         action.renderPointNumber += 3;\n            //     }\n            //     vdo.switch(false);\n            //\n            //     //首尾相连：\n            //     Vector3.sub(tempSurfaceNormal, lastSurfacePoint1, firstSurfacePoint1);\n            //     Vector3.normalize(tempSurfaceNormal, tempSurfaceNormal);\n            //     Vector3.cross(tempNormal, tempSurfaceNormal, bottomNormal);\n            //\n            //     vdo.switch(surfaceOpa < 1);\n            //     let index = vdo.currentIndex;\n            //     vdo.addVerticesData2(lastSurfacePoint1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(firstSurfacePoint1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(firstSurfacePoint2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(lastSurfacePoint2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     //建立侧面：\n            //     vdo.indexData.addIndex(index);\n            //     vdo.indexData.addIndex(index + 1);\n            //     vdo.indexData.addIndex(index + 2);\n            //\n            //     vdo.indexData.addIndex(index + 2);\n            //     vdo.indexData.addIndex(index + 3);\n            //     vdo.indexData.addIndex(index);\n            //     if (vdo.useOpacityBuffer) {\n            //         action.opacityPointNumber += 6;\n            //     } else {\n            //         action.renderPointNumber += 6;\n            //     }\n            //     vdo.switch(false);\n            // } else {\n            //     //侧面各自和中心完成封边：\n            //     Vector3.sub(tempSurfaceNormal, firstSurfacePoint1, center1);\n            //     Vector3.cross(tempNormal, bottomNormal, tempSurfaceNormal);\n            //     Vector3.normalize(tempNormal, tempNormal);\n            //     vdo.switch(surfaceOpa < 1);\n            //     let index = vdo.currentIndex;\n            //     vdo.addVerticesData2(center1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(center2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(firstSurfacePoint2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(firstSurfacePoint1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     //建立侧面：\n            //     vdo.addIndex(index);\n            //     vdo.addIndex(index + 1);\n            //     vdo.addIndex(index + 2);\n            //\n            //     vdo.addIndex(index + 2);\n            //     vdo.addIndex(index + 3);\n            //     vdo.addIndex(index);\n            //     let temp = {x: 0, y: 0, z: 0};\n            //     Vector3.sub(temp, lastSurfacePoint1, center1);\n            //     Vector3.cross(tempNormal, bottomNormal, temp);\n            //     Vector3.normalize(tempNormal, tempNormal);\n            //     index = vdo.currentIndex;\n            //     vdo.addVerticesData2(center1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(center2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(lastSurfacePoint2, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     vdo.addVerticesData2(lastSurfacePoint1, tempNormal, surfaceColor, surfaceOpa, UV, -1, 0);\n            //     //建立侧面：\n            //     vdo.addIndex(index);\n            //     vdo.addIndex(index + 1);\n            //     vdo.addIndex(index + 2);\n            //\n            //     vdo.addIndex(index + 2);\n            //     vdo.addIndex(index + 3);\n            //     vdo.addIndex(index);\n            //\n            //     if (vdo.useOpacityBuffer) {\n            //         action.opacityPointNumber += 12;\n            //     } else {\n            //         action.renderPointNumber += 12;\n            //     }\n            //     vdo.switch(false);\n            // }\n        }\n    }, {\n        key: \"textureManager\",\n        get: function get() {\n            return this.webglRender.textureManager;\n        }\n    }, {\n        key: \"defaultDepth\",\n        get: function get() {\n            return this.webglRender.defaultDepth;\n        }\n    }, {\n        key: \"currentContextState\",\n        get: function get() {\n            if (this[_stateStack].length == 0) {\n                // 状态栈永远不为空\n                var state = new _ContextState2.default(new _CanvasDrawingStylesWebgl2D2.default());\n                this[_stateStack].push(state);\n            }\n            return this[_stateStack][this[_stateStack].length - 1];\n        }\n    }, {\n        key: \"currentPath\",\n        get: function get() {\n            if (this[_pathList].length == 0) {\n                this[_pathList].push(new _Path3D2.default());\n            }\n            return this[_pathList][this[_pathList].length - 1];\n        }\n    }, {\n        key: \"renderActionList\",\n        get: function get() {\n            return this[_renderActionList];\n        }\n\n        /**************** 下面是标准接口实现 *************************/\n\n        /**\r\n         * back-reference to the canvas\r\n         * Canvas的回引用\r\n         * @returns {canvas}\r\n         */\n\n    }, {\n        key: \"canvas\",\n        get: function get() {\n            return this[_canvas];\n        }\n    }, {\n        key: \"strokeStyle\",\n        set: function set(stroke) {\n            this.currentContextState.strokeStyle = stroke;\n        },\n        get: function get() {\n            return this.currentContextState.strokeStyle;\n        }\n    }, {\n        key: \"cameraPosition\",\n        get: function get() {\n            return this.webglRender.cameraPosition;\n        }\n    }, {\n        key: \"lookAtTarget\",\n        get: function get() {\n            return this.webglRender.lookTarget;\n        }\n    }, {\n        key: \"currentFaceVector\",\n        get: function get() {\n            var m = this.currentContextState.transformMatrix;\n            _Mat2.default.mat4ToMat3(m, TEMP_TRANFORM_MAT3);\n            _Mat4.default.multiplyWithVertex(this.currentFaceNormal, TEMP_TRANFORM_MAT3, this.originalFaceNormal);\n            return this.currentFaceNormal;\n        }\n    }, {\n        key: \"fontWeight\",\n        get: function get() {\n            return this.currentContextState.canvasDrawingStyle.fontWeight;\n        },\n        set: function set(v) {\n            this.currentContextState.canvasDrawingStyle.fontWeight = v;\n        }\n    }, {\n        key: \"fontStyle\",\n        get: function get() {\n            return this.currentContextState.canvasDrawingStyle.fontStyle;\n        },\n        set: function set(v) {\n            this.currentContextState.canvasDrawingStyle.fontStyle = v;\n        }\n    }, {\n        key: \"fontFamily\",\n        get: function get() {\n            return this.currentContextState.canvasDrawingStyle.fontFamily;\n        },\n        set: function set(font) {\n            this.currentContextState.canvasDrawingStyle.fontFamily = font;\n        }\n    }, {\n        key: \"fontSize\",\n        get: function get() {\n            return this.currentContextState.canvasDrawingStyle.fontSize;\n        },\n        set: function set(size) {\n            this.currentContextState.canvasDrawingStyle.fontSize = size;\n        }\n    }, {\n        key: \"fillStyle\",\n        set: function set(fill) {\n            this.currentContextState.fillStyle = fill;\n        },\n        get: function get() {\n            return this.currentContextState.fillStyle;\n        }\n    }, {\n        key: \"globalAlpha\",\n        set: function set(alpha) {\n            this.currentContextState.globalAlpha = alpha;\n        },\n        get: function get() {\n            return this.currentContextState.globalAlpha;\n        }\n\n        /**\r\n         * set stroke lineWidth\r\n         * 设置stroke时的线宽度\r\n         * @param lineWidth\r\n         */\n\n    }, {\n        key: \"lineWidth\",\n        set: function set(lineWidth) {\n            this.currentContextState.lineWidth = lineWidth;\n        },\n        get: function get() {\n            return this.currentContextState.lineWidth;\n        }\n    }, {\n        key: \"textAlign\",\n        get: function get() {\n            return this.currentContextState.textAlign;\n        },\n        set: function set(textAlign) {\n            this.currentContextState.textAlign = textAlign;\n        }\n    }, {\n        key: \"textBaseline\",\n        get: function get() {\n            return this.currentContextState.textBaseline;\n        },\n        set: function set(textBaseline) {\n            this.currentContextState.textBaseline = textBaseline;\n        }\n    }, {\n        key: \"filterType\",\n        get: function get() {\n            return this.currentContextState.filterType;\n        },\n        set: function set(filter) {\n            this.currentContextState.filterType = filter;\n        }\n    }], [{\n        key: \"Normal_Filter\",\n        get: function get() {\n            return _ContextState2.default.Normal_Filter;\n        }\n    }, {\n        key: \"GaussianBlur_Filter\",\n        get: function get() {\n            return _ContextState2.default.GaussianBlur_Filter;\n        }\n    }, {\n        key: \"Unsharpen_Filter\",\n        get: function get() {\n            return _ContextState2.default.Unsharpen_Filter;\n        }\n    }, {\n        key: \"Sharpness_Filter\",\n        get: function get() {\n            return _ContextState2.default.Sharpen_Filter;\n        }\n    }, {\n        key: \"Sharpen_Filter\",\n        get: function get() {\n            return _ContextState2.default.Sharpen_Filter;\n        }\n    }, {\n        key: \"EdgeDetect_Filter\",\n        get: function get() {\n            return _ContextState2.default.EdgeDetect_Filter;\n        }\n    }, {\n        key: \"SobelHorizontal_Filter\",\n        get: function get() {\n            return _ContextState2.default.SobelHorizontal_Filter;\n        }\n    }, {\n        key: \"SobelVertical_Filter\",\n        get: function get() {\n            return _ContextState2.default.SobelVertical_Filter;\n        }\n    }, {\n        key: \"PrevitHorizontal_Filter\",\n        get: function get() {\n            return _ContextState2.default.PrevitHorizontal_Filter;\n        }\n    }, {\n        key: \"PrevitVertical_Filter\",\n        get: function get() {\n            return _ContextState2.default.PrevitVertical_Filter;\n        }\n    }, {\n        key: \"BoxBlur_Filter\",\n        get: function get() {\n            return _ContextState2.default.BoxBlur_Filter;\n        }\n    }, {\n        key: \"TriangleBlur_Filter\",\n        get: function get() {\n            return _ContextState2.default.TriangleBlur_Filter;\n        }\n    }, {\n        key: \"Emboss_Filter\",\n        get: function get() {\n            return _ContextState2.default.Emboss_Filter;\n        }\n    }]);\n\n    return CanvasRenderingContextWebgl2D;\n}();\n\nexports.default = CanvasRenderingContextWebgl2D;\n\n//# sourceURL=webpack://tielifa/./build/webgl/CanvasRenderingContextWebgl2D.js?");

/***/ }),

/***/ "./build/webgl/ContextState.js":
/*!*************************************!*\
  !*** ./build/webgl/ContextState.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./build/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Normal_Filter = 0;\nvar GaussianBlur_Filter = 1;\nvar Unsharpen_Filter = 2;\nvar Sharpness_Filter = 3;\nvar Sharpen_Filter = 4;\nvar EdgeDetect_Filter = 5;\nvar SobelHorizontal_Filter = 6;\nvar SobelVertical_Filter = 7;\nvar PrevitHorizontal_Filter = 8;\nvar PrevitVertical_Filter = 9;\nvar BoxBlur_Filter = 10;\nvar TriangleBlur_Filter = 11;\nvar Emboss_Filter = 12;\n\nvar ContextState = function () {\n    function ContextState(canvasDrawingStyle) {\n        _classCallCheck(this, ContextState);\n\n        this.canvasDrawingStyle = canvasDrawingStyle;\n        this.matrixIndex = 0;\n        this.fillStyle = '#000000';\n        this.strokeStyle = '#000000';\n        this.globalAlpha = 1;\n        this.id = -1;\n        this.matrix = _Mat2.default.identity();\n        this.filterType = Normal_Filter;\n        this.dirty = false;\n        this.scaleValue = { x: 1, y: 1, z: 1 };\n    }\n\n    _createClass(ContextState, [{\n        key: \"setTransformMatrix\",\n        value: function setTransformMatrix(value) {\n            // let current = this.transformMatrix.matrix;\n            _Mat2.default.copy(value, this.matrix);\n        }\n    }, {\n        key: \"applyTransform\",\n        value: function applyTransform(currentTransformMatrix) {\n            var lastMatrix = this.matrix;\n            _Mat2.default.multiply(lastMatrix, lastMatrix, currentTransformMatrix);\n        }\n    }, {\n        key: \"translate\",\n        value: function translate(x, y, z) {\n            if (z === undefined) z = 0;\n            if (_Tools2.default.equals(x, 0) && _Tools2.default.equals(y, 0) && _Tools2.default.equals(z, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.translationMatrix(m, x, y, z);\n            this.applyTransform(m);\n        }\n\n        // 默然是按照z轴旋转\n\n    }, {\n        key: \"rotateZ\",\n        value: function rotateZ(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationZMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateX\",\n        value: function rotateX(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationXMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"rotateY\",\n        value: function rotateY(radian) {\n            if (_Tools2.default.equals(radian, 0)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.rotationYMatrix(m, radian);\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"scale\",\n        value: function scale(scaleX, scaleY, scaleZ) {\n            if (scaleZ === undefined) scaleZ = 1;\n            if (_Tools2.default.equals(scaleX, 1) && _Tools2.default.equals(scaleY, 1) && _Tools2.default.equals(scaleZ, 1)) {\n                return;\n            }\n            var m = _Mat2.default.TEMP_MAT4[0];\n            _Mat2.default.scalingMatrix(m, scaleX, scaleY, scaleZ);\n            this.scaleValue.x *= scaleX;\n            this.scaleValue.y *= scaleY;\n            this.scaleValue.z *= scaleZ;\n            this.applyTransform(m);\n        }\n    }, {\n        key: \"clone\",\n        value: function clone() {\n            var newState = new ContextState(this.canvasDrawingStyle.clone());\n            newState.fillStyle = this.fillStyle;\n            newState.strokeStyle = this.strokeStyle;\n            newState.globalAlpha = this.globalAlpha;\n            newState.filterType = this.filterType;\n            newState.scaleValue.x = this.scaleValue.x;\n            newState.scaleValue.y = this.scaleValue.y;\n            newState.scaleValue.z = this.scaleValue.z;\n\n            // newState.matrixIndex = this.matrixIndex;\n            // 把当前的矩阵作为新矩阵的最后一个\n            newState.setTransformMatrix(this.transformMatrix);\n            return newState;\n        }\n    }, {\n        key: \"transformMatrixId\",\n\n\n        /**@deprecated*/\n        get: function get() {\n            return ContextState.matrixList.length - 1;\n        }\n    }, {\n        key: \"transformMatrix\",\n        get: function get() {\n            return this.matrix;\n            // let index = ContextState.matrixList.length - 1;\n            // let m = ContextState.matrixList[index];\n            // return {matrix: m, id: index};\n        }\n    }, {\n        key: \"lineWidth\",\n        get: function get() {\n            return this.canvasDrawingStyle.lineWidth;\n        },\n        set: function set(width) {\n            this.canvasDrawingStyle.lineWidth = width;\n        }\n    }, {\n        key: \"textAlign\",\n        get: function get() {\n            return this.canvasDrawingStyle.textAlign;\n        },\n        set: function set(textAlign) {\n            this.canvasDrawingStyle.textAlign = textAlign;\n        }\n    }, {\n        key: \"textBaseline\",\n        get: function get() {\n            return this.canvasDrawingStyle.textBaseline;\n        },\n        set: function set(textBaseline) {\n            this.canvasDrawingStyle.textBaseline = textBaseline;\n        }\n    }], [{\n        key: \"Normal_Filter\",\n        get: function get() {\n            return Normal_Filter;\n        }\n    }, {\n        key: \"GaussianBlur_Filter\",\n        get: function get() {\n            return GaussianBlur_Filter;\n        }\n    }, {\n        key: \"Unsharpen_Filter\",\n        get: function get() {\n            return Unsharpen_Filter;\n        }\n    }, {\n        key: \"Sharpness_Filter\",\n        get: function get() {\n            return Sharpen_Filter;\n        }\n    }, {\n        key: \"Sharpen_Filter\",\n        get: function get() {\n            return Sharpen_Filter;\n        }\n    }, {\n        key: \"EdgeDetect_Filter\",\n        get: function get() {\n            return EdgeDetect_Filter;\n        }\n    }, {\n        key: \"SobelHorizontal_Filter\",\n        get: function get() {\n            return SobelHorizontal_Filter;\n        }\n    }, {\n        key: \"SobelVertical_Filter\",\n        get: function get() {\n            return SobelVertical_Filter;\n        }\n    }, {\n        key: \"PrevitHorizontal_Filter\",\n        get: function get() {\n            return PrevitHorizontal_Filter;\n        }\n    }, {\n        key: \"PrevitVertical_Filter\",\n        get: function get() {\n            return PrevitVertical_Filter;\n        }\n    }, {\n        key: \"BoxBlur_Filter\",\n        get: function get() {\n            return BoxBlur_Filter;\n        }\n    }, {\n        key: \"TriangleBlur_Filter\",\n        get: function get() {\n            return TriangleBlur_Filter;\n        }\n    }, {\n        key: \"Emboss_Filter\",\n        get: function get() {\n            return Emboss_Filter;\n        }\n    }]);\n\n    return ContextState;\n}();\n\nexports.default = ContextState;\n\n//# sourceURL=webpack://tielifa/./build/webgl/ContextState.js?");

/***/ }),

/***/ "./build/webgl/FragmentData.js":
/*!*************************************!*\
  !*** ./build/webgl/FragmentData.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _Tools = __webpack_require__(/*! ../utils/Tools.js */ \"./build/utils/Tools.js\");\n\nvar _Tools2 = _interopRequireDefault(_Tools);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SINGLE_DATA_BYTE_LENGTH = 16;\n/**\r\n * 0-2 分别是3位uint8类型的颜色数据\r\n * 3-6: 1位float32的alpha值\r\n * 7-14：两位float32的贴图坐标值\r\n * 15：int8类型的贴图索引值\r\n */\n\nvar FragmentData = function () {\n    function FragmentData(verticesNum) {\n        _classCallCheck(this, FragmentData);\n\n        this.buffer = new ArrayBuffer(verticesNum * SINGLE_DATA_BYTE_LENGTH);\n        this.dv = new DataView(this.buffer);\n        this.currentIndex = 0;\n        this.isLittleEndian = _Tools2.default.littleEndian;\n    }\n\n    _createClass(FragmentData, [{\n        key: \"setFragmentData\",\n        value: function setFragmentData(r, g, b, alpha, u, v, textureIndex, filterType, index) {\n            var num = index + 1;\n            if (num * SINGLE_DATA_BYTE_LENGTH >= this.totalByteLength) {\n                var length = Math.max(num * SINGLE_DATA_BYTE_LENGTH, this.totalByteLength * 2);\n                this.increaseSize(length);\n            }\n            index = index * this.singleDataByteLength;\n            this.dv.setUint8(index, r);\n            this.dv.setUint8(index + 1, g);\n            this.dv.setUint8(index + 2, b);\n            this.dv.setUint8(index + 3, filterType);\n            index += 4;\n\n            this.dv.setFloat32(index, alpha, this.isLittleEndian);\n            this.dv.setFloat32(index + 4, u, this.isLittleEndian);\n            this.dv.setFloat32(index + 8, v, this.isLittleEndian);\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            this.currentIndex = 0;\n        }\n    }, {\n        key: \"increaseSize\",\n        value: function increaseSize(length) {\n            if (length <= this.totalByteLength) {\n                return;\n            }\n            this.resize(length);\n        }\n    }, {\n        key: \"resize\",\n        value: function resize(length) {\n            var oldBuffer = this.buffer;\n            this.buffer = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this.buffer);\n            if (length < oldBuffer.byteLength) {\n                for (var i = 0; i < length; i++) {\n                    ndv[i] = dv1[i];\n                }\n            } else {\n                ndv.set(dv1, 0);\n            }\n            this.dv = new DataView(this.buffer);\n        }\n    }, {\n        key: \"append\",\n        value: function append(fragmentData) {\n            var vertexNum = this.currentIndex;\n            var len = fragmentData.currentIndex * fragmentData.singleDataByteLength;\n            if (len === 0) return;\n            this.increaseSize(len + vertexNum * SINGLE_DATA_BYTE_LENGTH);\n            var dv1 = new Uint8Array(fragmentData.buffer);\n            var ndv = new Uint8Array(this.buffer);\n            var offset = vertexNum * SINGLE_DATA_BYTE_LENGTH;\n            for (var i = 0; i < len; i++) {\n                ndv[i + offset] = dv1[i];\n            }\n            this.currentIndex += fragmentData.currentIndex;\n        }\n    }, {\n        key: \"addFragmentData\",\n        value: function addFragmentData(r, g, b, alpha, u, v, textureIndex, filterType) {\n            var index = this.currentIndex;\n            this.setFragmentData(r, g, b, alpha, u, v, textureIndex, filterType, index);\n            this.currentIndex++;\n        }\n    }, {\n        key: \"copyFrom\",\n        value: function copyFrom(fragmentData) {\n            var myLen = this.totalByteLength;\n            var len = fragmentData.currentIndex * fragmentData.singleDataByteLength;\n            if (myLen < len) {\n                this.buffer = new ArrayBuffer(len);\n                this.dv = new DataView(this.buffer);\n            }\n            var ndv = new Uint8Array(this.buffer);\n            var fdv = new Uint8Array(fragmentData.buffer);\n            for (var i = 0; i < len; i++) {\n                ndv[i] = fdv[i];\n            }\n            this.currentIndex = fragmentData.currentIndex;\n        }\n    }, {\n        key: \"fixLength\",\n        value: function fixLength() {\n            var realByteLength = this.currentIndex * SINGLE_DATA_BYTE_LENGTH;\n            if (realByteLength < this.buffer.byteLength) {\n                this.resize(realByteLength);\n            }\n        }\n    }, {\n        key: \"totalByteLength\",\n        get: function get() {\n            return this.buffer.byteLength;\n        }\n    }, {\n        key: \"singleDataByteLength\",\n        get: function get() {\n            return SINGLE_DATA_BYTE_LENGTH;\n        }\n    }]);\n\n    return FragmentData;\n}();\n\nexports.default = FragmentData;\n\n//# sourceURL=webpack://tielifa/./build/webgl/FragmentData.js?");

/***/ }),

/***/ "./build/webgl/IndexData.js":
/*!**********************************!*\
  !*** ./build/webgl/IndexData.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _currentIndex = Symbol('当前顶点游标位置');\nvar _dataArray = Symbol('Int16的typed数组');\nvar _arrayBuffer = Symbol('存储顶点数组的buffer');\nvar SINGLE_DATA_BYTE_LENGTH = 2;\n\nvar IndexData = function () {\n    function IndexData(vertexNumber) {\n        _classCallCheck(this, IndexData);\n\n        this[_arrayBuffer] = new ArrayBuffer(vertexNumber * 2);\n        this[_dataArray] = new Uint16Array(this[_arrayBuffer]);\n        this[_currentIndex] = 0;\n    }\n\n    _createClass(IndexData, [{\n        key: 'init',\n        value: function init() {\n            this[_currentIndex] = 0;\n        }\n    }, {\n        key: 'setIndex',\n        value: function setIndex(indexData, index) {\n            var num = index + 1;\n            if (num * 2 >= this.totalByteLength) {\n                var length = Math.max(num * 2, this.totalByteLength * 2);\n                this.increaseSize(length);\n            }\n            this[_dataArray][index] = indexData;\n        }\n    }, {\n        key: 'getIndex',\n        value: function getIndex(index) {\n            return this[_dataArray][index];\n        }\n    }, {\n        key: 'addIndex',\n        value: function addIndex(indexData) {\n            var index = this[_currentIndex];\n            this.setIndex(indexData, index);\n            this[_currentIndex]++;\n        }\n    }, {\n        key: 'increaseSize',\n        value: function increaseSize(length) {\n            if (length <= this.totalByteLength) {\n                return;\n            }\n            this.resize(length);\n        }\n    }, {\n        key: 'resize',\n        value: function resize(length) {\n            var oldBuffer = this[_arrayBuffer];\n            this[_arrayBuffer] = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            if (length < oldBuffer.byteLength) {\n                for (var i = 0; i < length; i++) {\n                    ndv[i] = dv1[i];\n                }\n            } else {\n                ndv.set(dv1, 0);\n            }\n            this[_dataArray] = new Uint16Array(this[_arrayBuffer]);\n        }\n    }, {\n        key: 'append',\n        value: function append(indexData) {\n            // let vertexNum = this.currentIndex;\n            // let len = indexData.totalByteLength;\n            // this.increaseSize(len + vertexNum * SINGLE_DATA_BYTE_LENGTH);\n            // let dv1 = new Uint8Array(indexData.buffer);\n            // let ndv = new Uint8Array(this.buffer);\n            // ndv.set(dv1, vertexNum * SINGLE_DATA_BYTE_LENGTH);\n            // this[_currentIndex] += indexData.currentIndex;\n\n            var vertexNum = this.currentIndex;\n            var len = indexData.currentIndex * indexData.singleDataByteLength;\n            if (len === 0) return;\n            this.increaseSize(len + vertexNum * SINGLE_DATA_BYTE_LENGTH);\n            var dv1 = new Uint8Array(indexData.buffer);\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            var offset = vertexNum * SINGLE_DATA_BYTE_LENGTH;\n            for (var i = 0; i < len; i++) {\n                ndv[i + offset] = dv1[i];\n            }\n            this[_currentIndex] += indexData.currentIndex;\n        }\n    }, {\n        key: 'copyFrom',\n        value: function copyFrom(indexData) {\n            var myLen = this.totalByteLength;\n            var len = indexData.currentIndex * indexData.singleDataByteLength;\n            if (myLen < len) {\n                this[_arrayBuffer] = new ArrayBuffer(len);\n                this[_dataArray] = new Uint16Array(this[_arrayBuffer]);\n            }\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            var fdv = new Uint8Array(indexData.buffer);\n            for (var i = 0; i < len; i++) {\n                ndv[i] = fdv[i];\n            }\n            this[_currentIndex] = indexData.currentIndex;\n        }\n    }, {\n        key: 'fixLength',\n        value: function fixLength() {\n            var realByteLength = this.currentIndex * SINGLE_DATA_BYTE_LENGTH;\n            if (realByteLength < this.buffer.byteLength) {\n                this.resize(realByteLength);\n            }\n        }\n    }, {\n        key: 'dataArray',\n        get: function get() {\n            return this[_dataArray];\n        }\n    }, {\n        key: 'singleDataByteLength',\n        get: function get() {\n            return SINGLE_DATA_BYTE_LENGTH;\n        }\n    }, {\n        key: 'totalByteLength',\n        get: function get() {\n            return this[_arrayBuffer].byteLength;\n        }\n    }, {\n        key: 'buffer',\n        get: function get() {\n            return this[_arrayBuffer];\n        }\n    }, {\n        key: 'currentIndex',\n        get: function get() {\n            return this[_currentIndex];\n        }\n    }]);\n\n    return IndexData;\n}();\n\nexports.default = IndexData;\n\n//# sourceURL=webpack://tielifa/./build/webgl/IndexData.js?");

/***/ }),

/***/ "./build/webgl/Path3D.js":
/*!*******************************!*\
  !*** ./build/webgl/Path3D.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Path3D = function () {\n    function Path3D() {\n        _classCallCheck(this, Path3D);\n\n        this.subPathArray = [];\n    }\n\n    _createClass(Path3D, [{\n        key: \"addSubPath\",\n        value: function addSubPath(subPath) {\n            this.subPathArray.push(subPath);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean() {\n            this.subPathArray = [];\n        }\n    }, {\n        key: \"subPathNumber\",\n        get: function get() {\n            return this.subPathArray.length;\n        }\n    }, {\n        key: \"lastSubPath\",\n        get: function get() {\n            if (this.subPathNumber != 0) {\n                return this.subPathArray[this.subPathNumber - 1];\n            }\n        }\n    }]);\n\n    return Path3D;\n}();\n\nexports.default = Path3D;\n\n//# sourceURL=webpack://tielifa/./build/webgl/Path3D.js?");

/***/ }),

/***/ "./build/webgl/RenderAction.js":
/*!*************************************!*\
  !*** ./build/webgl/RenderAction.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _EarClipping = __webpack_require__(/*! ../geometry/EarClipping.js */ \"./build/geometry/EarClipping.js\");\n\nvar _EarClipping2 = _interopRequireDefault(_EarClipping);\n\nvar _LineToRectangle = __webpack_require__(/*! ../geometry/LineToRectangle.js */ \"./build/geometry/LineToRectangle.js\");\n\nvar _LineToRectangle2 = _interopRequireDefault(_LineToRectangle);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar ACTION_STROKE = 0; // stroke动作\nvar ACTION_FILL = 1; // fill动作\n\nvar TRIANGLE_ORG = [0, 1, 2];\nvar RECT_ORG = [0, 1, 2, 0, 2, 3];\n\nvar RenderAction = function () {\n    function RenderAction(type) {\n        _classCallCheck(this, RenderAction);\n\n        this.type = type;\n        this.textureIndex = -1;\n\n        this.vdo = null;\n\n        this.renderPointNumber = 0;\n        this.opacityPointNumber = 0;\n        this.applyMatrix = null;\n        this.applyColor = null;\n        this.applyOpacity = null;\n    }\n\n    _createClass(RenderAction, [{\n        key: \"collectVertexDataForStroke\",\n        value: function collectVertexDataForStroke(pathList, color, opacity, textureCoord, lineWidth, filterType, faceDirection, useOpacity) {\n            var _this = this;\n\n            var that = this;\n            if (useOpacity == null) useOpacity = false;\n            if (opacity < 1) {\n                useOpacity = true;\n            }\n            this.vdo.switch(useOpacity);\n            var outputInterface = {\n                setPoint: function setPoint(p, index) {\n                    that.vdo.setVerticesCoor2(p, index + outputInterface.offset);\n                },\n                addPoint: function addPoint(p) {\n                    that.vdo.addVerticesData3(p.x, p.y, p.z, faceDirection, color, opacity, textureCoord, -1, filterType);\n                }\n            };\n\n            var indexData = null;\n\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n\n                var _loop = function _loop(j) {\n                    var subPath = path.subPathArray[j];\n                    var vertexCount = subPath.pointsNumber;\n                    if (vertexCount < 2) return \"continue\";\n                    outputInterface.offset = _this.vdo.currentIndex;\n                    indexData = _this.vdo.currentIndexData;\n                    var pointsArray = subPath.pointsCoordinateArray;\n                    var inputInterface = {\n                        getX: function getX(index) {\n                            index = index * 3;\n                            return pointsArray[index];\n                        },\n                        getY: function getY(index) {\n                            index = index * 3;\n                            return pointsArray[index + 1];\n                        },\n                        getZ: function getZ(index) {\n                            index = index * 3;\n                            return pointsArray[index + 2];\n                        },\n                        getPointsNum: function getPointsNum() {\n                            return pointsArray.length / 3;\n                        }\n                    };\n                    var lineNum = _LineToRectangle2.default.generateRectanglesPoints(lineWidth, subPath.isClosed, faceDirection, outputInterface, inputInterface);\n                    for (var k = 0; k < lineNum; k++) {\n                        var index = k * 4;\n                        indexData.addIndex(outputInterface.offset + index);\n                        indexData.addIndex(outputInterface.offset + index + 1);\n                        indexData.addIndex(outputInterface.offset + index + 2);\n\n                        indexData.addIndex(outputInterface.offset + index + 2);\n                        indexData.addIndex(outputInterface.offset + index + 3);\n                        indexData.addIndex(outputInterface.offset + index);\n                    }\n                    if (!useOpacity) {\n                        _this.renderPointNumber += lineNum * 6;\n                    } else {\n                        _this.opacityPointNumber += lineNum * 6;\n                    }\n                };\n\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var _ret = _loop(j);\n\n                    if (_ret === \"continue\") continue;\n                }\n            }\n            this.vdo.switch(false);\n        }\n    }, {\n        key: \"collectVertexDataForFill\",\n        value: function collectVertexDataForFill(pathList, color, opacity, textureCoord, filterType, faceDirection, useOpacity) {\n            var indexData = null;\n            if (useOpacity == null) useOpacity = false;\n            if (opacity < 1) useOpacity = true;\n            this.vdo.switch(useOpacity);\n            for (var i = 0; i < pathList.length; i++) {\n                var path = pathList[i];\n                if (path.subPathNumber === 0) {\n                    continue;\n                }\n                for (var j = 0; j < path.subPathNumber; j++) {\n                    var subPath = path.subPathArray[j];\n                    if (subPath.pointsNumber < 3) continue; // 小于三个无法填充成一个面\n                    var vertexOrg = void 0;\n                    var pointArray = subPath.pointsCoordinateArray;\n                    var pointsNumber = subPath.pointsNumber;\n                    if (pointsNumber === 3) {\n                        vertexOrg = TRIANGLE_ORG;\n                    } else {\n                        if (pointsNumber === 4 && subPath.isRegularRect) {\n                            vertexOrg = RECT_ORG;\n                        } else {\n                            if (pointsNumber * 3 === pointArray.length) {\n                                vertexOrg = _EarClipping2.default.earcut(pointArray, null, 3);\n                            } else {\n                                var _temp = pointArray.slice(0, pointsNumber * 3);\n                                vertexOrg = _EarClipping2.default.earcut(_temp, null, 3);\n                            }\n                        }\n                    }\n                    if (!useOpacity) {\n                        this.renderPointNumber += vertexOrg.length;\n                    } else {\n                        this.opacityPointNumber += vertexOrg.length;\n                    }\n\n                    if (vertexOrg.length === 0) continue;\n                    // let offset = this.verticesData.currentIndex;\n                    var offset = this.vdo.currentIndex;\n                    indexData = this.vdo.currentIndexData;\n                    var k = void 0;\n                    for (k = 0; k < pointsNumber; k++) {\n                        var UV = undefined;\n                        if (textureCoord[0] instanceof Array) {\n                            UV = textureCoord[k];\n                        } else {\n                            UV = textureCoord;\n                        }\n\n                        this.vdo.addVerticesData3(subPath.getPointX(k), subPath.getPointY(k), subPath.getPointZ(k), faceDirection, color, opacity, UV, this.textureIndex, filterType);\n\n                        var vertexIndex = vertexOrg[k];\n                        indexData.addIndex(vertexIndex + offset);\n                    }\n\n                    var temp = k;\n                    for (var _k = temp; _k < vertexOrg.length; _k++) {\n                        var _vertexIndex = vertexOrg[_k];\n                        indexData.addIndex(_vertexIndex + offset);\n                    }\n                }\n            }\n            this.vdo.switch(false);\n        }\n    }], [{\n        key: \"ACTION_STROKE\",\n        get: function get() {\n            return ACTION_STROKE;\n        }\n    }, {\n        key: \"ACTION_FILL\",\n        get: function get() {\n            return ACTION_FILL;\n        }\n    }]);\n\n    return RenderAction;\n}();\n\nexports.default = RenderAction;\n\n//# sourceURL=webpack://tielifa/./build/webgl/RenderAction.js?");

/***/ }),

/***/ "./build/webgl/SubPath3D.js":
/*!**********************************!*\
  !*** ./build/webgl/SubPath3D.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _currentIndex = Symbol('当前的点所在的索引位置');\nvar _pointsCoordinateArray = Symbol('点的坐标值数组,每三个为一组，分别是x,y,z');\nvar _pointsTransformMatrixArray = Symbol('点的坐标值数组，每两个为一组，分别是stateId,matrixId');\n\nvar SubPath3D = function () {\n    function SubPath3D() {\n        _classCallCheck(this, SubPath3D);\n\n        // this.pointsArray = [];\n        this[_currentIndex] = 0;\n        this[_pointsCoordinateArray] = [];\n        this[_pointsTransformMatrixArray] = [];\n        // if (startPoint != undefined && startPoint != null) {\n        //     this.pushPoint(startPoint);\n        // }\n        this.isClosed = false;\n        this.isRegularRect = false;\n    }\n\n    _createClass(SubPath3D, [{\n        key: 'init',\n        value: function init() {\n            this.isClosed = false;\n            this[_currentIndex] = 0;\n        }\n    }, {\n        key: 'getPointX',\n        value: function getPointX(index) {\n            index = index * 3;\n            return this[_pointsCoordinateArray][index];\n        }\n    }, {\n        key: 'getPointY',\n        value: function getPointY(index) {\n            index = index * 3;\n            return this[_pointsCoordinateArray][index + 1];\n        }\n    }, {\n        key: 'getPointZ',\n        value: function getPointZ(index) {\n            index = index * 3;\n            return this[_pointsCoordinateArray][index + 2];\n        }\n    }, {\n        key: 'getPointStateId',\n        value: function getPointStateId(index) {\n            index = index * 2;\n            return this[_pointsTransformMatrixArray][index];\n        }\n    }, {\n        key: 'getPointMatrixId',\n        value: function getPointMatrixId(index) {\n            index = index * 2;\n            return this[_pointsTransformMatrixArray][index + 1];\n        }\n    }, {\n        key: 'getPointMatrixData',\n        value: function getPointMatrixData(index) {\n            return [this.getPointStateId(index), this.getPointMatrixId(index)];\n        }\n    }, {\n        key: 'setPoint',\n        value: function setPoint(index, x, y, z, stateId) {\n            stateId = stateId || 0;\n            // matrixId = matrixId || 0;\n            var sIndex = index * 2;\n            index = index * 3;\n            this[_pointsCoordinateArray][index] = x;\n            this[_pointsCoordinateArray][index + 1] = y;\n            this[_pointsCoordinateArray][index + 2] = z;\n            // this[_pointsTransformMatrixArray][sIndex] = stateId;\n            // this[_pointsTransformMatrixArray][sIndex + 1] = matrixId;\n        }\n    }, {\n        key: 'addPoint',\n        value: function addPoint(x, y, z, stateId) {\n            // matrixId = matrixId || 0;\n            var index = this[_currentIndex];\n            if (index * 3 >= this[_pointsCoordinateArray].length) {\n                this[_pointsCoordinateArray].push(x);\n                this[_pointsCoordinateArray].push(y);\n                this[_pointsCoordinateArray].push(z);\n            } else {\n                this[_pointsCoordinateArray][index] = x;\n                this[_pointsCoordinateArray][index + 1] = y;\n                this[_pointsCoordinateArray][index + 2] = z;\n            }\n            // if (index * 2 >= this[_pointsTransformMatrixArray].length) {\n            //     this[_pointsTransformMatrixArray].push(stateId);\n            //     this[_pointsTransformMatrixArray].push(matrixId);\n            // } else {\n            //     this[_pointsTransformMatrixArray][index] = stateId;\n            //     this[_pointsTransformMatrixArray][index + 1] = matrixId;\n            // }\n            this[_currentIndex]++;\n        }\n    }, {\n        key: 'close',\n        value: function close() {\n            this.isClosed = true;\n        }\n\n        // /**\n        //  * @deprecated\n        //  * @param index\n        //  * @returns {*}\n        //  */\n        // getPoint(index) {\n        //     return this.pointsArray[index];\n        // }\n\n\n    }, {\n        key: 'clean',\n        value: function clean() {\n            this[_pointsCoordinateArray] = [];\n            this[_pointsTransformMatrixArray] = [];\n            this.isClosed = false;\n        }\n    }, {\n        key: 'pointsCoordinateArray',\n        get: function get() {\n            return this[_pointsCoordinateArray];\n        }\n    }, {\n        key: 'pointsNumber',\n        get: function get() {\n            return this[_currentIndex];\n            // return this.pointsArray.length;\n        }\n    }]);\n\n    return SubPath3D;\n}();\n\nexports.default = SubPath3D;\n\n//# sourceURL=webpack://tielifa/./build/webgl/SubPath3D.js?");

/***/ }),

/***/ "./build/webgl/TransformMatrixData.js":
/*!********************************************!*\
  !*** ./build/webgl/TransformMatrixData.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _BaseBufferData2 = __webpack_require__(/*! ./BaseBufferData.js */ \"./build/webgl/BaseBufferData.js\");\n\nvar _BaseBufferData3 = _interopRequireDefault(_BaseBufferData2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar SINGLE_DATA_BYTE_LENGTH = 4;\n\nvar TransformMatrixData = function (_BaseBufferData) {\n    _inherits(TransformMatrixData, _BaseBufferData);\n\n    function TransformMatrixData(verticesNum) {\n        _classCallCheck(this, TransformMatrixData);\n\n        // 1位是float32类型，矩阵索引\n        return _possibleConstructorReturn(this, (TransformMatrixData.__proto__ || Object.getPrototypeOf(TransformMatrixData)).call(this, verticesNum, SINGLE_DATA_BYTE_LENGTH));\n    }\n\n    _createClass(TransformMatrixData, [{\n        key: \"setMatrixIndex\",\n        value: function setMatrixIndex(mIndex, index) {\n            this.setData(mIndex, index);\n        }\n    }, {\n        key: \"addMatrixIndex\",\n        value: function addMatrixIndex(mIndex) {\n            var index = this.currentIndex;\n            if (index * this.singleDataByteLength >= this.totalByteLength) {\n                this.resize(this.totalByteLength * 2);\n            }\n            this.setMatrixIndex(mIndex, index);\n            this.currentIndex++;\n        }\n    }, {\n        key: \"getMatrixIndex\",\n        value: function getMatrixIndex(index) {\n            return this.getData(index);\n        }\n    }]);\n\n    return TransformMatrixData;\n}(_BaseBufferData3.default);\n\nexports.default = TransformMatrixData;\n\n//# sourceURL=webpack://tielifa/./build/webgl/TransformMatrixData.js?");

/***/ }),

/***/ "./build/webgl/VDO.js":
/*!****************************!*\
  !*** ./build/webgl/VDO.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _VerticesData = __webpack_require__(/*! ./VerticesData.js */ \"./build/webgl/VerticesData.js\");\n\nvar _VerticesData2 = _interopRequireDefault(_VerticesData);\n\nvar _IndexData = __webpack_require__(/*! ./IndexData.js */ \"./build/webgl/IndexData.js\");\n\nvar _IndexData2 = _interopRequireDefault(_IndexData);\n\nvar _FragmentData = __webpack_require__(/*! ./FragmentData.js */ \"./build/webgl/FragmentData.js\");\n\nvar _FragmentData2 = _interopRequireDefault(_FragmentData);\n\nvar _TransformMatrixData = __webpack_require__(/*! ./TransformMatrixData.js */ \"./build/webgl/TransformMatrixData.js\");\n\nvar _TransformMatrixData2 = _interopRequireDefault(_TransformMatrixData);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar VDO = function () {\n    function VDO(maxVerticesNumber, indexNumber, lockSwitch) {\n        _classCallCheck(this, VDO);\n\n        if (indexNumber == null) indexNumber = maxVerticesNumber;\n        this.verticesData = new _VerticesData2.default(maxVerticesNumber);\n        this.indexData = new _IndexData2.default(indexNumber);\n        this.fragmentData = new _FragmentData2.default(maxVerticesNumber);\n        this.transformMatrixData = new _TransformMatrixData2.default(maxVerticesNumber);\n\n        this.opacityVerticesData = new _VerticesData2.default(maxVerticesNumber);\n        this.opacityIndexData = new _IndexData2.default(indexNumber);\n        this.opacityFragmentData = new _FragmentData2.default(maxVerticesNumber);\n        this.opacityTransformMatrixData = new _TransformMatrixData2.default(maxVerticesNumber);\n        this.useOpacityBuffer = false;\n        this.lockSwitch = lockSwitch;\n        if (this.lockSwitch == null) this.lockSwitch = false;\n    }\n\n    _createClass(VDO, [{\n        key: \"switch\",\n        value: function _switch(useOpacityBuffer) {\n            if (this.lockSwitch) return;\n            this.useOpacityBuffer = useOpacityBuffer;\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            this.verticesData.init();\n            this.fragmentData.init();\n            this.transformMatrixData.init();\n            this.indexData.init();\n\n            this.opacityVerticesData.init();\n            this.opacityFragmentData.init();\n            this.opacityTransformMatrixData.init();\n            this.opacityIndexData.init();\n        }\n    }, {\n        key: \"_addVerticesFragmentData\",\n        value: function _addVerticesFragmentData(x, y, z, nx, ny, nz, r, g, b, a, u, v, ti, ft) {\n            // this.switch(a < 1);\n            var vd = this.currentVerticesData;\n            var fd = this.currentFragmentData;\n            var index = vd.currentIndex;\n            vd.addVerticesData(x, y, z, nx, ny, nz);\n            fd.addFragmentData(r, g, b, a, u, v, ti, ft);\n            return index;\n        }\n    }, {\n        key: \"addIndex\",\n        value: function addIndex(index) {\n            var indexData = this.indexData;\n            if (this.useOpacityBuffer) {\n                indexData = this.opacityIndexData;\n            }\n            indexData.addIndex(index);\n        }\n    }, {\n        key: \"addVerticesData\",\n        value: function addVerticesData(coords, normal, color, opacity, uv, textureIndex, filterType) {\n            return this._addVerticesFragmentData(coords[0], coords[1], coords[2], normal[0], normal[1], normal[2], color[0], color[1], color[2], opacity, uv[0], uv[1], textureIndex, filterType);\n        }\n    }, {\n        key: \"addVerticesData2\",\n        value: function addVerticesData2(coords, normal, color, opacity, uv, textureIndex, filterType) {\n            return this._addVerticesFragmentData(coords.x, coords.y, coords.z, normal.x, normal.y, normal.z, color[0], color[1], color[2], opacity, uv[0], uv[1], textureIndex, filterType);\n        }\n    }, {\n        key: \"addVerticesData3\",\n        value: function addVerticesData3(x, y, z, normal, color, opacity, uv, textureIndex, filterType) {\n            return this._addVerticesFragmentData(x, y, z, normal[0], normal[1], normal[2], color[0], color[1], color[2], opacity, uv[0], uv[1], textureIndex, filterType);\n        }\n    }, {\n        key: \"addVerticesData4\",\n        value: function addVerticesData4(x, y, z, nx, ny, nz, color, opacity, uv, textureIndex, filterType) {\n            return this._addVerticesFragmentData(x, y, z, nx, ny, nz, color[0], color[1], color[2], opacity, uv[0], uv[1], textureIndex, filterType);\n        }\n    }, {\n        key: \"setVerticesCoor\",\n        value: function setVerticesCoor(coords, index) {\n            var vd = this.currentVerticesData;\n            vd.setVerticesCoor(coords[0], coords[1], coords[2], index);\n        }\n    }, {\n        key: \"setVerticesCoor2\",\n        value: function setVerticesCoor2(coords, index) {\n            var vd = this.currentVerticesData;\n            vd.setVerticesCoor(coords.x, coords.y, coords.z, index);\n        }\n    }, {\n        key: \"setVerticesCoor3\",\n        value: function setVerticesCoor3(x, y, z, index) {\n            var vd = this.currentVerticesData;\n            vd.setVerticesCoor(x, y, z, index);\n        }\n    }, {\n        key: \"fixLength\",\n        value: function fixLength() {\n            this.verticesData.fixLength();\n            this.fragmentData.fixLength();\n            this.indexData.fixLength();\n\n            this.opacityIndexData.fixLength();\n            this.opacityFragmentData.fixLength();\n            this.opacityVerticesData.fixLength();\n        }\n    }, {\n        key: \"currentIndexData\",\n        get: function get() {\n            if (this.useOpacityBuffer) {\n                return this.opacityIndexData;\n            } else {\n                return this.indexData;\n            }\n        }\n    }, {\n        key: \"currentVerticesData\",\n        get: function get() {\n            if (this.useOpacityBuffer) {\n                return this.opacityVerticesData;\n            } else {\n                return this.verticesData;\n            }\n        }\n    }, {\n        key: \"currentFragmentData\",\n        get: function get() {\n            if (this.useOpacityBuffer) {\n                return this.opacityFragmentData;\n            } else {\n                return this.fragmentData;\n            }\n        }\n    }, {\n        key: \"currentIndex\",\n        get: function get() {\n            if (this.useOpacityBuffer) {\n                return this.opacityCurrentIndex;\n            } else {\n                return this.originalCurrentIndex;\n            }\n        }\n    }, {\n        key: \"originalCurrentIndex\",\n        get: function get() {\n            return this.verticesData.currentIndex;\n        }\n    }, {\n        key: \"opacityCurrentIndex\",\n        get: function get() {\n            return this.opacityVerticesData.currentIndex;\n        }\n    }]);\n\n    return VDO;\n}();\n\nexports.default = VDO;\n\n//# sourceURL=webpack://tielifa/./build/webgl/VDO.js?");

/***/ }),

/***/ "./build/webgl/VerticesData.js":
/*!*************************************!*\
  !*** ./build/webgl/VerticesData.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _currentIndex = Symbol('当前顶点游标位置');\nvar _dataArray = Symbol('Float32的typed数组');\nvar _arrayBuffer = Symbol('存储顶点数组的buffer');\nvar SINGLE_DATA_BYTE_LENGTH = 32;\n\nvar VerticesData = function () {\n    function VerticesData(verticesNum) {\n        _classCallCheck(this, VerticesData);\n\n        this[_arrayBuffer] = new ArrayBuffer(verticesNum * 4 * 2 * 4);\n        this[_dataArray] = new Float32Array(this[_arrayBuffer]);\n        this[_currentIndex] = 0;\n    }\n\n    _createClass(VerticesData, [{\n        key: 'init',\n        value: function init() {\n            this[_currentIndex] = 0;\n        }\n    }, {\n        key: 'setVerticesData',\n        value: function setVerticesData(x, y, z, nx, ny, nz, index) {\n            var num = index + 1;\n            index = index * 8;\n            if (num * SINGLE_DATA_BYTE_LENGTH >= this.totalByteLength) {\n                var length = Math.max(num * SINGLE_DATA_BYTE_LENGTH, this.totalByteLength * 2);\n                this.increaseSize(length);\n            }\n            this[_dataArray][index] = x;\n            this[_dataArray][index + 1] = y;\n            this[_dataArray][index + 2] = z;\n\n            this[_dataArray][index + 4] = nx;\n            this[_dataArray][index + 5] = ny;\n            this[_dataArray][index + 6] = nz;\n        }\n    }, {\n        key: 'setVerticesCoor',\n        value: function setVerticesCoor(x, y, z, index) {\n            var num = index + 1;\n            index = index * 8;\n            if (num * SINGLE_DATA_BYTE_LENGTH >= this.totalByteLength) {\n                var length = Math.max(num * SINGLE_DATA_BYTE_LENGTH, this.totalByteLength * 2);\n                this.increaseSize(length);\n            }\n            this[_dataArray][index] = x;\n            this[_dataArray][index + 1] = y;\n            this[_dataArray][index + 2] = z;\n        }\n    }, {\n        key: 'getVerticesData',\n        value: function getVerticesData(index) {\n            index = index * 8;\n            var x = this[_dataArray][index];\n            var y = this[_dataArray][index + 1];\n            var z = this[_dataArray][index + 2];\n\n            var nx = this[_dataArray][index + 4];\n            var ny = this[_dataArray][index + 5];\n            var nz = this[_dataArray][index + 6];\n\n            return [x, y, z, nx, ny, nz];\n        }\n    }, {\n        key: 'getVerticesPositionData',\n        value: function getVerticesPositionData(index) {\n            index = index * 8;\n            var x = this[_dataArray][index];\n            var y = this[_dataArray][index + 1];\n            var z = this[_dataArray][index + 2];\n            return [x, y, z];\n        }\n    }, {\n        key: 'getVerticesPositionXData',\n        value: function getVerticesPositionXData(index) {\n            index = index * 8;\n            return this[_dataArray][index];\n        }\n    }, {\n        key: 'getVerticesPositionYData',\n        value: function getVerticesPositionYData(index) {\n            index = index * 8;\n            return this[_dataArray][index + 1];\n        }\n    }, {\n        key: 'getVerticesPositionZData',\n        value: function getVerticesPositionZData(index) {\n            index = index * 8;\n            return this[_dataArray][index + 2];\n        }\n    }, {\n        key: 'getVerticesNormalData',\n        value: function getVerticesNormalData(index) {\n            index = index * 8;\n            var nx = this[_dataArray][index + 4];\n            var ny = this[_dataArray][index + 5];\n            var nz = this[_dataArray][index + 6];\n            return [nx, ny, nz];\n        }\n    }, {\n        key: 'getVerticesNormalXData',\n        value: function getVerticesNormalXData(index) {\n            index = index * 8;\n            return this[_dataArray][index + 4];\n        }\n    }, {\n        key: 'getVerticesNormalYData',\n        value: function getVerticesNormalYData(index) {\n            index = index * 8;\n            return this[_dataArray][index + 5];\n        }\n    }, {\n        key: 'getVerticesNormalZData',\n        value: function getVerticesNormalZData(index) {\n            index = index * 8;\n            return this[_dataArray][index + 6];\n        }\n    }, {\n        key: 'addVerticesData',\n        value: function addVerticesData(x, y, z, nx, ny, nz) {\n            var index = this[_currentIndex];\n            this.setVerticesData(x, y, z, nx, ny, nz, index);\n            this[_currentIndex]++;\n        }\n    }, {\n        key: 'increaseSize',\n        value: function increaseSize(length) {\n            if (length === 0) return;\n            if (length <= this.totalByteLength) {\n                return;\n            }\n            this.resize(length);\n        }\n    }, {\n        key: 'resize',\n        value: function resize(length) {\n            var oldBuffer = this[_arrayBuffer];\n            this[_arrayBuffer] = new ArrayBuffer(length);\n            var dv1 = new Uint8Array(oldBuffer);\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            if (length < oldBuffer.byteLength) {\n                for (var i = 0; i < length; i++) {\n                    ndv[i] = dv1[i];\n                }\n            } else {\n                ndv.set(dv1, 0);\n            }\n\n            this[_dataArray] = new Float32Array(this[_arrayBuffer]);\n        }\n    }, {\n        key: 'append',\n        value: function append(verticesData) {\n            var vertexNum = this.currentIndex;\n            var len = verticesData.currentIndex * verticesData.singleDataByteLength;\n            if (len === 0) return;\n            this.increaseSize(len + vertexNum * SINGLE_DATA_BYTE_LENGTH);\n            var dv1 = new Uint8Array(verticesData.buffer);\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            var offset = vertexNum * SINGLE_DATA_BYTE_LENGTH;\n            for (var i = 0; i < len; i++) {\n                ndv[i + offset] = dv1[i];\n            }\n            this[_currentIndex] += verticesData.currentIndex;\n        }\n    }, {\n        key: 'copyFrom',\n        value: function copyFrom(verticesData) {\n            var myLen = this.totalByteLength;\n            var len = verticesData.currentIndex * verticesData.singleDataByteLength;\n            if (myLen < len) {\n                this[_arrayBuffer] = new ArrayBuffer(len);\n                this[_dataArray] = new Float32Array(this[_arrayBuffer]);\n            }\n            var ndv = new Uint8Array(this[_arrayBuffer]);\n            var fdv = new Uint8Array(verticesData.buffer);\n            for (var i = 0; i < len; i++) {\n                ndv[i] = fdv[i];\n            }\n            // ndv.set(fdv, 0);\n            this[_currentIndex] = verticesData.currentIndex;\n        }\n    }, {\n        key: 'fixLength',\n        value: function fixLength() {\n            var realByteLength = this.currentIndex * SINGLE_DATA_BYTE_LENGTH;\n            if (realByteLength < this.buffer.byteLength) {\n                this.resize(realByteLength);\n            }\n        }\n    }, {\n        key: 'singleDataByteLength',\n        get: function get() {\n            return SINGLE_DATA_BYTE_LENGTH;\n        }\n    }, {\n        key: 'totalByteLength',\n        get: function get() {\n            return this[_arrayBuffer].byteLength;\n        }\n    }, {\n        key: 'buffer',\n        get: function get() {\n            return this[_arrayBuffer];\n        }\n    }, {\n        key: 'currentIndex',\n        get: function get() {\n            return this[_currentIndex];\n        }\n    }]);\n\n    return VerticesData;\n}();\n\nexports.default = VerticesData;\n\n//# sourceURL=webpack://tielifa/./build/webgl/VerticesData.js?");

/***/ }),

/***/ "./build/webgl/WebGLRender.js":
/*!************************************!*\
  !*** ./build/webgl/WebGLRender.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _TextureManager = __webpack_require__(/*! ../texture/TextureManager.js */ \"./build/texture/TextureManager.js\");\n\nvar _TextureManager2 = _interopRequireDefault(_TextureManager);\n\nvar _Mat = __webpack_require__(/*! ../math/Mat4.js */ \"./build/math/Mat4.js\");\n\nvar _Mat2 = _interopRequireDefault(_Mat);\n\nvar _TempCanvas = __webpack_require__(/*! ../texture/TempCanvas.js */ \"./build/texture/TempCanvas.js\");\n\nvar _TempCanvas2 = _interopRequireDefault(_TempCanvas);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar fsSource = \"\\n  precision mediump float;\\n  varying vec4 currentColor;\\n  varying vec2 v_texcoord;\\n  varying vec3 normal;\\n  varying vec3 v_position;\\n  varying float v_filterType;\\n  uniform vec2 singleCanvas;\\n  uniform vec3 u_lightPosition;\\n  uniform float enableLight;\\n  uniform sampler2D u_texture;\\n  \\n  void getNormalFilter(inout float filter[9]){\\n        filter[0] = 0.0;\\n        filter[1] = 0.0;\\n        filter[2] = 0.0;\\n        filter[3] = 0.0;\\n        filter[4] = 1.0;\\n        filter[5] = 0.0;\\n        filter[6] = 0.0;\\n        filter[7] = 0.0;\\n        filter[8] = 0.0;\\n  }\\n  \\n  void getGaussianBlurFilter(inout float filter[9]){\\n        filter[0] = 0.045;\\n        filter[1] = 0.122;\\n        filter[2] = 0.045;\\n        filter[3] = 0.122;\\n        filter[4] = 0.332;\\n        filter[5] = 0.122;\\n        filter[6] = 0.045;\\n        filter[7] = 0.122;\\n        filter[8] = 0.045;\\n  }\\n  \\n  void getUnsharpenFilter(inout float filter[9]){\\n        filter[0] = -1.0;\\n        filter[1] = -1.0;\\n        filter[2] = -1.0;\\n        filter[3] = -1.0;\\n        filter[4] = 9.0;\\n        filter[5] = -1.0;\\n        filter[6] = -1.0;\\n        filter[7] = -1.0;\\n        filter[8] = -1.0;\\n  }\\n  \\n  void getSharpnessFilter(inout float filter[9]){\\n        filter[0] = 0.0;\\n        filter[1] = -1.0;\\n        filter[2] = 0.0;\\n        filter[3] = -1.0;\\n        filter[4] = 5.0;\\n        filter[5] = -1.0;\\n        filter[6] = 0.0;\\n        filter[7] = -1.0;\\n        filter[8] = 0.0;\\n  }\\n  \\n   void getSharpenFilter(inout float filter[9]){\\n        filter[0] = -0.125;\\n        filter[1] = -0.125;\\n        filter[2] = -0.125;\\n        filter[3] = -0.125;\\n        filter[4] =  2.0;\\n        filter[5] = -0.125;\\n        filter[6] = -0.125;\\n        filter[7] = -0.125;\\n        filter[8] = -0.125;\\n  }\\n  \\n  void getEdgeDetectFilter(inout float filter[9]){\\n        filter[0] = -5.0;\\n        filter[1] = -5.0;\\n        filter[2] = -5.0;\\n        filter[3] = -5.0;\\n        filter[4] =  39.0;\\n        filter[5] = -5.0;\\n        filter[6] = -5.0;\\n        filter[7] = -5.0;\\n        filter[8] = -5.0;\\n  }\\n  \\n  void getSobelHorizontalFilter(inout float filter[9]){\\n        filter[0] = 1.0;\\n        filter[1] = 2.0;\\n        filter[2] = 1.0;\\n        filter[3] = 0.0;\\n        filter[4] =  0.0;\\n        filter[5] = 0.0;\\n        filter[6] = -1.0;\\n        filter[7] = -2.0;\\n        filter[8] = -1.0;\\n  }\\n  \\n  void getSobelVerticalFilter(inout float filter[9]){\\n        filter[0] = 1.0;\\n        filter[1] = 0.0;\\n        filter[2] = -1.0;\\n        filter[3] = 2.0;\\n        filter[4] =  0.0;\\n        filter[5] = -2.0;\\n        filter[6] = 1.0;\\n        filter[7] = 0.0;\\n        filter[8] = -1.0;\\n  }\\n  \\n  void getPrevitHorizontalFilter(inout float filter[9]){\\n        filter[0] = 1.0;\\n        filter[1] = 1.0;\\n        filter[2] = 1.0;\\n        filter[3] = 0.0;\\n        filter[4] = 0.0;\\n        filter[5] = 0.0;\\n        filter[6] = -1.0;\\n        filter[7] = -1.0;\\n        filter[8] = -1.0;\\n  }\\n  \\n  void getPrevitVerticalFilter(inout float filter[9]){\\n        filter[0] = 1.0;\\n        filter[1] = 0.0;\\n        filter[2] = -1.0;\\n        filter[3] = 1.0;\\n        filter[4] = 0.0;\\n        filter[5] = -1.0;\\n        filter[6] = 1.0;\\n        filter[7] = 0.0;\\n        filter[8] = -1.0;\\n  }\\n  \\n  void getBoxBlurFilter(inout float filter[9]){\\n        filter[0] = 0.111;\\n        filter[1] = 0.111;\\n        filter[2] = 0.111;\\n        filter[3] = 0.111;\\n        filter[4] = 0.111;\\n        filter[5] = 0.111;\\n        filter[6] = 0.111;\\n        filter[7] = 0.111;\\n        filter[8] = 0.111;\\n  }\\n  \\n  void getTriangleBlurFilter(inout float filter[9]){\\n        filter[0] = 0.0625;\\n        filter[1] = 0.125;\\n        filter[2] = 0.0625;\\n        filter[3] = 0.125;\\n        filter[4] = 0.25;\\n        filter[5] = 0.125;\\n        filter[6] = 0.0625;\\n        filter[7] = 0.125;\\n        filter[8] = 0.0625;\\n  }\\n  \\n  void getEmbossFilter(inout float filter[9]){\\n        filter[0] = -2.0;\\n        filter[1] = -1.0;\\n        filter[2] = 0.0;\\n        filter[3] = -1.0;\\n        filter[4] = 1.0;\\n        filter[5] = 1.0;\\n        filter[6] = 0.0;\\n        filter[7] = 1.0;\\n        filter[8] = 2.0;\\n  }\\n  \\n  void filter3(in float kernel[9],in vec2 coord,in vec2 onePixel, inout vec4 colorSum){\\n        float offset = -1.0;\\n        for(float i = 0.0 ; i < 3.0;i++){\\n            for(float j =0.0;j < 3.0;j++){\\n                colorSum += texture2D(u_texture, coord + onePixel * vec2(offset + j, offset+ i)) * kernel[int(i*3.0+j)];\\n            }\\n        }\\n  }\\n  \\n  void filter5(in float kernel[25],in vec2 coord,in vec2 onePixel, inout vec4 colorSum){\\n        float offset = -2.0;\\n        for(float i = 0.0 ; i < 5.0;i++){\\n            for(float j =0.0;j < 5.0;j++){\\n                colorSum += texture2D(u_texture, coord + onePixel * vec2(offset + j, offset+ i)) * kernel[int(i*5.0+j)];\\n            }\\n        }\\n  }\\n  \\n  void main() {\\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\\n        vec2 onePixel = vec2(1.0/singleCanvas.x, 1.0/singleCanvas.y);\\n        vec4 color = currentColor;\\n        float opacity = texture2D(u_texture, coord).a * color.a;\\n        float kernel3[9];\\n        float kernel5[25];\\n        vec4 colorSum = vec4(0.0,0.0,0.0,0.0);\\n        \\n        if(int(v_filterType) == 0){\\n            getNormalFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 1){\\n            getGaussianBlurFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 2){\\n            getUnsharpenFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }\\n        else\\n        if(int(v_filterType) == 3){\\n            getSharpnessFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 4){\\n            getSharpenFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 5){\\n            getEdgeDetectFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 6){\\n            getSobelHorizontalFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 7){\\n            getSobelVerticalFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 8){\\n            getPrevitHorizontalFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 9){\\n            getPrevitVerticalFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 10){\\n            getBoxBlurFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 11){\\n            getTriangleBlurFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }else\\n        if(int(v_filterType) == 12){\\n            getEmbossFilter(kernel3);\\n            filter3(kernel3,coord,onePixel,colorSum);\\n        }\\n\\n        \\n        // colorSum.w = opacity;\\n        // colorSum = texture2D(u_texture, coord);\\n        vec3 r_normal = normalize(normal);    \\n        vec3 forward = u_lightPosition - v_position;\\n        // vec3 lightLocation = vec3(0.0,0.0,1.0); \\n        vec3 lightLocation = normalize(forward);    \\n        gl_FragColor = color * colorSum;//texture2D(u_texture, coord);\\n        gl_FragColor.a = opacity;\\n        float light = abs(dot(r_normal,lightLocation));\\n        //if(opacity < 1.0) light = abs(light);\\n        if(enableLight == 1.0){\\n            gl_FragColor.rgb *= light;\\n            // gl_FragColor.rgb = vec3(light,light,light);\\n        }\\n  }\\n  \";\n/**\r\n precision mediump float;\r\n varying vec4 currentColor;\r\n varying vec2 v_texcoord;\r\n uniform vec2 singleCanvas;\r\n uniform sampler2D u_texture;\r\n void main() {\r\n        vec2 coord = vec2(v_texcoord.x / singleCanvas.x , v_texcoord.y/singleCanvas.y);\r\n        vec4 color = currentColor;\r\n        gl_FragColor = color * texture2D(u_texture,coord);\r\n  }\r\n */\n\nvar _program = Symbol('WebGL的program');\nvar _maxTransformMatrixNum = Symbol('转换矩阵变量可用的最大数量');\n\nvar WebGLRender = function () {\n    function WebGLRender(gl, p) {\n        _classCallCheck(this, WebGLRender);\n\n        p = p || {};\n        this.gl = gl;\n        this.DEBUG_DRAW_COUNT = 0;\n        this.defaultTransformMatrix = _Mat2.default.identity();\n        this.orthoProjectionMatrix = _Mat2.default.identity();\n        this.perspectiveMatrix = _Mat2.default.identity();\n        this.cameraPosition = { x: 0, y: 0, z: 0 };\n        this.lookTarget = { x: undefined, y: undefined, z: undefined };\n        var projectionType = p['projectionType'] || 0;\n\n        var textureMaxSize = p['textureMaxSize'] || gl.getParameter(this.gl.MAX_TEXTURE_SIZE);\n        var maxVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n        // 顶点作色器里已经用了一个mat4了，就是4个vector,减去这4个然后除以4就得到可以定义的最大mat4数组\n        var maxTransformNum = p['maxTransformNum'] || Math.floor((maxVectors - 4) / 4);\n        // debug:\n        maxTransformNum = 2;\n        this[_maxTransformMatrixNum] = maxTransformNum;\n        this.enableDepthTest = p['enableDepthTest'];\n        if (this.enableDepthTest == null) this.enableDepthTest = false;\n        this.textureManager = null;\n        this.vdo = null;\n        // this.verticesData = null;\n        // this.fragmentData = null;\n        // this.indexData = null;\n        // this.transformMatrixData = null;\n        this.canvasWidth = -1;\n        this.canvasHeight = -1;\n        this.lightPosition = new Float32Array(3);\n        this.lightPosition[0] = gl.canvas.width / 2;\n        this.lightPosition[1] = gl.canvas.height / 2;\n        this.lightPosition[2] = 0;\n        this.projectionType = projectionType;\n        this.fov = p['fov'] || 40;\n        this.defaultDepth = 0;\n        this.tempCanvas = p['tempCanvas'] || new _TempCanvas2.default();\n        this.init();\n        this.textureManager.maxHeight = textureMaxSize;\n        this.textureManager.maxWidth = this.textureManager.maxHeight;\n        var enableLight = p['enableLight'];\n        if (enableLight == null) enableLight = false;\n        this.enableLight(enableLight);\n    }\n\n    _createClass(WebGLRender, [{\n        key: \"enableLight\",\n        value: function enableLight(flag) {\n            var value = 0;\n            if (flag) value = 1.0;else value = 0;\n            this.gl.uniform1f(this.shaderInformation.enableLight, value);\n        }\n    }, {\n        key: \"clean\",\n        value: function clean(clearAllTexture) {\n            this.DEBUG_DRAW_COUNT = 0;\n            this.gl.clearColor(0, 0, 0, 1);\n            // this.gl.colorMask(false, false, false, true);\n            this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\n            this.textureManager.clean(clearAllTexture);\n        }\n    }, {\n        key: \"initRending\",\n        value: function initRending() {\n            var gl = this.gl;\n            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n        }\n    }, {\n        key: \"setUniformTransformMatrix\",\n        value: function setUniformTransformMatrix(matrix, id) {\n            var gl = this.gl;\n            gl.uniformMatrix4fv(this.shaderInformation.transformMatrixArray[id], false, matrix);\n        }\n    }, {\n        key: \"prepareWebGLBuffer\",\n        value: function prepareWebGLBuffer(opacity) {\n            if (opacity == undefined) opacity = false;\n            var vbuffer = this.vdo.verticesData.buffer;\n            var fbuffer = this.vdo.fragmentData.buffer;\n            var ibuffer = this.vdo.indexData.dataArray;\n            if (opacity) {\n                vbuffer = this.vdo.opacityVerticesData.buffer;\n                fbuffer = this.vdo.opacityFragmentData.buffer;\n                ibuffer = this.vdo.opacityIndexData.dataArray;\n            }\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.enableVertexAttribArray(shaderInfo.vertexAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.verticesBuffer);\n            // gl.bufferData(gl.ARRAY_BUFFER, this.verticesData.buffer, gl.DYNAMIC_DRAW);\n            gl.bufferData(gl.ARRAY_BUFFER, vbuffer, gl.DYNAMIC_DRAW);\n\n            var size = 3;\n            var type = gl.FLOAT;\n            var normalize = false;\n            var stride = 32;\n            var offset = 0;\n            gl.vertexAttribPointer(shaderInfo.vertexAttribute, size, type, normalize, stride, offset);\n            //法向量数据：\n            type = gl.FLOAT;\n            size = 3;\n            offset = 16; // 4 * 4;//因为有一个空的float32，所以要多移动4个字节\n            normalize = true; //单位划该向量\n            gl.vertexAttribPointer(shaderInfo.normalAttribute, size, type, normalize, stride, offset);\n\n            gl.enableVertexAttribArray(shaderInfo.colorAttribute);\n            gl.enableVertexAttribArray(shaderInfo.textureCoordAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.fragmentBuffer);\n            // gl.bufferData(gl.ARRAY_BUFFER, this.fragmentData.buffer, gl.DYNAMIC_DRAW);\n            gl.bufferData(gl.ARRAY_BUFFER, fbuffer, gl.DYNAMIC_DRAW);\n\n            type = gl.UNSIGNED_BYTE;\n            stride = this.vdo.fragmentData.singleDataByteLength;\n            size = 3;\n            offset = 0;\n            normalize = false;\n            gl.vertexAttribPointer(shaderInfo.colorAttribute, size, type, normalize, stride, offset);\n\n            type = gl.UNSIGNED_BYTE;\n            // stride = this.vdo.fragmentData.singleDataByteLength;\n            size = 1;\n            offset = 3;\n            normalize = false;\n            gl.vertexAttribPointer(shaderInfo.filterTypeAttribute, size, type, normalize, stride, offset);\n\n            type = gl.FLOAT;\n            size = 1;\n            offset = 4;\n            gl.vertexAttribPointer(shaderInfo.alphaAttribute, size, type, normalize, stride, offset);\n\n            type = gl.FLOAT;\n            size = 2;\n            offset = 8;\n            gl.vertexAttribPointer(shaderInfo.textureCoordAttribute, size, type, normalize, stride, offset);\n\n            // gl.enableVertexAttribArray(shaderInfo.transformMatrixIndex);\n            // gl.bindBuffer(gl.ARRAY_BUFFER, shaderInfo.matrixIndexBuffer);\n            // gl.bufferData(gl.ARRAY_BUFFER, this.transformMatrixData.buffer, gl.DYNAMIC_DRAW);\n            // type = gl.FLOAT;\n            // size = 1;\n            // offset = 0;\n            // stride = 4;\n            // gl.vertexAttribPointer(shaderInfo.transformMatrixIndex, size, type, normalize, stride, offset);\n\n            // calculateDataProperty:\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, shaderInfo.indexDataBuffer);\n            // gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indexData.dataArray, gl.DYNAMIC_DRAW);\n            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, ibuffer, gl.DYNAMIC_DRAW);\n        }\n    }, {\n        key: \"executeRenderAction\",\n        value: function executeRenderAction(actionList) {\n            if (this.vdo == null) return;\n            this.prepareWebGLBuffer();\n            var matrixIndex = 1; // 每次绘制都要重新设置矩阵的索引\n            var lastAction = null;\n            var startIndex = 0;\n            var rendNumber = 0;\n            var opacityActionArray = [];\n            for (var i = 0; i < actionList.length; i++) {\n                var currentAction = actionList[i];\n                if (currentAction.opacityPointNumber !== 0) opacityActionArray.push(currentAction);\n                if (currentAction.renderPointNumber === 0) continue;\n                if (lastAction == null) lastAction = currentAction;\n                if (currentAction.applyMatrix != lastAction.applyMatrix) {\n                    this.renderVertices(startIndex, rendNumber, lastAction.textureIndex, lastAction.applyMatrix);\n                    lastAction = currentAction;\n                    startIndex += rendNumber;\n                    rendNumber = currentAction.renderPointNumber;\n                } else {\n                    if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                        this.renderVertices(startIndex, rendNumber, lastAction.textureIndex, lastAction.applyMatrix);\n                        lastAction = currentAction;\n                        startIndex += rendNumber;\n                        rendNumber = 0;\n                    }\n                    if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n                        lastAction = currentAction;\n                    }\n                    rendNumber += currentAction.renderPointNumber;\n                }\n                // 先收集顶点数据，顶点的矩阵在下一步再设置\n                // if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                //     this.renderVertices(startIndex, rendNumber, lastAction.textureIndex);\n                //     lastAction = currentAction;\n                //     startIndex += rendNumber;\n                //     rendNumber = 0;\n                // }\n                // if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n                //     lastAction = currentAction;\n                // }\n                // rendNumber += currentAction.renderPointNumber;\n            }\n\n            if (lastAction != undefined) {\n                this.renderVertices(startIndex, rendNumber, lastAction.textureIndex, lastAction.applyMatrix);\n            }\n\n            //绘制透明：\n            if (opacityActionArray.length == 0) return;\n            this.prepareWebGLBuffer(true);\n            this.gl.depthMask(false);\n            matrixIndex = 1; // 每次绘制都要重新设置矩阵的索引\n            lastAction = null;\n            startIndex = 0;\n            rendNumber = 0;\n            for (var _i = 0; _i < opacityActionArray.length; _i++) {\n                var _currentAction = opacityActionArray[_i];\n                if (lastAction == null) lastAction = _currentAction;\n                if (_currentAction.applyMatrix != lastAction.applyMatrix) {\n                    this.renderVertices(startIndex, rendNumber, lastAction.textureIndex, lastAction.applyMatrix);\n                    lastAction = _currentAction;\n                    startIndex += rendNumber;\n                    rendNumber = _currentAction.opacityPointNumber;\n                } else {\n                    if (_currentAction.textureIndex != lastAction.textureIndex && _currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                        this.renderVertices(startIndex, rendNumber, lastAction.textureIndex, lastAction.applyMatrix);\n                        lastAction = _currentAction;\n                        startIndex += rendNumber;\n                        rendNumber = 0;\n                    }\n                    if (lastAction.textureIndex == -1 && _currentAction.textureIndex != -1) {\n                        lastAction = _currentAction;\n                    }\n                    rendNumber += _currentAction.opacityPointNumber;\n                }\n                // 先收集顶点数据，顶点的矩阵在下一步再设置\n                // if (currentAction.textureIndex != lastAction.textureIndex && currentAction.textureIndex != -1 && lastAction.textureIndex != -1) {\n                //     this.renderVertices(startIndex, rendNumber, lastAction.textureIndex);\n                //     lastAction = currentAction;\n                //     startIndex += rendNumber;\n                //     rendNumber = 0;\n                // }\n                // if (lastAction.textureIndex == -1 && currentAction.textureIndex != -1) {\n                //     lastAction = currentAction;\n                // }\n                // rendNumber += currentAction.renderPointNumber;\n            }\n\n            if (lastAction != undefined) {\n                this.renderVertices(startIndex, rendNumber, lastAction.textureIndex, lastAction.applyMatrix);\n            }\n\n            this.gl.depthMask(true);\n        }\n    }, {\n        key: \"renderVertices\",\n        value: function renderVertices(startIndex, renderPointNumber, textureIndex, transformMatrix) {\n            if (renderPointNumber == 0) {\n                return;\n            }\n            var gl = this.gl;\n            this.initProjectionMatrix();\n            if (transformMatrix != null) {\n                var m = _Mat2.default.identity();\n                _Mat2.default.multiply(m, transformMatrix, this.defaultTransformMatrix);\n                gl.uniformMatrix4fv(this.shaderInformation.transformMatrixArray[0], false, m);\n            }\n            this.gl.uniform3f(this.shaderInformation.lightPosition, this.lightPosition[0], this.lightPosition[1], this.lightPosition[2]);\n            this.configTexture(textureIndex);\n            // offset 是字节偏移，所以要乘以2，因为每一个index是2个字节\n            gl.drawElements(gl.TRIANGLES, renderPointNumber, gl.UNSIGNED_SHORT, startIndex * 2);\n            this.DEBUG_DRAW_COUNT++;\n        }\n    }, {\n        key: \"initProjectionMatrix\",\n        value: function initProjectionMatrix() {\n            var gl = this.gl;\n            var halfFOVRadian = this.fov * Math.PI / 360;\n\n            // 设置透视矩阵\n            // if (this.canvasHeight != gl.canvas.height && this.canvasWidth != gl.canvas.width) {\n            // let t = Math.tan((this.fov) * Math.PI / 180);\n            // let defaultDepth = -gl.canvas.height / (2 * t);\n            var t = Math.tan(halfFOVRadian);\n            this.defaultDepth = -gl.canvas.height / (2 * t);\n            // 为了配合预设的深度\n            _Mat2.default.identityMatrix(this.defaultTransformMatrix);\n            _Mat2.default.translationMatrix(this.defaultTransformMatrix, 0, 0, this.defaultDepth);\n            gl.uniformMatrix4fv(this.shaderInformation.transformMatrixArray[0], false, this.defaultTransformMatrix);\n            var m1 = void 0;\n            var near = 1;\n            if (this.projectionType == 0) {\n                m1 = _Mat2.default.orthoProjection(0, 0, gl.canvas.width, gl.canvas.height, near, Math.abs(this.defaultDepth * 2), this.orthoProjectionMatrix);\n            } else {\n                this.initLookAtTarget(this.defaultDepth);\n                m1 = _Mat2.default.perspective3(halfFOVRadian * 2, gl.canvas.width, gl.canvas.height, near, Math.abs(this.defaultDepth * 10), this.perspectiveMatrix);\n                var cm = _Mat2.default.lookAt(this.cameraPosition, this.lookTarget);\n                _Mat2.default.inverse(cm, cm);\n                _Mat2.default.multiply(m1, m1, cm);\n            }\n            gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m1);\n            this.canvasHeight = gl.canvas.height;\n            this.canvasWidth = gl.canvas.width;\n            // }\n        }\n    }, {\n        key: \"initLookAtTarget\",\n        value: function initLookAtTarget(defaultDepth) {\n            if (this.lookTarget.x === undefined) {\n                this.lookTarget.x = 0;\n            }\n            if (this.lookTarget.y === undefined) {\n                this.lookTarget.y = 0;\n            }\n            if (this.lookTarget.z === undefined) {\n                this.lookTarget.z = defaultDepth;\n            }\n        }\n    }, {\n        key: \"setLightPosition\",\n        value: function setLightPosition(x, y, z) {\n            this.lightPosition[0] = x;\n            this.lightPosition[1] = y;\n            this.lightPosition[2] = z;\n        }\n    }, {\n        key: \"configTexture\",\n        value: function configTexture(textureIndex) {\n            if (textureIndex == null) textureIndex = -1;\n            var gl = this.gl;\n            var shaderInfo = this.shaderInformation;\n            gl.uniform1i(shaderInfo.textureLocation, 0);\n            var texture = void 0;\n            var c = void 0;\n            if (textureIndex === -1) {\n                texture = shaderInfo.blackTexture;\n                c = { width: 1, height: 1 };\n            } else {\n                texture = this.textureManager.textureArray[textureIndex];\n                c = { width: texture.width, height: texture.height };\n                texture = texture.glTexture;\n            }\n            gl.uniform2f(shaderInfo.singleCanvas, c.width, c.height);\n            gl.activeTexture(gl.TEXTURE0 + 0);\n            gl.bindTexture(gl.TEXTURE_2D, texture);\n        }\n    }, {\n        key: \"createShaderProgram\",\n        value: function createShaderProgram() {\n            var gl = this.gl;\n            var vertexShader = this.loadShader(gl.VERTEX_SHADER, this.getVertexShaderSource(this.maxTransformMatrixNum));\n            var fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fsSource);\n\n            // 创建Shader程序，一个是顶点shader一个是片段shader\n            var shaderProgram = gl.createProgram();\n            gl.attachShader(shaderProgram, vertexShader);\n            gl.attachShader(shaderProgram, fragmentShader);\n            gl.linkProgram(shaderProgram);\n\n            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {\n                console.error('无法初始化Program: ' + gl.getProgramInfoLog(shaderProgram));\n                gl.deleteProgram(shaderProgram);\n                return null;\n            }\n            gl.useProgram(shaderProgram);\n            return shaderProgram;\n        }\n    }, {\n        key: \"init\",\n        value: function init() {\n            var gl = this.gl;\n            this.gl.enable(this.gl.BLEND);\n            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n            if (this.enableDepthTest) {\n                gl.enable(gl.DEPTH_TEST);\n                gl.depthFunc(gl.LEQUAL);\n            } else {\n                this.gl.disable(this.gl.DEPTH_TEST);\n            }\n            this[_program] = this.createShaderProgram();\n            var program = this[_program];\n            this.shaderInformation = this.initShaderInformation(program);\n            this.textureManager = new _TextureManager2.default(801, gl, 10, 4, this.tempCanvas);\n            this.initProjectionMatrix();\n        }\n\n        // setPerspective(viewAngel, near, far) {\n        //     let aspect = this.gl.canvas.clientWidth / this.gl.canvas.clientHeight;\n        //     let m = Mat4.perspective2(0, 0, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight, near, far);\n        //     m = Mat4.perspective(viewAngel, aspect, near, far);\n        //     m = Mat4.perspective3(viewAngel, this.gl.canvas.clientWidth, this.gl.canvas.clientHeight, near, far);\n        //     this.gl.uniformMatrix4fv(this.shaderInformation.perspectiveMatrix, false, m);\n        // }\n\n    }, {\n        key: \"initShaderInformation\",\n        value: function initShaderInformation(program) {\n            var gl = this.gl;\n\n            var textureCoordAttribute = gl.getAttribLocation(program, \"u_texCoord\");\n            gl.enableVertexAttribArray(textureCoordAttribute);\n\n            var filterTypeAttribute = gl.getAttribLocation(program, \"u_filterType\");\n            gl.enableVertexAttribArray(filterTypeAttribute);\n\n            var vertexAttribute = gl.getAttribLocation(program, \"a_position\");\n            gl.enableVertexAttribArray(vertexAttribute);\n\n            var normalAttribute = gl.getAttribLocation(program, \"a_normal\");\n            gl.enableVertexAttribArray(normalAttribute);\n\n            // let transformMatrixIndex = gl.getAttribLocation(program, \"transform_matrix_index\");\n            // gl.enableVertexAttribArray(transformMatrixIndex);\n\n            var colorAttribute = gl.getAttribLocation(program, 'color');\n            gl.enableVertexAttribArray(colorAttribute);\n\n            var alphaAttribute = gl.getAttribLocation(program, 'alpha');\n            gl.enableVertexAttribArray(alphaAttribute);\n\n            // 转化矩阵全局变量\n            var perspectiveMatrix = gl.getUniformLocation(program, \"perspective_matrix\");\n            var transformMatrixArray = new Array(this.maxTransformMatrixNum);\n            for (var i = 0; i < transformMatrixArray.length; i++) {\n                transformMatrixArray[i] = gl.getUniformLocation(program, \"transform_matrix_array[\" + i + \"]\");\n            }\n\n            var singleCanvas = gl.getUniformLocation(program, \"singleCanvas\");\n            var lightPosition = gl.getUniformLocation(program, \"u_lightPosition\");\n            var enableLight = gl.getUniformLocation(program, \"enableLight\");\n            var textureLocation = gl.getUniformLocation(program, \"u_texture\");\n            // 创建数据缓存\n            var verticesBuffer = gl.createBuffer();\n            var matrixIndexBuffer = gl.createBuffer();\n            var fragmentBuffer = gl.createBuffer();\n            var indexDataBuffer = gl.createBuffer();\n\n            var blackTexture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, blackTexture);\n            var blackPixel = new Uint8Array([255, 255, 255, 255]);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, blackPixel);\n            gl.bindTexture(gl.TEXTURE_2D, null);\n            return {\n                vertexAttribute: vertexAttribute,\n                normalAttribute: normalAttribute,\n                colorAttribute: colorAttribute,\n                filterTypeAttribute: filterTypeAttribute,\n                alphaAttribute: alphaAttribute,\n                textureCoordAttribute: textureCoordAttribute,\n                verticesBuffer: verticesBuffer,\n                fragmentBuffer: fragmentBuffer,\n                matrixIndexBuffer: matrixIndexBuffer,\n                indexDataBuffer: indexDataBuffer,\n                perspectiveMatrix: perspectiveMatrix,\n                transformMatrixArray: transformMatrixArray,\n                // transformMatrixIndex: transformMatrixIndex,\n                singleCanvas: singleCanvas,\n                textureLocation: textureLocation,\n                blackTexture: blackTexture,\n                lightPosition: lightPosition,\n                enableLight: enableLight,\n                webgl: gl\n            };\n        }\n\n        /**\r\n         * 创建作色器\r\n         * @param type 着色器类型\r\n         * @param source 代码源\r\n         * @returns {*} Shader对象\r\n         */\n\n    }, {\n        key: \"loadShader\",\n        value: function loadShader(type, source) {\n            var gl = this.gl;\n            var shader = gl.createShader(type);\n            // 把GLSL代码给shader\n            gl.shaderSource(shader, source);\n            // 编译着色器程序\n            gl.compileShader(shader);\n            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n                console.error('着色器编译错误: ' + gl.getShaderInfoLog(shader));\n                gl.deleteShader(shader);\n                return null;\n            }\n            return shader;\n        }\n\n        /**\r\n           这样我看得更清楚些\r\n           attribute vec4 color;\r\n         attribute vec4 a_position;\r\n         attribute vec2 u_texCoord;\r\n         attribute vec2 transform_matrix_index;\r\n         varying vec2 v_texcoord;\r\n         varying vec4 currentColor;\r\n         uniform mat4 texture_matrix;\r\n         uniform mat4 perspective_matrix;\r\n         uniform mat4 transform_matrix_array[transformMatrixCount];\r\n         void main() {\r\n                // v_texcoord = u_texCoord;\r\n                vec4 new_position = transform_matrix_array[0] * a_position;\r\n                vec4 finalPosition = perspective_matrix* new_position;\r\n                currentColor = vec4 (color.xyz/255.0,color.w/100.0);\r\n                gl_Position = finalPosition;\r\n        };\r\n           * @param transformMatrixCount\r\n         * @returns {string}\r\n         */\n\n    }, {\n        key: \"getVertexShaderSource\",\n        value: function getVertexShaderSource(transformMatrixCount) {\n            var vsSource = ' attribute vec3 color;\\n' + '     attribute vec4 a_position;\\n' + '     attribute vec3 a_normal;\\n' + '     attribute float alpha;\\n' + '     attribute vec2 u_texCoord;\\n' + '     attribute float u_filterType;\\n' + '     varying vec3 v_position;\\n' + '     varying float v_filterType;\\n' + '     attribute float transform_matrix_index;\\n' + '     varying vec2 v_texcoord;\\n' + '     varying vec4 currentColor;\\n' + '     varying vec3 normal;\\n' + '     uniform mat4 perspective_matrix;\\n' + '     uniform mat4 transform_matrix_array[' + transformMatrixCount + '];\\n' + '     void main() {\\n' + '            normal = a_normal;\\n' + '            float ft = u_filterType;\\n' + '            v_filterType = u_filterType + 0.5;\\n' + '            vec4 yuandian = vec4(0,0,0,1);\\n' + '            v_texcoord = u_texCoord;\\n' + '            vec4 new_position = transform_matrix_array[0] * a_position;\\n' + '            v_position = vec3(new_position.xyz);\\n' + '            vec4 finalPosition = perspective_matrix* new_position;\\n' + '            currentColor = vec4 (color.xyz/255.0,alpha);\\n' + '            gl_Position = finalPosition;\\n' + '    }';\n            return vsSource;\n        }\n    }, {\n        key: \"maxTransformMatrixNum\",\n        get: function get() {\n            return this[_maxTransformMatrixNum];\n        }\n    }]);\n\n    return WebGLRender;\n}();\n\nexports.default = WebGLRender;\n\n//# sourceURL=webpack://tielifa/./build/webgl/WebGLRender.js?");

/***/ }),

/***/ 0:
/*!************************************!*\
  !*** multi ./build/EntryPoints.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./build/EntryPoints.js */\"./build/EntryPoints.js\");\n\n\n//# sourceURL=webpack://tielifa/multi_./build/EntryPoints.js?");

/***/ })

/******/ })["default"];
});